{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Dec = void 0;\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst int_1 = require(\"./int\");\nconst coin_utils_1 = require(\"./coin-utils\");\nconst etc_1 = require(\"./etc\");\nclass Dec {\n  /**\n   * Create a new Dec from integer with decimal place at prec\n   * @param int - Parse a number | bigInteger | string into a Dec.\n   * If int is string and contains dot(.), prec is ignored and automatically calculated.\n   * @param prec - Precision\n   */\n  constructor(int) {\n    let prec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (typeof int === \"number\") {\n      int = int.toString();\n    }\n    if (typeof int === \"string\") {\n      if (int.length === 0) {\n        throw new Error(\"empty string\");\n      }\n      if (!etc_1.isValidDecimalString(int)) {\n        if (etc_1.isExponentDecString(int)) {\n          int = etc_1.exponentDecStringToDecString(int);\n        } else {\n          throw new Error(`invalid decimal: ${int}`);\n        }\n      }\n      // Even if an input with more than 18 decimals, it does not throw an error and ignores the rest.\n      const reduced = Dec.reduceDecimalsFromString(int);\n      if (reduced.isDownToZero) {\n        // However, as a result, if the input becomes 0, a problem may occur in mul or quo. In this case, print a warning.\n        console.log(`WARNING: Got ${int}. Dec can only handle up to 18 decimals. However, since the decimal point of the input exceeds 18 digits, the remainder is discarded. As a result, input becomes 0.`);\n      }\n      int = reduced.res;\n      if (int.indexOf(\".\") >= 0) {\n        prec = int.length - int.indexOf(\".\") - 1;\n        int = int.replace(\".\", \"\");\n      }\n      this.int = big_integer_1.default(int);\n    } else if (int instanceof int_1.Int) {\n      this.int = big_integer_1.default(int.toString());\n    } else if (typeof int === \"bigint\") {\n      this.int = big_integer_1.default(int);\n    } else {\n      this.int = big_integer_1.default(int);\n    }\n    this.int = this.int.multiply(Dec.calcPrecisionMultiplier(prec));\n    this.checkBitLen();\n  }\n  static calcPrecisionMultiplier(prec) {\n    if (prec < 0) {\n      throw new Error(\"Invalid prec\");\n    }\n    if (prec > Dec.precision) {\n      throw new Error(\"Too much precision\");\n    }\n    if (Dec.precisionMultipliers[prec.toString()]) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return Dec.precisionMultipliers[prec.toString()];\n    }\n    const zerosToAdd = Dec.precision - prec;\n    const multiplier = big_integer_1.default(10).pow(zerosToAdd);\n    Dec.precisionMultipliers[prec.toString()] = multiplier;\n    return multiplier;\n  }\n  static reduceDecimalsFromString(str) {\n    const decimalPointIndex = str.indexOf(\".\");\n    if (decimalPointIndex < 0) {\n      return {\n        res: str,\n        isDownToZero: false\n      };\n    }\n    const exceededDecimals = str.length - 1 - decimalPointIndex - Dec.precision;\n    if (exceededDecimals <= 0) {\n      return {\n        res: str,\n        isDownToZero: false\n      };\n    }\n    const res = str.slice(0, str.length - exceededDecimals);\n    return {\n      res,\n      isDownToZero: /^[0.]*$/.test(res)\n    };\n  }\n  checkBitLen() {\n    if (this.int.abs().gt(Dec.maxDec)) {\n      throw new Error(`Integer out of range ${this.int.toString()}`);\n    }\n  }\n  isZero() {\n    return this.int.eq(big_integer_1.default(0));\n  }\n  isNegative() {\n    return this.int.isNegative();\n  }\n  isPositive() {\n    return this.int.isPositive();\n  }\n  equals(d2) {\n    return this.int.eq(d2.int);\n  }\n  /**\n   * Alias for the greater method.\n   */\n  gt(d2) {\n    return this.int.gt(d2.int);\n  }\n  /**\n   * Alias for the greaterOrEquals method.\n   */\n  gte(d2) {\n    return this.int.geq(d2.int);\n  }\n  /**\n   * Alias for the lesser method.\n   */\n  lt(d2) {\n    return this.int.lt(d2.int);\n  }\n  /**\n   * Alias for the lesserOrEquals method.\n   */\n  lte(d2) {\n    return this.int.leq(d2.int);\n  }\n  /**\n   * reverse the decimal sign.\n   */\n  neg() {\n    return new Dec(this.int.negate(), Dec.precision);\n  }\n  /**\n   * Returns the absolute value of a decimals.\n   */\n  abs() {\n    return new Dec(this.int.abs(), Dec.precision);\n  }\n  add(d2) {\n    return new Dec(this.int.add(d2.int), Dec.precision);\n  }\n  sub(d2) {\n    return new Dec(this.int.subtract(d2.int), Dec.precision);\n  }\n  pow(n) {\n    if (n.isZero()) {\n      return new Dec(1);\n    }\n    if (n.isNegative()) {\n      return new Dec(1).quo(this.pow(n.abs()));\n    }\n    let base = new Dec(this.int, Dec.precision);\n    let tmp = new Dec(1);\n    for (let i = n; i.gt(new int_1.Int(1)); i = i.div(new int_1.Int(2))) {\n      if (!i.mod(new int_1.Int(2)).isZero()) {\n        tmp = tmp.mul(base);\n      }\n      base = base.mul(base);\n    }\n    return base.mul(tmp);\n  }\n  mul(d2) {\n    return new Dec(this.mulRaw(d2).chopPrecisionAndRound(), Dec.precision);\n  }\n  mulTruncate(d2) {\n    return new Dec(this.mulRaw(d2).chopPrecisionAndTruncate(), Dec.precision);\n  }\n  mulRaw(d2) {\n    return new Dec(this.int.multiply(d2.int), Dec.precision);\n  }\n  quo(d2) {\n    return new Dec(this.quoRaw(d2).chopPrecisionAndRound(), Dec.precision);\n  }\n  quoTruncate(d2) {\n    return new Dec(this.quoRaw(d2).chopPrecisionAndTruncate(), Dec.precision);\n  }\n  quoRoundUp(d2) {\n    return new Dec(this.quoRaw(d2).chopPrecisionAndRoundUp(), Dec.precision);\n  }\n  quoRaw(d2) {\n    const precision = Dec.calcPrecisionMultiplier(0);\n    // multiply precision twice\n    const mul = this.int.multiply(precision).multiply(precision);\n    return new Dec(mul.divide(d2.int), Dec.precision);\n  }\n  isInteger() {\n    const precision = Dec.calcPrecisionMultiplier(0);\n    return this.int.remainder(precision).equals(big_integer_1.default(0));\n  }\n  /**\n   * Remove a Precision amount of rightmost digits and perform bankers rounding\n   * on the remainder (gaussian rounding) on the digits which have been removed.\n   */\n  chopPrecisionAndRound() {\n    // Remove the negative and add it back when returning\n    if (this.isNegative()) {\n      const absoulteDec = this.abs();\n      const choped = absoulteDec.chopPrecisionAndRound();\n      return choped.negate();\n    }\n    const precision = Dec.calcPrecisionMultiplier(0);\n    const fivePrecision = precision.divide(big_integer_1.default(2));\n    // Get the truncated quotient and remainder\n    const {\n      quotient,\n      remainder\n    } = this.int.divmod(precision);\n    // If remainder is zero\n    if (remainder.equals(big_integer_1.default(0))) {\n      return quotient;\n    }\n    if (remainder.lt(fivePrecision)) {\n      return quotient;\n    } else if (remainder.gt(fivePrecision)) {\n      return quotient.add(big_integer_1.default(1));\n    } else {\n      // always round to an even number\n      if (quotient.divide(big_integer_1.default(2)).equals(big_integer_1.default(0))) {\n        return quotient;\n      } else {\n        return quotient.add(big_integer_1.default(1));\n      }\n    }\n  }\n  chopPrecisionAndRoundUp() {\n    // Remove the negative and add it back when returning\n    if (this.isNegative()) {\n      const absoulteDec = this.abs();\n      // truncate since d is negative...\n      const choped = absoulteDec.chopPrecisionAndTruncate();\n      return choped.negate();\n    }\n    const precision = Dec.calcPrecisionMultiplier(0);\n    // Get the truncated quotient and remainder\n    const {\n      quotient,\n      remainder\n    } = this.int.divmod(precision);\n    // If remainder is zero\n    if (remainder.equals(big_integer_1.default(0))) {\n      return quotient;\n    }\n    return quotient.add(big_integer_1.default(1));\n  }\n  /**\n   * Similar to chopPrecisionAndRound, but always rounds down\n   */\n  chopPrecisionAndTruncate() {\n    const precision = Dec.calcPrecisionMultiplier(0);\n    return this.int.divide(precision);\n  }\n  toString() {\n    let prec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Dec.precision;\n    let locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const precision = Dec.calcPrecisionMultiplier(0);\n    const int = this.int.abs();\n    const {\n      quotient: integer,\n      remainder: fraction\n    } = int.divmod(precision);\n    let fractionStr = fraction.toString(10);\n    for (let i = 0, l = fractionStr.length; i < Dec.precision - l; i++) {\n      fractionStr = \"0\" + fractionStr;\n    }\n    fractionStr = fractionStr.substring(0, prec);\n    const isNegative = this.isNegative() && !(integer.eq(big_integer_1.default(0)) && fractionStr.length === 0);\n    const integerStr = locale ?\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    coin_utils_1.CoinUtils.integerStringToUSLocaleString(integer.toString()) : integer.toString();\n    return `${isNegative ? \"-\" : \"\"}${integerStr}${fractionStr.length > 0 ? \".\" + fractionStr : \"\"}`;\n  }\n  round() {\n    return new int_1.Int(this.chopPrecisionAndRound());\n  }\n  roundUp() {\n    return new int_1.Int(this.chopPrecisionAndRoundUp());\n  }\n  truncate() {\n    return new int_1.Int(this.chopPrecisionAndTruncate());\n  }\n  roundDec() {\n    return new Dec(this.chopPrecisionAndRound(), 0);\n  }\n  roundUpDec() {\n    return new Dec(this.chopPrecisionAndRoundUp(), 0);\n  }\n  truncateDec() {\n    return new Dec(this.chopPrecisionAndTruncate(), 0);\n  }\n}\nexports.Dec = Dec;\nDec.precision = 18;\n// Bytes required to represent the above precision is 18.\n// Ceiling[Log2[999 999 999 999 999 999]]\nDec.decimalPrecisionBits = 60;\n// Max bit length for `Dec` is 256 + 60(decimalPrecisionBits)\n// The int in the `Dec` is handled as integer assuming that it has 18 precision.\n// (2 ** (256 + 60) - 1)\nDec.maxDec = big_integer_1.default(\"133499189745056880149688856635597007162669032647290798121690100488888732861290034376435130433535\");\nDec.precisionMultipliers = {};","map":{"version":3,"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AAMA,MAAaA,GAAG;EA+Dd;;;;;;EAMAC,YAAYC,GAA+B,EAAkB;IAAA,IAAhBC,2EAAe,CAAC;IAC3D,IAAI,OAAOD,GAAG,KAAK,QAAQ,EAAE;MAC3BA,GAAG,GAAGA,GAAG,CAACE,QAAQ,EAAE;;IAGtB,IAAI,OAAOF,GAAG,KAAK,QAAQ,EAAE;MAC3B,IAAIA,GAAG,CAACG,MAAM,KAAK,CAAC,EAAE;QACpB,MAAM,IAAIC,KAAK,CAAC,cAAc,CAAC;;MAEjC,IAAI,CAACC,0BAAoB,CAACL,GAAG,CAAC,EAAE;QAC9B,IAAIK,yBAAmB,CAACL,GAAG,CAAC,EAAE;UAC5BA,GAAG,GAAGK,kCAA4B,CAACL,GAAG,CAAC;SACxC,MAAM;UACL,MAAM,IAAII,KAAK,CAAC,oBAAoBJ,GAAG,EAAE,CAAC;;;MAG9C;MACA,MAAMM,OAAO,GAAGR,GAAG,CAACS,wBAAwB,CAACP,GAAG,CAAC;MACjD,IAAIM,OAAO,CAACE,YAAY,EAAE;QACxB;QACAC,OAAO,CAACC,GAAG,CACT,gBAAgBV,GAAG,qKAAqK,CACzL;;MAEHA,GAAG,GAAGM,OAAO,CAACK,GAAG;MACjB,IAAIX,GAAG,CAACY,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;QACzBX,IAAI,GAAGD,GAAG,CAACG,MAAM,GAAGH,GAAG,CAACY,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC;QACxCZ,GAAG,GAAGA,GAAG,CAACa,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC;;MAE5B,IAAI,CAACb,GAAG,GAAGc,qBAAU,CAACd,GAAG,CAAC;KAC3B,MAAM,IAAIA,GAAG,YAAYe,SAAG,EAAE;MAC7B,IAAI,CAACf,GAAG,GAAGc,qBAAU,CAACd,GAAG,CAACE,QAAQ,EAAE,CAAC;KACtC,MAAM,IAAI,OAAOF,GAAG,KAAK,QAAQ,EAAE;MAClC,IAAI,CAACA,GAAG,GAAGc,qBAAU,CAACd,GAAG,CAAC;KAC3B,MAAM;MACL,IAAI,CAACA,GAAG,GAAGc,qBAAU,CAACd,GAAG,CAAC;;IAG5B,IAAI,CAACA,GAAG,GAAG,IAAI,CAACA,GAAG,CAACgB,QAAQ,CAAClB,GAAG,CAACmB,uBAAuB,CAAChB,IAAI,CAAC,CAAC;IAE/D,IAAI,CAACiB,WAAW,EAAE;EACpB;EA/FU,OAAOD,uBAAuB,CACtChB,IAAY;IAEZ,IAAIA,IAAI,GAAG,CAAC,EAAE;MACZ,MAAM,IAAIG,KAAK,CAAC,cAAc,CAAC;;IAEjC,IAAIH,IAAI,GAAGH,GAAG,CAACqB,SAAS,EAAE;MACxB,MAAM,IAAIf,KAAK,CAAC,oBAAoB,CAAC;;IAEvC,IAAIN,GAAG,CAACsB,oBAAoB,CAACnB,IAAI,CAACC,QAAQ,EAAE,CAAC,EAAE;MAC7C;MACA,OAAOJ,GAAG,CAACsB,oBAAoB,CAACnB,IAAI,CAACC,QAAQ,EAAE,CAAE;;IAGnD,MAAMmB,UAAU,GAAGvB,GAAG,CAACqB,SAAS,GAAGlB,IAAI;IACvC,MAAMqB,UAAU,GAAGR,qBAAU,CAAC,EAAE,CAAC,CAACS,GAAG,CAACF,UAAU,CAAC;IACjDvB,GAAG,CAACsB,oBAAoB,CAACnB,IAAI,CAACC,QAAQ,EAAE,CAAC,GAAGoB,UAAU;IACtD,OAAOA,UAAU;EACnB;EAEU,OAAOf,wBAAwB,CACvCiB,GAAW;IAEX,MAAMC,iBAAiB,GAAGD,GAAG,CAACZ,OAAO,CAAC,GAAG,CAAC;IAC1C,IAAIa,iBAAiB,GAAG,CAAC,EAAE;MACzB,OAAO;QACLd,GAAG,EAAEa,GAAG;QACRhB,YAAY,EAAE;OACf;;IAGH,MAAMkB,gBAAgB,GAAGF,GAAG,CAACrB,MAAM,GAAG,CAAC,GAAGsB,iBAAiB,GAAG3B,GAAG,CAACqB,SAAS;IAC3E,IAAIO,gBAAgB,IAAI,CAAC,EAAE;MACzB,OAAO;QACLf,GAAG,EAAEa,GAAG;QACRhB,YAAY,EAAE;OACf;;IAGH,MAAMG,GAAG,GAAGa,GAAG,CAACG,KAAK,CAAC,CAAC,EAAEH,GAAG,CAACrB,MAAM,GAAGuB,gBAAgB,CAAC;IACvD,OAAO;MACLf,GAAG;MACHH,YAAY,EAAE,SAAS,CAACoB,IAAI,CAACjB,GAAG;KACjC;EACH;EAqDUO,WAAW;IACnB,IAAI,IAAI,CAAClB,GAAG,CAAC6B,GAAG,EAAE,CAACC,EAAE,CAAChC,GAAG,CAACiC,MAAM,CAAC,EAAE;MACjC,MAAM,IAAI3B,KAAK,CAAC,wBAAwB,IAAI,CAACJ,GAAG,CAACE,QAAQ,EAAE,EAAE,CAAC;;EAElE;EAEO8B,MAAM;IACX,OAAO,IAAI,CAAChC,GAAG,CAACiC,EAAE,CAACnB,qBAAU,CAAC,CAAC,CAAC,CAAC;EACnC;EAEOoB,UAAU;IACf,OAAO,IAAI,CAAClC,GAAG,CAACkC,UAAU,EAAE;EAC9B;EAEOC,UAAU;IACf,OAAO,IAAI,CAACnC,GAAG,CAACmC,UAAU,EAAE;EAC9B;EAEOC,MAAM,CAACC,EAAO;IACnB,OAAO,IAAI,CAACrC,GAAG,CAACiC,EAAE,CAACI,EAAE,CAACrC,GAAG,CAAC;EAC5B;EAEA;;;EAGO8B,EAAE,CAACO,EAAO;IACf,OAAO,IAAI,CAACrC,GAAG,CAAC8B,EAAE,CAACO,EAAE,CAACrC,GAAG,CAAC;EAC5B;EAEA;;;EAGOsC,GAAG,CAACD,EAAO;IAChB,OAAO,IAAI,CAACrC,GAAG,CAACuC,GAAG,CAACF,EAAE,CAACrC,GAAG,CAAC;EAC7B;EAEA;;;EAGOwC,EAAE,CAACH,EAAO;IACf,OAAO,IAAI,CAACrC,GAAG,CAACwC,EAAE,CAACH,EAAE,CAACrC,GAAG,CAAC;EAC5B;EAEA;;;EAGOyC,GAAG,CAACJ,EAAO;IAChB,OAAO,IAAI,CAACrC,GAAG,CAAC0C,GAAG,CAACL,EAAE,CAACrC,GAAG,CAAC;EAC7B;EAEA;;;EAGO2C,GAAG;IACR,OAAO,IAAI7C,GAAG,CAAC,IAAI,CAACE,GAAG,CAAC4C,MAAM,EAAE,EAAE9C,GAAG,CAACqB,SAAS,CAAC;EAClD;EAEA;;;EAGOU,GAAG;IACR,OAAO,IAAI/B,GAAG,CAAC,IAAI,CAACE,GAAG,CAAC6B,GAAG,EAAE,EAAE/B,GAAG,CAACqB,SAAS,CAAC;EAC/C;EAEO0B,GAAG,CAACR,EAAO;IAChB,OAAO,IAAIvC,GAAG,CAAC,IAAI,CAACE,GAAG,CAAC6C,GAAG,CAACR,EAAE,CAACrC,GAAG,CAAC,EAAEF,GAAG,CAACqB,SAAS,CAAC;EACrD;EAEO2B,GAAG,CAACT,EAAO;IAChB,OAAO,IAAIvC,GAAG,CAAC,IAAI,CAACE,GAAG,CAAC+C,QAAQ,CAACV,EAAE,CAACrC,GAAG,CAAC,EAAEF,GAAG,CAACqB,SAAS,CAAC;EAC1D;EAEOI,GAAG,CAACyB,CAAM;IACf,IAAIA,CAAC,CAAChB,MAAM,EAAE,EAAE;MACd,OAAO,IAAIlC,GAAG,CAAC,CAAC,CAAC;;IAGnB,IAAIkD,CAAC,CAACd,UAAU,EAAE,EAAE;MAClB,OAAO,IAAIpC,GAAG,CAAC,CAAC,CAAC,CAACmD,GAAG,CAAC,IAAI,CAAC1B,GAAG,CAACyB,CAAC,CAACnB,GAAG,EAAE,CAAC,CAAC;;IAG1C,IAAIqB,IAAI,GAAG,IAAIpD,GAAG,CAAC,IAAI,CAACE,GAAG,EAAEF,GAAG,CAACqB,SAAS,CAAC;IAC3C,IAAIgC,GAAG,GAAG,IAAIrD,GAAG,CAAC,CAAC,CAAC;IAEpB,KAAK,IAAIsD,CAAC,GAAGJ,CAAC,EAAEI,CAAC,CAACtB,EAAE,CAAC,IAAIf,SAAG,CAAC,CAAC,CAAC,CAAC,EAAEqC,CAAC,GAAGA,CAAC,CAACC,GAAG,CAAC,IAAItC,SAAG,CAAC,CAAC,CAAC,CAAC,EAAE;MACvD,IAAI,CAACqC,CAAC,CAACE,GAAG,CAAC,IAAIvC,SAAG,CAAC,CAAC,CAAC,CAAC,CAACiB,MAAM,EAAE,EAAE;QAC/BmB,GAAG,GAAGA,GAAG,CAACI,GAAG,CAACL,IAAI,CAAC;;MAErBA,IAAI,GAAGA,IAAI,CAACK,GAAG,CAACL,IAAI,CAAC;;IAGvB,OAAOA,IAAI,CAACK,GAAG,CAACJ,GAAG,CAAC;EACtB;EAEOI,GAAG,CAAClB,EAAO;IAChB,OAAO,IAAIvC,GAAG,CAAC,IAAI,CAAC0D,MAAM,CAACnB,EAAE,CAAC,CAACoB,qBAAqB,EAAE,EAAE3D,GAAG,CAACqB,SAAS,CAAC;EACxE;EAEOuC,WAAW,CAACrB,EAAO;IACxB,OAAO,IAAIvC,GAAG,CAAC,IAAI,CAAC0D,MAAM,CAACnB,EAAE,CAAC,CAACsB,wBAAwB,EAAE,EAAE7D,GAAG,CAACqB,SAAS,CAAC;EAC3E;EAEUqC,MAAM,CAACnB,EAAO;IACtB,OAAO,IAAIvC,GAAG,CAAC,IAAI,CAACE,GAAG,CAACgB,QAAQ,CAACqB,EAAE,CAACrC,GAAG,CAAC,EAAEF,GAAG,CAACqB,SAAS,CAAC;EAC1D;EAEO8B,GAAG,CAACZ,EAAO;IAChB,OAAO,IAAIvC,GAAG,CAAC,IAAI,CAAC8D,MAAM,CAACvB,EAAE,CAAC,CAACoB,qBAAqB,EAAE,EAAE3D,GAAG,CAACqB,SAAS,CAAC;EACxE;EAEO0C,WAAW,CAACxB,EAAO;IACxB,OAAO,IAAIvC,GAAG,CAAC,IAAI,CAAC8D,MAAM,CAACvB,EAAE,CAAC,CAACsB,wBAAwB,EAAE,EAAE7D,GAAG,CAACqB,SAAS,CAAC;EAC3E;EAEO2C,UAAU,CAACzB,EAAO;IACvB,OAAO,IAAIvC,GAAG,CAAC,IAAI,CAAC8D,MAAM,CAACvB,EAAE,CAAC,CAAC0B,uBAAuB,EAAE,EAAEjE,GAAG,CAACqB,SAAS,CAAC;EAC1E;EAEUyC,MAAM,CAACvB,EAAO;IACtB,MAAMlB,SAAS,GAAGrB,GAAG,CAACmB,uBAAuB,CAAC,CAAC,CAAC;IAEhD;IACA,MAAMsC,GAAG,GAAG,IAAI,CAACvD,GAAG,CAACgB,QAAQ,CAACG,SAAS,CAAC,CAACH,QAAQ,CAACG,SAAS,CAAC;IAC5D,OAAO,IAAIrB,GAAG,CAACyD,GAAG,CAACS,MAAM,CAAC3B,EAAE,CAACrC,GAAG,CAAC,EAAEF,GAAG,CAACqB,SAAS,CAAC;EACnD;EAEO8C,SAAS;IACd,MAAM9C,SAAS,GAAGrB,GAAG,CAACmB,uBAAuB,CAAC,CAAC,CAAC;IAChD,OAAO,IAAI,CAACjB,GAAG,CAACkE,SAAS,CAAC/C,SAAS,CAAC,CAACiB,MAAM,CAACtB,qBAAU,CAAC,CAAC,CAAC,CAAC;EAC5D;EAEA;;;;EAIU2C,qBAAqB;IAC7B;IACA,IAAI,IAAI,CAACvB,UAAU,EAAE,EAAE;MACrB,MAAMiC,WAAW,GAAG,IAAI,CAACtC,GAAG,EAAE;MAC9B,MAAMuC,MAAM,GAAGD,WAAW,CAACV,qBAAqB,EAAE;MAClD,OAAOW,MAAM,CAACxB,MAAM,EAAE;;IAGxB,MAAMzB,SAAS,GAAGrB,GAAG,CAACmB,uBAAuB,CAAC,CAAC,CAAC;IAChD,MAAMoD,aAAa,GAAGlD,SAAS,CAAC6C,MAAM,CAAClD,qBAAU,CAAC,CAAC,CAAC,CAAC;IAErD;IACA,MAAM;MAAEwD,QAAQ;MAAEJ;IAAS,CAAE,GAAG,IAAI,CAAClE,GAAG,CAACuE,MAAM,CAACpD,SAAS,CAAC;IAE1D;IACA,IAAI+C,SAAS,CAAC9B,MAAM,CAACtB,qBAAU,CAAC,CAAC,CAAC,CAAC,EAAE;MACnC,OAAOwD,QAAQ;;IAGjB,IAAIJ,SAAS,CAAC1B,EAAE,CAAC6B,aAAa,CAAC,EAAE;MAC/B,OAAOC,QAAQ;KAChB,MAAM,IAAIJ,SAAS,CAACpC,EAAE,CAACuC,aAAa,CAAC,EAAE;MACtC,OAAOC,QAAQ,CAACzB,GAAG,CAAC/B,qBAAU,CAAC,CAAC,CAAC,CAAC;KACnC,MAAM;MACL;MACA,IAAIwD,QAAQ,CAACN,MAAM,CAAClD,qBAAU,CAAC,CAAC,CAAC,CAAC,CAACsB,MAAM,CAACtB,qBAAU,CAAC,CAAC,CAAC,CAAC,EAAE;QACxD,OAAOwD,QAAQ;OAChB,MAAM;QACL,OAAOA,QAAQ,CAACzB,GAAG,CAAC/B,qBAAU,CAAC,CAAC,CAAC,CAAC;;;EAGxC;EAEUiD,uBAAuB;IAC/B;IACA,IAAI,IAAI,CAAC7B,UAAU,EAAE,EAAE;MACrB,MAAMiC,WAAW,GAAG,IAAI,CAACtC,GAAG,EAAE;MAC9B;MACA,MAAMuC,MAAM,GAAGD,WAAW,CAACR,wBAAwB,EAAE;MACrD,OAAOS,MAAM,CAACxB,MAAM,EAAE;;IAGxB,MAAMzB,SAAS,GAAGrB,GAAG,CAACmB,uBAAuB,CAAC,CAAC,CAAC;IAEhD;IACA,MAAM;MAAEqD,QAAQ;MAAEJ;IAAS,CAAE,GAAG,IAAI,CAAClE,GAAG,CAACuE,MAAM,CAACpD,SAAS,CAAC;IAE1D;IACA,IAAI+C,SAAS,CAAC9B,MAAM,CAACtB,qBAAU,CAAC,CAAC,CAAC,CAAC,EAAE;MACnC,OAAOwD,QAAQ;;IAGjB,OAAOA,QAAQ,CAACzB,GAAG,CAAC/B,qBAAU,CAAC,CAAC,CAAC,CAAC;EACpC;EAEA;;;EAGU6C,wBAAwB;IAChC,MAAMxC,SAAS,GAAGrB,GAAG,CAACmB,uBAAuB,CAAC,CAAC,CAAC;IAChD,OAAO,IAAI,CAACjB,GAAG,CAACgE,MAAM,CAAC7C,SAAS,CAAC;EACnC;EAEOjB,QAAQ,GAEU;IAAA,IADvBD,2EAAeH,GAAG,CAACqB,SAAS;IAAA,IAC5BqD,6EAAkB,KAAK;IAEvB,MAAMrD,SAAS,GAAGrB,GAAG,CAACmB,uBAAuB,CAAC,CAAC,CAAC;IAChD,MAAMjB,GAAG,GAAG,IAAI,CAACA,GAAG,CAAC6B,GAAG,EAAE;IAC1B,MAAM;MAAEyC,QAAQ,EAAEG,OAAO;MAAEP,SAAS,EAAEQ;IAAQ,CAAE,GAAG1E,GAAG,CAACuE,MAAM,CAACpD,SAAS,CAAC;IAExE,IAAIwD,WAAW,GAAGD,QAAQ,CAACxE,QAAQ,CAAC,EAAE,CAAC;IACvC,KAAK,IAAIkD,CAAC,GAAG,CAAC,EAAEwB,CAAC,GAAGD,WAAW,CAACxE,MAAM,EAAEiD,CAAC,GAAGtD,GAAG,CAACqB,SAAS,GAAGyD,CAAC,EAAExB,CAAC,EAAE,EAAE;MAClEuB,WAAW,GAAG,GAAG,GAAGA,WAAW;;IAEjCA,WAAW,GAAGA,WAAW,CAACE,SAAS,CAAC,CAAC,EAAE5E,IAAI,CAAC;IAE5C,MAAMiC,UAAU,GACd,IAAI,CAACA,UAAU,EAAE,IACjB,EAAEuC,OAAO,CAACxC,EAAE,CAACnB,qBAAU,CAAC,CAAC,CAAC,CAAC,IAAI6D,WAAW,CAACxE,MAAM,KAAK,CAAC,CAAC;IAE1D,MAAM2E,UAAU,GAAGN,MAAM;IACrB;IACA;IACAO,sBAAS,CAACC,6BAA6B,CAACP,OAAO,CAACvE,QAAQ,EAAE,CAAC,GAC3DuE,OAAO,CAACvE,QAAQ,EAAE;IAEtB,OAAO,GAAGgC,UAAU,GAAG,GAAG,GAAG,EAAE,GAAG4C,UAAU,GAC1CH,WAAW,CAACxE,MAAM,GAAG,CAAC,GAAG,GAAG,GAAGwE,WAAW,GAAG,EAC/C,EAAE;EACJ;EAEOM,KAAK;IACV,OAAO,IAAIlE,SAAG,CAAC,IAAI,CAAC0C,qBAAqB,EAAE,CAAC;EAC9C;EAEOyB,OAAO;IACZ,OAAO,IAAInE,SAAG,CAAC,IAAI,CAACgD,uBAAuB,EAAE,CAAC;EAChD;EAEOoB,QAAQ;IACb,OAAO,IAAIpE,SAAG,CAAC,IAAI,CAAC4C,wBAAwB,EAAE,CAAC;EACjD;EAEOyB,QAAQ;IACb,OAAO,IAAItF,GAAG,CAAC,IAAI,CAAC2D,qBAAqB,EAAE,EAAE,CAAC,CAAC;EACjD;EAEO4B,UAAU;IACf,OAAO,IAAIvF,GAAG,CAAC,IAAI,CAACiE,uBAAuB,EAAE,EAAE,CAAC,CAAC;EACnD;EAEOuB,WAAW;IAChB,OAAO,IAAIxF,GAAG,CAAC,IAAI,CAAC6D,wBAAwB,EAAE,EAAE,CAAC,CAAC;EACpD;;AAzWF4B;AACyBzF,aAAS,GAAG,EAAE;AACrC;AACA;AAC0BA,wBAAoB,GAAG,EAAE;AACnD;AACA;AACA;AAC0BA,UAAM,GAAGgB,qBAAU,CAC3C,kGAAkG,CACnG;AAEyBhB,wBAAoB,GAE1C,EAAE","names":["Dec","constructor","int","prec","toString","length","Error","etc_1","reduced","reduceDecimalsFromString","isDownToZero","console","log","res","indexOf","replace","big_integer_1","int_1","multiply","calcPrecisionMultiplier","checkBitLen","precision","precisionMultipliers","zerosToAdd","multiplier","pow","str","decimalPointIndex","exceededDecimals","slice","test","abs","gt","maxDec","isZero","eq","isNegative","isPositive","equals","d2","gte","geq","lt","lte","leq","neg","negate","add","sub","subtract","n","quo","base","tmp","i","div","mod","mul","mulRaw","chopPrecisionAndRound","mulTruncate","chopPrecisionAndTruncate","quoRaw","quoTruncate","quoRoundUp","chopPrecisionAndRoundUp","divide","isInteger","remainder","absoulteDec","choped","fivePrecision","quotient","divmod","locale","integer","fraction","fractionStr","l","substring","integerStr","coin_utils_1","integerStringToUSLocaleString","round","roundUp","truncate","roundDec","roundUpDec","truncateDec","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/node_modules/@keplr-wallet/unit/src/decimal.ts"],"sourcesContent":["import bigInteger from \"big-integer\";\nimport { Int } from \"./int\";\nimport { CoinUtils } from \"./coin-utils\";\nimport {\n  exponentDecStringToDecString,\n  isExponentDecString,\n  isValidDecimalString,\n} from \"./etc\";\n\nexport class Dec {\n  public static readonly precision = 18;\n  // Bytes required to represent the above precision is 18.\n  // Ceiling[Log2[999 999 999 999 999 999]]\n  protected static readonly decimalPrecisionBits = 60;\n  // Max bit length for `Dec` is 256 + 60(decimalPrecisionBits)\n  // The int in the `Dec` is handled as integer assuming that it has 18 precision.\n  // (2 ** (256 + 60) - 1)\n  protected static readonly maxDec = bigInteger(\n    \"133499189745056880149688856635597007162669032647290798121690100488888732861290034376435130433535\"\n  );\n\n  protected static readonly precisionMultipliers: {\n    [key: string]: bigInteger.BigInteger | undefined;\n  } = {};\n  protected static calcPrecisionMultiplier(\n    prec: number\n  ): bigInteger.BigInteger {\n    if (prec < 0) {\n      throw new Error(\"Invalid prec\");\n    }\n    if (prec > Dec.precision) {\n      throw new Error(\"Too much precision\");\n    }\n    if (Dec.precisionMultipliers[prec.toString()]) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return Dec.precisionMultipliers[prec.toString()]!;\n    }\n\n    const zerosToAdd = Dec.precision - prec;\n    const multiplier = bigInteger(10).pow(zerosToAdd);\n    Dec.precisionMultipliers[prec.toString()] = multiplier;\n    return multiplier;\n  }\n\n  protected static reduceDecimalsFromString(\n    str: string\n  ): { res: string; isDownToZero: boolean } {\n    const decimalPointIndex = str.indexOf(\".\");\n    if (decimalPointIndex < 0) {\n      return {\n        res: str,\n        isDownToZero: false,\n      };\n    }\n\n    const exceededDecimals = str.length - 1 - decimalPointIndex - Dec.precision;\n    if (exceededDecimals <= 0) {\n      return {\n        res: str,\n        isDownToZero: false,\n      };\n    }\n\n    const res = str.slice(0, str.length - exceededDecimals);\n    return {\n      res,\n      isDownToZero: /^[0.]*$/.test(res),\n    };\n  }\n\n  protected int: bigInteger.BigInteger;\n\n  /**\n   * Create a new Dec from integer with decimal place at prec\n   * @param int - Parse a number | bigInteger | string into a Dec.\n   * If int is string and contains dot(.), prec is ignored and automatically calculated.\n   * @param prec - Precision\n   */\n  constructor(int: bigInteger.BigNumber | Int, prec: number = 0) {\n    if (typeof int === \"number\") {\n      int = int.toString();\n    }\n\n    if (typeof int === \"string\") {\n      if (int.length === 0) {\n        throw new Error(\"empty string\");\n      }\n      if (!isValidDecimalString(int)) {\n        if (isExponentDecString(int)) {\n          int = exponentDecStringToDecString(int);\n        } else {\n          throw new Error(`invalid decimal: ${int}`);\n        }\n      }\n      // Even if an input with more than 18 decimals, it does not throw an error and ignores the rest.\n      const reduced = Dec.reduceDecimalsFromString(int);\n      if (reduced.isDownToZero) {\n        // However, as a result, if the input becomes 0, a problem may occur in mul or quo. In this case, print a warning.\n        console.log(\n          `WARNING: Got ${int}. Dec can only handle up to 18 decimals. However, since the decimal point of the input exceeds 18 digits, the remainder is discarded. As a result, input becomes 0.`\n        );\n      }\n      int = reduced.res;\n      if (int.indexOf(\".\") >= 0) {\n        prec = int.length - int.indexOf(\".\") - 1;\n        int = int.replace(\".\", \"\");\n      }\n      this.int = bigInteger(int);\n    } else if (int instanceof Int) {\n      this.int = bigInteger(int.toString());\n    } else if (typeof int === \"bigint\") {\n      this.int = bigInteger(int);\n    } else {\n      this.int = bigInteger(int);\n    }\n\n    this.int = this.int.multiply(Dec.calcPrecisionMultiplier(prec));\n\n    this.checkBitLen();\n  }\n\n  protected checkBitLen(): void {\n    if (this.int.abs().gt(Dec.maxDec)) {\n      throw new Error(`Integer out of range ${this.int.toString()}`);\n    }\n  }\n\n  public isZero(): boolean {\n    return this.int.eq(bigInteger(0));\n  }\n\n  public isNegative(): boolean {\n    return this.int.isNegative();\n  }\n\n  public isPositive(): boolean {\n    return this.int.isPositive();\n  }\n\n  public equals(d2: Dec): boolean {\n    return this.int.eq(d2.int);\n  }\n\n  /**\n   * Alias for the greater method.\n   */\n  public gt(d2: Dec): boolean {\n    return this.int.gt(d2.int);\n  }\n\n  /**\n   * Alias for the greaterOrEquals method.\n   */\n  public gte(d2: Dec): boolean {\n    return this.int.geq(d2.int);\n  }\n\n  /**\n   * Alias for the lesser method.\n   */\n  public lt(d2: Dec): boolean {\n    return this.int.lt(d2.int);\n  }\n\n  /**\n   * Alias for the lesserOrEquals method.\n   */\n  public lte(d2: Dec): boolean {\n    return this.int.leq(d2.int);\n  }\n\n  /**\n   * reverse the decimal sign.\n   */\n  public neg(): Dec {\n    return new Dec(this.int.negate(), Dec.precision);\n  }\n\n  /**\n   * Returns the absolute value of a decimals.\n   */\n  public abs(): Dec {\n    return new Dec(this.int.abs(), Dec.precision);\n  }\n\n  public add(d2: Dec): Dec {\n    return new Dec(this.int.add(d2.int), Dec.precision);\n  }\n\n  public sub(d2: Dec): Dec {\n    return new Dec(this.int.subtract(d2.int), Dec.precision);\n  }\n\n  public pow(n: Int): Dec {\n    if (n.isZero()) {\n      return new Dec(1);\n    }\n\n    if (n.isNegative()) {\n      return new Dec(1).quo(this.pow(n.abs()));\n    }\n\n    let base = new Dec(this.int, Dec.precision);\n    let tmp = new Dec(1);\n\n    for (let i = n; i.gt(new Int(1)); i = i.div(new Int(2))) {\n      if (!i.mod(new Int(2)).isZero()) {\n        tmp = tmp.mul(base);\n      }\n      base = base.mul(base);\n    }\n\n    return base.mul(tmp);\n  }\n\n  public mul(d2: Dec): Dec {\n    return new Dec(this.mulRaw(d2).chopPrecisionAndRound(), Dec.precision);\n  }\n\n  public mulTruncate(d2: Dec): Dec {\n    return new Dec(this.mulRaw(d2).chopPrecisionAndTruncate(), Dec.precision);\n  }\n\n  protected mulRaw(d2: Dec): Dec {\n    return new Dec(this.int.multiply(d2.int), Dec.precision);\n  }\n\n  public quo(d2: Dec): Dec {\n    return new Dec(this.quoRaw(d2).chopPrecisionAndRound(), Dec.precision);\n  }\n\n  public quoTruncate(d2: Dec): Dec {\n    return new Dec(this.quoRaw(d2).chopPrecisionAndTruncate(), Dec.precision);\n  }\n\n  public quoRoundUp(d2: Dec): Dec {\n    return new Dec(this.quoRaw(d2).chopPrecisionAndRoundUp(), Dec.precision);\n  }\n\n  protected quoRaw(d2: Dec): Dec {\n    const precision = Dec.calcPrecisionMultiplier(0);\n\n    // multiply precision twice\n    const mul = this.int.multiply(precision).multiply(precision);\n    return new Dec(mul.divide(d2.int), Dec.precision);\n  }\n\n  public isInteger(): boolean {\n    const precision = Dec.calcPrecisionMultiplier(0);\n    return this.int.remainder(precision).equals(bigInteger(0));\n  }\n\n  /**\n   * Remove a Precision amount of rightmost digits and perform bankers rounding\n   * on the remainder (gaussian rounding) on the digits which have been removed.\n   */\n  protected chopPrecisionAndRound(): bigInteger.BigInteger {\n    // Remove the negative and add it back when returning\n    if (this.isNegative()) {\n      const absoulteDec = this.abs();\n      const choped = absoulteDec.chopPrecisionAndRound();\n      return choped.negate();\n    }\n\n    const precision = Dec.calcPrecisionMultiplier(0);\n    const fivePrecision = precision.divide(bigInteger(2));\n\n    // Get the truncated quotient and remainder\n    const { quotient, remainder } = this.int.divmod(precision);\n\n    // If remainder is zero\n    if (remainder.equals(bigInteger(0))) {\n      return quotient;\n    }\n\n    if (remainder.lt(fivePrecision)) {\n      return quotient;\n    } else if (remainder.gt(fivePrecision)) {\n      return quotient.add(bigInteger(1));\n    } else {\n      // always round to an even number\n      if (quotient.divide(bigInteger(2)).equals(bigInteger(0))) {\n        return quotient;\n      } else {\n        return quotient.add(bigInteger(1));\n      }\n    }\n  }\n\n  protected chopPrecisionAndRoundUp(): bigInteger.BigInteger {\n    // Remove the negative and add it back when returning\n    if (this.isNegative()) {\n      const absoulteDec = this.abs();\n      // truncate since d is negative...\n      const choped = absoulteDec.chopPrecisionAndTruncate();\n      return choped.negate();\n    }\n\n    const precision = Dec.calcPrecisionMultiplier(0);\n\n    // Get the truncated quotient and remainder\n    const { quotient, remainder } = this.int.divmod(precision);\n\n    // If remainder is zero\n    if (remainder.equals(bigInteger(0))) {\n      return quotient;\n    }\n\n    return quotient.add(bigInteger(1));\n  }\n\n  /**\n   * Similar to chopPrecisionAndRound, but always rounds down\n   */\n  protected chopPrecisionAndTruncate(): bigInteger.BigInteger {\n    const precision = Dec.calcPrecisionMultiplier(0);\n    return this.int.divide(precision);\n  }\n\n  public toString(\n    prec: number = Dec.precision,\n    locale: boolean = false\n  ): string {\n    const precision = Dec.calcPrecisionMultiplier(0);\n    const int = this.int.abs();\n    const { quotient: integer, remainder: fraction } = int.divmod(precision);\n\n    let fractionStr = fraction.toString(10);\n    for (let i = 0, l = fractionStr.length; i < Dec.precision - l; i++) {\n      fractionStr = \"0\" + fractionStr;\n    }\n    fractionStr = fractionStr.substring(0, prec);\n\n    const isNegative =\n      this.isNegative() &&\n      !(integer.eq(bigInteger(0)) && fractionStr.length === 0);\n\n    const integerStr = locale\n      ? // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        CoinUtils.integerStringToUSLocaleString(integer.toString())\n      : integer.toString();\n\n    return `${isNegative ? \"-\" : \"\"}${integerStr}${\n      fractionStr.length > 0 ? \".\" + fractionStr : \"\"\n    }`;\n  }\n\n  public round(): Int {\n    return new Int(this.chopPrecisionAndRound());\n  }\n\n  public roundUp(): Int {\n    return new Int(this.chopPrecisionAndRoundUp());\n  }\n\n  public truncate(): Int {\n    return new Int(this.chopPrecisionAndTruncate());\n  }\n\n  public roundDec(): Dec {\n    return new Dec(this.chopPrecisionAndRound(), 0);\n  }\n\n  public roundUpDec(): Dec {\n    return new Dec(this.chopPrecisionAndRoundUp(), 0);\n  }\n\n  public truncateDec(): Dec {\n    return new Dec(this.chopPrecisionAndTruncate(), 0);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}