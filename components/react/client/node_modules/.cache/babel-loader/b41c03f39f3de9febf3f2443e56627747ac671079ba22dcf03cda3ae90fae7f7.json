{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseAccount = void 0;\nconst unit_1 = require(\"@keplr-wallet/unit\");\nclass BaseAccount {\n  constructor(type, address, accountNumber, sequence) {\n    this.type = type;\n    this.address = address;\n    this.accountNumber = accountNumber;\n    this.sequence = sequence;\n  }\n  static fetchFromRest(instance, address) {\n    let defaultBech32Address = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = yield instance.get(`auth/accounts/${address}`);\n      return BaseAccount.fromAminoJSON(result.data, defaultBech32Address ? address : \"\");\n    });\n  }\n  static fromAminoJSON(obj) {\n    let defaultBech32Address = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    if (\"height\" in obj) {\n      obj = obj.result;\n    }\n    const type = obj.type || \"\";\n    let value = \"value\" in obj ? obj.value : obj;\n    // If the chain modifies the account type, handle the case where the account type embeds the base account.\n    // (Actually, the only existent case is ethermint, and this is the line for handling ethermint)\n    const baseAccount = value.BaseAccount || value.baseAccount || value.base_account;\n    if (baseAccount) {\n      value = baseAccount;\n    }\n    // If the account is the vesting account that embeds the base vesting account,\n    // the actual base account exists under the base vesting account.\n    // But, this can be different according to the version of cosmos-sdk.\n    // So, anyway, try to parse it by some ways...\n    const baseVestingAccount = value.BaseVestingAccount || value.baseVestingAccount || value.base_vesting_account;\n    if (baseVestingAccount) {\n      value = baseVestingAccount.BaseAccount || baseVestingAccount.baseAccount || baseVestingAccount.base_account;\n    }\n    let address = value.address;\n    if (!address) {\n      if (!defaultBech32Address) {\n        throw new Error(`Account's address is unknown: ${JSON.stringify(obj)}`);\n      }\n      address = defaultBech32Address;\n    }\n    const accountNumber = value.account_number;\n    const sequence = value.sequence;\n    return new BaseAccount(type, address, new unit_1.Int(accountNumber !== null && accountNumber !== void 0 ? accountNumber : \"0\"), new unit_1.Int(sequence !== null && sequence !== void 0 ? sequence : \"0\"));\n  }\n  getType() {\n    return this.type;\n  }\n  getAddress() {\n    return this.address;\n  }\n  getAccountNumber() {\n    return this.accountNumber;\n  }\n  getSequence() {\n    return this.sequence;\n  }\n}\nexports.BaseAccount = BaseAccount;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAUA,MAAaA,WAAW;EAgFtBC,YACqBC,IAAY,EACZC,OAAe,EACfC,aAAkB,EAClBC,QAAa;IAHb,SAAI,GAAJH,IAAI;IACJ,YAAO,GAAPC,OAAO;IACP,kBAAa,GAAbC,aAAa;IACb,aAAQ,GAARC,QAAQ;EAC1B;EApFI,OAAaC,aAAa,CAC/BC,QAAuB,EACvBJ,OAAe,EAGsB;IAAA,IAArCK,2FAAgC,KAAK;;MAErC,MAAMC,MAAM,GAAG,MAAMF,QAAQ,CAACG,GAAG,CAAC,iBAAiBP,OAAO,EAAE,CAAC;MAE7D,OAAOH,WAAW,CAACW,aAAa,CAC9BF,MAAM,CAACG,IAAI,EACXJ,oBAAoB,GAAGL,OAAO,GAAG,EAAE,CACpC;IACH,CAAC;;EAEM,OAAOQ,aAAa,CACzBE,GAQgC,EAGC;IAAA,IAAjCL,2FAA+B,EAAE;IAEjC,IAAI,QAAQ,IAAIK,GAAG,EAAE;MACnBA,GAAG,GAAGA,GAAG,CAACJ,MAAM;;IAGlB,MAAMP,IAAI,GAAGW,GAAG,CAACX,IAAI,IAAI,EAAE;IAE3B,IAAIY,KAAK,GAAG,OAAO,IAAID,GAAG,GAAGA,GAAG,CAACC,KAAK,GAAGD,GAAG;IAE5C;IACA;IACA,MAAME,WAAW,GACfD,KAAK,CAACd,WAAW,IAAIc,KAAK,CAACC,WAAW,IAAID,KAAK,CAACE,YAAY;IAC9D,IAAID,WAAW,EAAE;MACfD,KAAK,GAAGC,WAAW;;IAGrB;IACA;IACA;IACA;IACA,MAAME,kBAAkB,GACtBH,KAAK,CAACI,kBAAkB,IACxBJ,KAAK,CAACG,kBAAkB,IACxBH,KAAK,CAACK,oBAAoB;IAC5B,IAAIF,kBAAkB,EAAE;MACtBH,KAAK,GACHG,kBAAkB,CAACjB,WAAW,IAC9BiB,kBAAkB,CAACF,WAAW,IAC9BE,kBAAkB,CAACD,YAAY;;IAGnC,IAAIb,OAAO,GAAGW,KAAK,CAACX,OAAO;IAC3B,IAAI,CAACA,OAAO,EAAE;MACZ,IAAI,CAACK,oBAAoB,EAAE;QACzB,MAAM,IAAIY,KAAK,CAAC,iCAAiCC,IAAI,CAACC,SAAS,CAACT,GAAG,CAAC,EAAE,CAAC;;MAEzEV,OAAO,GAAGK,oBAAoB;;IAGhC,MAAMJ,aAAa,GAAGU,KAAK,CAACS,cAAc;IAC1C,MAAMlB,QAAQ,GAAGS,KAAK,CAACT,QAAQ;IAE/B,OAAO,IAAIL,WAAW,CACpBE,IAAI,EACJC,OAAO,EACP,IAAIqB,UAAG,CAACpB,aAAa,aAAbA,aAAa,cAAbA,aAAa,GAAI,GAAG,CAAC,EAC7B,IAAIoB,UAAG,CAACnB,QAAQ,aAARA,QAAQ,cAARA,QAAQ,GAAI,GAAG,CAAC,CACzB;EACH;EASAoB,OAAO;IACL,OAAO,IAAI,CAACvB,IAAI;EAClB;EAEAwB,UAAU;IACR,OAAO,IAAI,CAACvB,OAAO;EACrB;EAEAwB,gBAAgB;IACd,OAAO,IAAI,CAACvB,aAAa;EAC3B;EAEAwB,WAAW;IACT,OAAO,IAAI,CAACvB,QAAQ;EACtB;;AArGFwB","names":["BaseAccount","constructor","type","address","accountNumber","sequence","fetchFromRest","instance","defaultBech32Address","result","get","fromAminoJSON","data","obj","value","baseAccount","base_account","baseVestingAccount","BaseVestingAccount","base_vesting_account","Error","JSON","stringify","account_number","unit_1","getType","getAddress","getAccountNumber","getSequence","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/cosmos/src/account/index.ts"],"sourcesContent":["import { Int } from \"@keplr-wallet/unit\";\nimport { AxiosInstance } from \"axios\";\n\nexport interface Account {\n  getType(): string;\n  getAddress(): string;\n  getAccountNumber(): Int;\n  getSequence(): Int;\n}\n\nexport class BaseAccount implements Account {\n  public static async fetchFromRest(\n    instance: AxiosInstance,\n    address: string,\n    // If the account doesn't exist, the result from `auth/accounts` would not have the address.\n    // In this case, if `defaultBech32Address` param is provided, this will use it instead of the result from rest.\n    defaultBech32Address: boolean = false\n  ): Promise<BaseAccount> {\n    const result = await instance.get(`auth/accounts/${address}`);\n\n    return BaseAccount.fromAminoJSON(\n      result.data,\n      defaultBech32Address ? address : \"\"\n    );\n  }\n\n  public static fromAminoJSON(\n    obj:\n      | {\n          height: string;\n          result: {\n            type: string;\n            value: any;\n          };\n        }\n      | { type: string; value: any },\n    // If the account doesn't exist, the result from `auth/accounts` would not have the address.\n    // In this case, if `defaultBech32Address` param is provided, this will use it instead of the result from rest.\n    defaultBech32Address: string = \"\"\n  ): BaseAccount {\n    if (\"height\" in obj) {\n      obj = obj.result;\n    }\n\n    const type = obj.type || \"\";\n\n    let value = \"value\" in obj ? obj.value : obj;\n\n    // If the chain modifies the account type, handle the case where the account type embeds the base account.\n    // (Actually, the only existent case is ethermint, and this is the line for handling ethermint)\n    const baseAccount =\n      value.BaseAccount || value.baseAccount || value.base_account;\n    if (baseAccount) {\n      value = baseAccount;\n    }\n\n    // If the account is the vesting account that embeds the base vesting account,\n    // the actual base account exists under the base vesting account.\n    // But, this can be different according to the version of cosmos-sdk.\n    // So, anyway, try to parse it by some ways...\n    const baseVestingAccount =\n      value.BaseVestingAccount ||\n      value.baseVestingAccount ||\n      value.base_vesting_account;\n    if (baseVestingAccount) {\n      value =\n        baseVestingAccount.BaseAccount ||\n        baseVestingAccount.baseAccount ||\n        baseVestingAccount.base_account;\n    }\n\n    let address = value.address;\n    if (!address) {\n      if (!defaultBech32Address) {\n        throw new Error(`Account's address is unknown: ${JSON.stringify(obj)}`);\n      }\n      address = defaultBech32Address;\n    }\n\n    const accountNumber = value.account_number;\n    const sequence = value.sequence;\n\n    return new BaseAccount(\n      type,\n      address,\n      new Int(accountNumber ?? \"0\"),\n      new Int(sequence ?? \"0\")\n    );\n  }\n\n  constructor(\n    protected readonly type: string,\n    protected readonly address: string,\n    protected readonly accountNumber: Int,\n    protected readonly sequence: Int\n  ) {}\n\n  getType(): string {\n    return this.type;\n  }\n\n  getAddress(): string {\n    return this.address;\n  }\n\n  getAccountNumber(): Int {\n    return this.accountNumber;\n  }\n\n  getSequence(): Int {\n    return this.sequence;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}