{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableSecretContractChainQuery = void 0;\nconst chain_query_1 = require(\"../chain-query\");\nconst common_1 = require(\"@keplr-wallet/common\");\nconst mobx_1 = require(\"mobx\");\nconst buffer_1 = require(\"buffer/\");\nclass ObservableSecretContractChainQuery extends chain_query_1.ObservableChainQuery {\n  constructor(kvStore, chainId, chainGetter, apiGetter, contractAddress,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  obj, querySecretContractCodeHash) {\n    // Don't need to set the url initially because it can't request without encyption.\n    super(kvStore, chainId, chainGetter, ``);\n    this.apiGetter = apiGetter;\n    this.contractAddress = contractAddress;\n    this.obj = obj;\n    this.querySecretContractCodeHash = querySecretContractCodeHash;\n    this.keplr = undefined;\n    this._isIniting = false;\n    mobx_1.makeObservable(this);\n  }\n  onStart() {\n    const _super = Object.create(null, {\n      onStart: {\n        get: () => super.onStart\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      _super.onStart.call(this);\n      if (!this.keplr) {\n        yield this.initKeplr();\n      }\n      if (!this.keplr) {\n        throw new Error(\"Failed to get keplr\");\n      }\n      yield this.querySecretContractCodeHash.getQueryContract(this.contractAddress).waitResponse();\n      yield this.init();\n    });\n  }\n  get isFetching() {\n    return this.querySecretContractCodeHash.getQueryContract(this.contractAddress).isFetching || this.keplr == null || this._isIniting || super.isFetching;\n  }\n  canFetch() {\n    if (!this.querySecretContractCodeHash.getQueryContract(this.contractAddress).response) {\n      return false;\n    }\n    return this.contractAddress.length !== 0 && this.nonce != null;\n  }\n  *initKeplr() {\n    this.keplr = yield* common_1.toGenerator(this.apiGetter());\n  }\n  *init() {\n    this._isIniting = true;\n    if (this.keplr && this.contractCodeHash) {\n      const enigmaUtils = this.keplr.getEnigmaUtils(this.chainId);\n      const encrypted = yield* common_1.toGenerator(enigmaUtils.encrypt(this.contractCodeHash, this.obj));\n      this.nonce = encrypted.slice(0, 32);\n      const encoded = buffer_1.Buffer.from(buffer_1.Buffer.from(encrypted).toString(\"base64\")).toString(\"hex\");\n      this.setUrl(`/wasm/contract/${this.contractAddress}/query/${encoded}?encoding=hex`);\n    }\n    this._isIniting = false;\n  }\n  fetchResponse(abortController) {\n    const _super = Object.create(null, {\n      fetchResponse: {\n        get: () => super.fetchResponse\n      }\n    });\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      let response;\n      let headers;\n      try {\n        const fetched = yield _super.fetchResponse.call(this, abortController);\n        response = fetched.response;\n        headers = fetched.headers;\n      } catch (e) {\n        if ((_b = (_a = e.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) {\n          const encryptedError = e.response.data.error;\n          const errorMessageRgx = /rpc error: code = (.+) = encrypted: (.+): (.+)/g;\n          const rgxMatches = errorMessageRgx.exec(encryptedError);\n          if (rgxMatches != null && rgxMatches.length === 4) {\n            const errorCipherB64 = rgxMatches[2];\n            const errorCipherBz = buffer_1.Buffer.from(errorCipherB64, \"base64\");\n            if (this.keplr && this.nonce) {\n              const decrypted = yield this.keplr.getEnigmaUtils(this.chainId).decrypt(errorCipherBz, this.nonce);\n              const errorStr = buffer_1.Buffer.from(decrypted).toString();\n              // If error is from secret wasm chain itself, decrypt the error message and throw it.\n              throw new Error(errorStr);\n            }\n          }\n        }\n        throw e;\n      }\n      const encResult = response.data;\n      if (!this.keplr) {\n        throw new Error(\"Keplr API not initialized\");\n      }\n      if (!this.nonce) {\n        throw new Error(\"Nonce is unknown\");\n      }\n      if (!encResult) {\n        throw new Error(\"Failed to get the response from the contract\");\n      }\n      const decrypted = yield this.keplr.getEnigmaUtils(this.chainId).decrypt(buffer_1.Buffer.from(encResult.result.smart, \"base64\"), this.nonce);\n      const message = buffer_1.Buffer.from(buffer_1.Buffer.from(decrypted).toString(), \"base64\").toString();\n      const obj = JSON.parse(message);\n      return {\n        headers,\n        response: {\n          data: obj,\n          status: response.status,\n          staled: false,\n          timestamp: Date.now()\n        }\n      };\n    });\n  }\n  // Actually, the url of fetching the secret20 balance will be changed every time.\n  // So, we should save it with deterministic key.\n  getCacheKey() {\n    return `${this.instance.name}-${this.instance.defaults.baseURL}${this.instance.getUri({\n      url: `/wasm/contract/${this.contractAddress}/query/${JSON.stringify(this.obj)}?encoding=json`\n    })}`;\n  }\n  get contractCodeHash() {\n    const queryCodeHash = this.querySecretContractCodeHash.getQueryContract(this.contractAddress);\n    if (!queryCodeHash.response) {\n      return undefined;\n    }\n    // Code hash is persistent, so it is safe not to consider that the response is from cache or network.\n    // TODO: Handle the error case.\n    return queryCodeHash.response.data.result;\n  }\n}\n__decorate([mobx_1.observable.ref], ObservableSecretContractChainQuery.prototype, \"keplr\", void 0);\n__decorate([mobx_1.observable], ObservableSecretContractChainQuery.prototype, \"_isIniting\", void 0);\n__decorate([mobx_1.flow], ObservableSecretContractChainQuery.prototype, \"initKeplr\", null);\n__decorate([mobx_1.flow], ObservableSecretContractChainQuery.prototype, \"init\", null);\n__decorate([mobx_1.computed], ObservableSecretContractChainQuery.prototype, \"contractCodeHash\", null);\nexports.ObservableSecretContractChainQuery = ObservableSecretContractChainQuery;","map":{"version":3,"mappings":"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","names":["ObservableSecretContractChainQuery","chain_query_1","constructor","kvStore","chainId","chainGetter","apiGetter","contractAddress","obj","querySecretContractCodeHash","undefined","mobx_1","onStart","_super","keplr","initKeplr","Error","getQueryContract","waitResponse","init","isFetching","_isIniting","canFetch","response","length","nonce","common_1","contractCodeHash","enigmaUtils","getEnigmaUtils","encrypted","encrypt","slice","encoded","buffer_1","from","toString","setUrl","fetchResponse","abortController","headers","fetched","e","data","error","encryptedError","errorMessageRgx","rgxMatches","exec","errorCipherB64","errorCipherBz","decrypted","decrypt","errorStr","encResult","result","smart","message","JSON","parse","status","staled","timestamp","Date","now","getCacheKey","instance","name","defaults","baseURL","getUri","url","stringify","queryCodeHash","__decorate","ref","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/query/secret-wasm/contract-query.ts"],"sourcesContent":["import { ObservableChainQuery } from \"../chain-query\";\nimport { KVStore, toGenerator } from \"@keplr-wallet/common\";\nimport { ChainGetter } from \"../../common\";\nimport { ObservableQuerySecretContractCodeHash } from \"./contract-hash\";\nimport { computed, flow, makeObservable, observable } from \"mobx\";\nimport { Keplr } from \"@keplr-wallet/types\";\nimport { QueryResponse } from \"../../common\";\n\nimport { Buffer } from \"buffer/\";\n\nexport class ObservableSecretContractChainQuery<\n  T\n> extends ObservableChainQuery<T> {\n  @observable.ref\n  protected keplr?: Keplr = undefined;\n\n  protected nonce?: Uint8Array;\n\n  @observable\n  protected _isIniting: boolean = false;\n\n  constructor(\n    kvStore: KVStore,\n    chainId: string,\n    chainGetter: ChainGetter,\n    protected readonly apiGetter: () => Promise<Keplr | undefined>,\n    protected readonly contractAddress: string,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    protected obj: object,\n    protected readonly querySecretContractCodeHash: ObservableQuerySecretContractCodeHash\n  ) {\n    // Don't need to set the url initially because it can't request without encyption.\n    super(kvStore, chainId, chainGetter, ``);\n    makeObservable(this);\n  }\n\n  protected async onStart() {\n    super.onStart();\n\n    if (!this.keplr) {\n      await this.initKeplr();\n    }\n\n    if (!this.keplr) {\n      throw new Error(\"Failed to get keplr\");\n    }\n\n    await this.querySecretContractCodeHash\n      .getQueryContract(this.contractAddress)\n      .waitResponse();\n\n    await this.init();\n  }\n\n  get isFetching(): boolean {\n    return (\n      this.querySecretContractCodeHash.getQueryContract(this.contractAddress)\n        .isFetching ||\n      this.keplr == null ||\n      this._isIniting ||\n      super.isFetching\n    );\n  }\n\n  protected canFetch(): boolean {\n    if (\n      !this.querySecretContractCodeHash.getQueryContract(this.contractAddress)\n        .response\n    ) {\n      return false;\n    }\n\n    return this.contractAddress.length !== 0 && this.nonce != null;\n  }\n\n  @flow\n  protected *initKeplr() {\n    this.keplr = yield* toGenerator(this.apiGetter());\n  }\n\n  @flow\n  protected *init() {\n    this._isIniting = true;\n\n    if (this.keplr && this.contractCodeHash) {\n      const enigmaUtils = this.keplr.getEnigmaUtils(this.chainId);\n      const encrypted = yield* toGenerator(\n        enigmaUtils.encrypt(this.contractCodeHash, this.obj)\n      );\n      this.nonce = encrypted.slice(0, 32);\n\n      const encoded = Buffer.from(\n        Buffer.from(encrypted).toString(\"base64\")\n      ).toString(\"hex\");\n\n      this.setUrl(\n        `/wasm/contract/${this.contractAddress}/query/${encoded}?encoding=hex`\n      );\n    }\n\n    this._isIniting = false;\n  }\n\n  protected async fetchResponse(\n    abortController: AbortController\n  ): Promise<{ response: QueryResponse<T>; headers: any }> {\n    let response: QueryResponse<T>;\n    let headers: any;\n    try {\n      const fetched = await super.fetchResponse(abortController);\n      response = fetched.response;\n      headers = fetched.headers;\n    } catch (e) {\n      if (e.response?.data?.error) {\n        const encryptedError = e.response.data.error;\n\n        const errorMessageRgx = /rpc error: code = (.+) = encrypted: (.+): (.+)/g;\n\n        const rgxMatches = errorMessageRgx.exec(encryptedError);\n        if (rgxMatches != null && rgxMatches.length === 4) {\n          const errorCipherB64 = rgxMatches[2];\n          const errorCipherBz = Buffer.from(errorCipherB64, \"base64\");\n\n          if (this.keplr && this.nonce) {\n            const decrypted = await this.keplr\n              .getEnigmaUtils(this.chainId)\n              .decrypt(errorCipherBz, this.nonce);\n\n            const errorStr = Buffer.from(decrypted).toString();\n\n            // If error is from secret wasm chain itself, decrypt the error message and throw it.\n            throw new Error(errorStr);\n          }\n        }\n      }\n      throw e;\n    }\n\n    const encResult = (response.data as unknown) as\n      | {\n          height: string;\n          result: {\n            smart: string;\n          };\n        }\n      | undefined;\n\n    if (!this.keplr) {\n      throw new Error(\"Keplr API not initialized\");\n    }\n\n    if (!this.nonce) {\n      throw new Error(\"Nonce is unknown\");\n    }\n\n    if (!encResult) {\n      throw new Error(\"Failed to get the response from the contract\");\n    }\n\n    const decrypted = await this.keplr\n      .getEnigmaUtils(this.chainId)\n      .decrypt(Buffer.from(encResult.result.smart, \"base64\"), this.nonce);\n\n    const message = Buffer.from(\n      Buffer.from(decrypted).toString(),\n      \"base64\"\n    ).toString();\n\n    const obj = JSON.parse(message);\n    return {\n      headers,\n      response: {\n        data: obj as T,\n        status: response.status,\n        staled: false,\n        timestamp: Date.now(),\n      },\n    };\n  }\n\n  // Actually, the url of fetching the secret20 balance will be changed every time.\n  // So, we should save it with deterministic key.\n  protected getCacheKey(): string {\n    return `${this.instance.name}-${\n      this.instance.defaults.baseURL\n    }${this.instance.getUri({\n      url: `/wasm/contract/${this.contractAddress}/query/${JSON.stringify(\n        this.obj\n      )}?encoding=json`,\n    })}`;\n  }\n\n  @computed\n  get contractCodeHash(): string | undefined {\n    const queryCodeHash = this.querySecretContractCodeHash.getQueryContract(\n      this.contractAddress\n    );\n\n    if (!queryCodeHash.response) {\n      return undefined;\n    }\n\n    // Code hash is persistent, so it is safe not to consider that the response is from cache or network.\n    // TODO: Handle the error case.\n    return queryCodeHash.response.data.result;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}