{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableQueryCosmosBalanceRegistry = exports.ObservableQueryCosmosBalances = exports.ObservableQueryBalanceNative = void 0;\nconst common_1 = require(\"@keplr-wallet/common\");\nconst mobx_1 = require(\"mobx\");\nconst unit_1 = require(\"@keplr-wallet/unit\");\nconst common_2 = require(\"../../../common\");\nconst balances_1 = require(\"../../balances\");\nconst chain_query_1 = require(\"../../chain-query\");\nclass ObservableQueryBalanceNative extends balances_1.ObservableQueryBalanceInner {\n  constructor(kvStore, chainId, chainGetter, denomHelper, nativeBalances) {\n    super(kvStore, chainId, chainGetter,\n    // No need to set the url\n    \"\", denomHelper);\n    this.nativeBalances = nativeBalances;\n    mobx_1.makeObservable(this);\n  }\n  canFetch() {\n    return false;\n  }\n  get isFetching() {\n    return this.nativeBalances.isFetching;\n  }\n  get error() {\n    return this.nativeBalances.error;\n  }\n  get response() {\n    return this.nativeBalances.response;\n  }\n  *fetch() {\n    yield this.nativeBalances.fetch();\n  }\n  get balance() {\n    const currency = this.currency;\n    if (!this.nativeBalances.response) {\n      return new unit_1.CoinPretty(currency, new unit_1.Int(0)).ready(false);\n    }\n    return common_2.StoreUtils.getBalanceFromCurrency(currency, this.nativeBalances.response.data.balances);\n  }\n}\n__decorate([mobx_1.override], ObservableQueryBalanceNative.prototype, \"fetch\", null);\n__decorate([mobx_1.computed], ObservableQueryBalanceNative.prototype, \"balance\", null);\nexports.ObservableQueryBalanceNative = ObservableQueryBalanceNative;\nclass ObservableQueryCosmosBalances extends chain_query_1.ObservableChainQuery {\n  constructor(kvStore, chainId, chainGetter, bech32Address) {\n    super(kvStore, chainId, chainGetter, `/cosmos/bank/v1beta1/balances/${bech32Address}?pagination.limit=1000`);\n    this.duplicatedFetchCheck = false;\n    this.bech32Address = bech32Address;\n    mobx_1.makeObservable(this);\n  }\n  canFetch() {\n    // If bech32 address is empty, it will always fail, so don't need to fetch it.\n    return this.bech32Address.length > 0;\n  }\n  *fetch() {\n    if (!this.duplicatedFetchCheck) {\n      // Because the native \"bank\" module's balance shares the querying result,\n      // it is inefficient to fetching duplicately in the same loop.\n      // So, if the fetching requests are in the same tick, this prevent to refetch the result and use the prior fetching.\n      this.duplicatedFetchCheck = true;\n      setTimeout(() => {\n        this.duplicatedFetchCheck = false;\n      }, 1);\n      yield super.fetch();\n    }\n  }\n  setResponse(response) {\n    super.setResponse(response);\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    // 반환된 response 안의 denom을 등록하도록 시도한다.\n    // 어차피 이미 등록되어 있으면 밑의 메소드가 아무 행동도 안하기 때문에 괜찮다.\n    // computed를 줄이기 위해서 배열로 한번에 설정하는게 낫다.\n    const denoms = response.data.balances.map(coin => coin.denom);\n    chainInfo.addUnknownCurrencies(...denoms);\n  }\n}\n__decorate([mobx_1.override], ObservableQueryCosmosBalances.prototype, \"fetch\", null);\nexports.ObservableQueryCosmosBalances = ObservableQueryCosmosBalances;\nclass ObservableQueryCosmosBalanceRegistry {\n  constructor(kvStore) {\n    this.kvStore = kvStore;\n    this.nativeBalances = new Map();\n  }\n  getBalanceInner(chainId, chainGetter, bech32Address, minimalDenom) {\n    const denomHelper = new common_1.DenomHelper(minimalDenom);\n    if (denomHelper.type !== \"native\") {\n      return;\n    }\n    const key = `${chainId}/${bech32Address}`;\n    if (!this.nativeBalances.has(key)) {\n      this.nativeBalances.set(key, new ObservableQueryCosmosBalances(this.kvStore, chainId, chainGetter, bech32Address));\n    }\n    return new ObservableQueryBalanceNative(this.kvStore, chainId, chainGetter, denomHelper,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.nativeBalances.get(key));\n  }\n}\nexports.ObservableQueryCosmosBalanceRegistry = ObservableQueryCosmosBalanceRegistry;","map":{"version":3,"mappings":"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","names":["ObservableQueryBalanceNative","balances_1","constructor","kvStore","chainId","chainGetter","denomHelper","nativeBalances","mobx_1","canFetch","isFetching","error","response","fetch","balance","currency","unit_1","ready","common_2","getBalanceFromCurrency","data","balances","__decorate","exports","ObservableQueryCosmosBalances","chain_query_1","bech32Address","length","duplicatedFetchCheck","setTimeout","setResponse","chainInfo","getChain","denoms","map","coin","denom","addUnknownCurrencies","ObservableQueryCosmosBalanceRegistry","Map","getBalanceInner","minimalDenom","common_1","type","key","has","set","get"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/query/cosmos/balance/balances.ts"],"sourcesContent":["import { DenomHelper, KVStore } from \"@keplr-wallet/common\";\nimport { ChainGetter, QueryResponse } from \"../../../common\";\nimport { computed, makeObservable, override } from \"mobx\";\nimport { CoinPretty, Int } from \"@keplr-wallet/unit\";\nimport { StoreUtils } from \"../../../common\";\nimport { BalanceRegistry, ObservableQueryBalanceInner } from \"../../balances\";\nimport { ObservableChainQuery } from \"../../chain-query\";\nimport { Balances } from \"./types\";\n\nexport class ObservableQueryBalanceNative extends ObservableQueryBalanceInner {\n  constructor(\n    kvStore: KVStore,\n    chainId: string,\n    chainGetter: ChainGetter,\n    denomHelper: DenomHelper,\n    protected readonly nativeBalances: ObservableQueryCosmosBalances\n  ) {\n    super(\n      kvStore,\n      chainId,\n      chainGetter,\n      // No need to set the url\n      \"\",\n      denomHelper\n    );\n\n    makeObservable(this);\n  }\n\n  protected canFetch(): boolean {\n    return false;\n  }\n\n  get isFetching(): boolean {\n    return this.nativeBalances.isFetching;\n  }\n\n  get error() {\n    return this.nativeBalances.error;\n  }\n\n  get response() {\n    return this.nativeBalances.response;\n  }\n\n  @override\n  *fetch() {\n    yield this.nativeBalances.fetch();\n  }\n\n  @computed\n  get balance(): CoinPretty {\n    const currency = this.currency;\n\n    if (!this.nativeBalances.response) {\n      return new CoinPretty(currency, new Int(0)).ready(false);\n    }\n\n    return StoreUtils.getBalanceFromCurrency(\n      currency,\n      this.nativeBalances.response.data.balances\n    );\n  }\n}\n\nexport class ObservableQueryCosmosBalances extends ObservableChainQuery<Balances> {\n  protected bech32Address: string;\n\n  protected duplicatedFetchCheck: boolean = false;\n\n  constructor(\n    kvStore: KVStore,\n    chainId: string,\n    chainGetter: ChainGetter,\n    bech32Address: string\n  ) {\n    super(\n      kvStore,\n      chainId,\n      chainGetter,\n      `/cosmos/bank/v1beta1/balances/${bech32Address}?pagination.limit=1000`\n    );\n\n    this.bech32Address = bech32Address;\n\n    makeObservable(this);\n  }\n\n  protected canFetch(): boolean {\n    // If bech32 address is empty, it will always fail, so don't need to fetch it.\n    return this.bech32Address.length > 0;\n  }\n\n  @override\n  *fetch() {\n    if (!this.duplicatedFetchCheck) {\n      // Because the native \"bank\" module's balance shares the querying result,\n      // it is inefficient to fetching duplicately in the same loop.\n      // So, if the fetching requests are in the same tick, this prevent to refetch the result and use the prior fetching.\n      this.duplicatedFetchCheck = true;\n      setTimeout(() => {\n        this.duplicatedFetchCheck = false;\n      }, 1);\n\n      yield super.fetch();\n    }\n  }\n\n  protected setResponse(response: Readonly<QueryResponse<Balances>>) {\n    super.setResponse(response);\n\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    // 반환된 response 안의 denom을 등록하도록 시도한다.\n    // 어차피 이미 등록되어 있으면 밑의 메소드가 아무 행동도 안하기 때문에 괜찮다.\n    // computed를 줄이기 위해서 배열로 한번에 설정하는게 낫다.\n    const denoms = response.data.balances.map((coin) => coin.denom);\n    chainInfo.addUnknownCurrencies(...denoms);\n  }\n}\n\nexport class ObservableQueryCosmosBalanceRegistry implements BalanceRegistry {\n  protected nativeBalances: Map<\n    string,\n    ObservableQueryCosmosBalances\n  > = new Map();\n\n  constructor(protected readonly kvStore: KVStore) {}\n\n  getBalanceInner(\n    chainId: string,\n    chainGetter: ChainGetter,\n    bech32Address: string,\n    minimalDenom: string\n  ): ObservableQueryBalanceInner | undefined {\n    const denomHelper = new DenomHelper(minimalDenom);\n    if (denomHelper.type !== \"native\") {\n      return;\n    }\n\n    const key = `${chainId}/${bech32Address}`;\n\n    if (!this.nativeBalances.has(key)) {\n      this.nativeBalances.set(\n        key,\n        new ObservableQueryCosmosBalances(\n          this.kvStore,\n          chainId,\n          chainGetter,\n          bech32Address\n        )\n      );\n    }\n\n    return new ObservableQueryBalanceNative(\n      this.kvStore,\n      chainId,\n      chainGetter,\n      denomHelper,\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.nativeBalances.get(key)!\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}