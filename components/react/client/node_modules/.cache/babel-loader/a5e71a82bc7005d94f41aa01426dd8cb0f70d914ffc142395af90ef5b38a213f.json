{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SecretWasmService = void 0;\nconst secretjs_1 = require(\"secretjs\");\nconst crypto_1 = require(\"@keplr-wallet/crypto\");\nconst common_1 = require(\"@keplr-wallet/common\");\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nconst router_1 = require(\"@keplr-wallet/router\");\nconst buffer_1 = require(\"buffer/\");\nclass SecretWasmService {\n  constructor(kvStore) {\n    this.kvStore = kvStore;\n    this.debouncerMap = new Map();\n    this.cacheEnigmaUtils = new Map();\n    this.onChainRemoved = () => {\n      this.cacheEnigmaUtils = new Map();\n    };\n  }\n  init(chainsService, keyRingService, permissionService) {\n    this.chainsService = chainsService;\n    this.keyRingService = keyRingService;\n    this.permissionService = permissionService;\n    this.chainsService.addChainRemovedHandler(this.onChainRemoved);\n  }\n  getPubkey(env, chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainInfo = yield this.chainsService.getChainInfo(chainId);\n      const keyRingType = yield this.keyRingService.getKeyRingType();\n      if (keyRingType === \"none\") {\n        throw new router_1.KeplrError(\"secret-wasm\", 130, \"Key ring is not initialized\");\n      }\n      const seed = yield this.getSeed(env, chainInfo);\n      const utils = this.getEnigmaUtils(chainInfo, seed);\n      return utils.pubkey;\n    });\n  }\n  getTxEncryptionKey(env, chainId, nonce) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainInfo = yield this.chainsService.getChainInfo(chainId);\n      const keyRingType = yield this.keyRingService.getKeyRingType();\n      if (keyRingType === \"none\") {\n        throw new router_1.KeplrError(\"secret-wasm\", 130, \"Key ring is not initialized\");\n      }\n      const seed = yield this.getSeed(env, chainInfo);\n      const utils = this.getEnigmaUtils(chainInfo, seed);\n      return utils.getTxEncryptionKey(nonce);\n    });\n  }\n  encrypt(env, chainId, contractCodeHash,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainInfo = yield this.chainsService.getChainInfo(chainId);\n      const keyRingType = yield this.keyRingService.getKeyRingType();\n      if (keyRingType === \"none\") {\n        throw new router_1.KeplrError(\"secret-wasm\", 130, \"Key ring is not initialized\");\n      }\n      // XXX: Keplr should generate the seed deterministically according to the account.\n      // Otherwise, it will lost the encryption/decryption key if Keplr is uninstalled or local storage is cleared.\n      // For now, use the signature of some string to generate the seed.\n      // It need to more research.\n      const seed = yield this.getSeed(env, chainInfo);\n      const utils = this.getEnigmaUtils(chainInfo, seed);\n      return yield utils.encrypt(contractCodeHash, msg);\n    });\n  }\n  decrypt(env, chainId, ciphertext, nonce) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainInfo = yield this.chainsService.getChainInfo(chainId);\n      const keyRingType = yield this.keyRingService.getKeyRingType();\n      if (keyRingType === \"none\") {\n        throw new router_1.KeplrError(\"secret-wasm\", 130, \"Key ring is not initialized\");\n      }\n      // XXX: Keplr should generate the seed deterministically according to the account.\n      // Otherwise, it will lost the encryption/decryption key if Keplr is uninstalled or local storage is cleared.\n      // For now, use the signature of some string to generate the seed.\n      // It need to more research.\n      const seed = yield this.getSeed(env, chainInfo);\n      const utils = this.getEnigmaUtils(chainInfo, seed);\n      return yield utils.decrypt(ciphertext, nonce);\n    });\n  }\n  getEnigmaUtils(chainInfo, seed) {\n    const key = `${chainInfo.chainId}-${buffer_1.Buffer.from(seed).toString(\"hex\")}`;\n    if (this.cacheEnigmaUtils.has(key)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.cacheEnigmaUtils.get(key);\n    }\n    // TODO: Handle the rest config.\n    const utils = new secretjs_1.EnigmaUtils(chainInfo.rest, seed);\n    this.cacheEnigmaUtils.set(key, utils);\n    return utils;\n  }\n  // GetSeed will be debounced if the prior promise is pending.\n  // GetSeed can be occured multiple times at once,\n  // this case can be problem if the cache doesn't exist and key type is ledger,\n  // because multiple requests to ledger will make the connection unstable.\n  getSeed(env, chainInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const key = yield this.keyRingService.getKey(chainInfo.chainId);\n      const bech32Address = new cosmos_1.Bech32Address(key.address).toBech32(chainInfo.bech32Config.bech32PrefixAccAddr);\n      const debouncerKey = `${env.isInternalMsg}/${chainInfo.chainId}/${bech32Address}`;\n      if (!this.debouncerMap.has(debouncerKey)) {\n        this.debouncerMap.set(debouncerKey, common_1.Debouncer.promise(this.getSeedInner.bind(this)));\n      }\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const debouncedFn = this.debouncerMap.get(debouncerKey);\n      return yield debouncedFn(env, chainInfo, bech32Address);\n    });\n  }\n  getSeedInner(env, chainInfo, bech32Address) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const storeKey = `seed-${chainInfo.chainId}-${bech32Address}`;\n      const cached = yield this.kvStore.get(storeKey);\n      if (cached) {\n        return buffer_1.Buffer.from(cached, \"hex\");\n      }\n      const seed = crypto_1.Hash.sha256(buffer_1.Buffer.from(yield this.keyRingService.sign(env, chainInfo.chainId, buffer_1.Buffer.from(JSON.stringify({\n        account_number: 0,\n        chain_id: chainInfo.chainId,\n        fee: [],\n        memo: \"Create Keplr Secret encryption key. Only approve requests by Keplr.\",\n        msgs: [],\n        sequence: 0\n      })))));\n      yield this.kvStore.set(storeKey, buffer_1.Buffer.from(seed).toString(\"hex\"));\n      return seed;\n    });\n  }\n}\nexports.SecretWasmService = SecretWasmService;","map":{"version":3,"mappings":"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","names":["SecretWasmService","constructor","kvStore","Map","cacheEnigmaUtils","init","chainsService","keyRingService","permissionService","addChainRemovedHandler","onChainRemoved","getPubkey","env","chainId","chainInfo","getChainInfo","keyRingType","getKeyRingType","router_1","seed","getSeed","utils","getEnigmaUtils","pubkey","getTxEncryptionKey","nonce","encrypt","contractCodeHash","msg","decrypt","ciphertext","key","buffer_1","from","toString","has","get","secretjs_1","rest","set","getKey","bech32Address","cosmos_1","address","toBech32","bech32Config","bech32PrefixAccAddr","debouncerKey","isInternalMsg","debouncerMap","common_1","promise","getSeedInner","bind","debouncedFn","storeKey","cached","crypto_1","sha256","sign","JSON","stringify","account_number","chain_id","fee","memo","msgs","sequence","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/background/src/secret-wasm/service.ts"],"sourcesContent":["import { EnigmaUtils } from \"secretjs\";\nimport { KeyRingService } from \"../keyring\";\nimport { ChainsService } from \"../chains\";\nimport { PermissionService } from \"../permission\";\nimport { Hash } from \"@keplr-wallet/crypto\";\nimport { KVStore, Debouncer } from \"@keplr-wallet/common\";\nimport { ChainInfo } from \"@keplr-wallet/types\";\nimport { Bech32Address } from \"@keplr-wallet/cosmos\";\nimport { Env, KeplrError } from \"@keplr-wallet/router\";\nimport { Buffer } from \"buffer/\";\n\nexport class SecretWasmService {\n  protected debouncerMap: Map<\n    string,\n    (\n      env: Env,\n      chainInfo: ChainInfo,\n      bech32Address: string\n    ) => Promise<Uint8Array>\n  > = new Map();\n\n  protected cacheEnigmaUtils: Map<string, EnigmaUtils> = new Map();\n\n  protected chainsService!: ChainsService;\n  protected keyRingService!: KeyRingService;\n  public permissionService!: PermissionService;\n\n  constructor(protected readonly kvStore: KVStore) {}\n\n  init(\n    chainsService: ChainsService,\n    keyRingService: KeyRingService,\n    permissionService: PermissionService\n  ) {\n    this.chainsService = chainsService;\n    this.keyRingService = keyRingService;\n    this.permissionService = permissionService;\n\n    this.chainsService.addChainRemovedHandler(this.onChainRemoved);\n  }\n\n  protected readonly onChainRemoved = () => {\n    this.cacheEnigmaUtils = new Map();\n  };\n\n  async getPubkey(env: Env, chainId: string): Promise<Uint8Array> {\n    const chainInfo = await this.chainsService.getChainInfo(chainId);\n\n    const keyRingType = await this.keyRingService.getKeyRingType();\n    if (keyRingType === \"none\") {\n      throw new KeplrError(\"secret-wasm\", 130, \"Key ring is not initialized\");\n    }\n\n    const seed = await this.getSeed(env, chainInfo);\n\n    const utils = this.getEnigmaUtils(chainInfo, seed);\n    return utils.pubkey;\n  }\n\n  async getTxEncryptionKey(\n    env: Env,\n    chainId: string,\n    nonce: Uint8Array\n  ): Promise<Uint8Array> {\n    const chainInfo = await this.chainsService.getChainInfo(chainId);\n\n    const keyRingType = await this.keyRingService.getKeyRingType();\n    if (keyRingType === \"none\") {\n      throw new KeplrError(\"secret-wasm\", 130, \"Key ring is not initialized\");\n    }\n\n    const seed = await this.getSeed(env, chainInfo);\n\n    const utils = this.getEnigmaUtils(chainInfo, seed);\n    return utils.getTxEncryptionKey(nonce);\n  }\n\n  async encrypt(\n    env: Env,\n    chainId: string,\n    contractCodeHash: string,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    msg: object\n  ): Promise<Uint8Array> {\n    const chainInfo = await this.chainsService.getChainInfo(chainId);\n\n    const keyRingType = await this.keyRingService.getKeyRingType();\n    if (keyRingType === \"none\") {\n      throw new KeplrError(\"secret-wasm\", 130, \"Key ring is not initialized\");\n    }\n\n    // XXX: Keplr should generate the seed deterministically according to the account.\n    // Otherwise, it will lost the encryption/decryption key if Keplr is uninstalled or local storage is cleared.\n    // For now, use the signature of some string to generate the seed.\n    // It need to more research.\n    const seed = await this.getSeed(env, chainInfo);\n\n    const utils = this.getEnigmaUtils(chainInfo, seed);\n\n    return await utils.encrypt(contractCodeHash, msg);\n  }\n\n  async decrypt(\n    env: Env,\n    chainId: string,\n    ciphertext: Uint8Array,\n    nonce: Uint8Array\n  ): Promise<Uint8Array> {\n    const chainInfo = await this.chainsService.getChainInfo(chainId);\n\n    const keyRingType = await this.keyRingService.getKeyRingType();\n    if (keyRingType === \"none\") {\n      throw new KeplrError(\"secret-wasm\", 130, \"Key ring is not initialized\");\n    }\n\n    // XXX: Keplr should generate the seed deterministically according to the account.\n    // Otherwise, it will lost the encryption/decryption key if Keplr is uninstalled or local storage is cleared.\n    // For now, use the signature of some string to generate the seed.\n    // It need to more research.\n    const seed = await this.getSeed(env, chainInfo);\n\n    const utils = this.getEnigmaUtils(chainInfo, seed);\n\n    return await utils.decrypt(ciphertext, nonce);\n  }\n\n  private getEnigmaUtils(chainInfo: ChainInfo, seed: Uint8Array): EnigmaUtils {\n    const key = `${chainInfo.chainId}-${Buffer.from(seed).toString(\"hex\")}`;\n\n    if (this.cacheEnigmaUtils.has(key)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.cacheEnigmaUtils.get(key)!;\n    }\n\n    // TODO: Handle the rest config.\n    const utils = new EnigmaUtils(chainInfo.rest, seed);\n    this.cacheEnigmaUtils.set(key, utils);\n\n    return utils;\n  }\n\n  // GetSeed will be debounced if the prior promise is pending.\n  // GetSeed can be occured multiple times at once,\n  // this case can be problem if the cache doesn't exist and key type is ledger,\n  // because multiple requests to ledger will make the connection unstable.\n  protected async getSeed(env: Env, chainInfo: ChainInfo): Promise<Uint8Array> {\n    const key = await this.keyRingService.getKey(chainInfo.chainId);\n    const bech32Address = new Bech32Address(key.address).toBech32(\n      chainInfo.bech32Config.bech32PrefixAccAddr\n    );\n    const debouncerKey = `${env.isInternalMsg}/${chainInfo.chainId}/${bech32Address}`;\n\n    if (!this.debouncerMap.has(debouncerKey)) {\n      this.debouncerMap.set(\n        debouncerKey,\n        Debouncer.promise(this.getSeedInner.bind(this))\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const debouncedFn = this.debouncerMap.get(debouncerKey)!;\n\n    return await debouncedFn(env, chainInfo, bech32Address);\n  }\n\n  protected async getSeedInner(\n    env: Env,\n    chainInfo: ChainInfo,\n    bech32Address: string\n  ): Promise<Uint8Array> {\n    const storeKey = `seed-${chainInfo.chainId}-${bech32Address}`;\n\n    const cached = await this.kvStore.get<string>(storeKey);\n    if (cached) {\n      return Buffer.from(cached, \"hex\");\n    }\n\n    const seed = Hash.sha256(\n      Buffer.from(\n        await this.keyRingService.sign(\n          env,\n          chainInfo.chainId,\n          Buffer.from(\n            JSON.stringify({\n              account_number: 0,\n              chain_id: chainInfo.chainId,\n              fee: [],\n              memo:\n                \"Create Keplr Secret encryption key. Only approve requests by Keplr.\",\n              msgs: [],\n              sequence: 0,\n            })\n          )\n        )\n      )\n    );\n\n    await this.kvStore.set(storeKey, Buffer.from(seed).toString(\"hex\"));\n\n    return seed;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}