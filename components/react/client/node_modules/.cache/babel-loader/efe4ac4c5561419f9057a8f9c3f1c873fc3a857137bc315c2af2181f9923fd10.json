{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Registry = exports.isPbjsGeneratedType = exports.isTsProtoGeneratedType = void 0;\nconst tx_1 = require(\"./codec/cosmos/bank/v1beta1/tx\");\nconst coin_1 = require(\"./codec/cosmos/base/v1beta1/coin\");\nconst tx_2 = require(\"./codec/cosmos/tx/v1beta1/tx\");\nconst any_1 = require(\"./codec/google/protobuf/any\");\nfunction isTsProtoGeneratedType(type) {\n  return typeof type.fromPartial === \"function\";\n}\nexports.isTsProtoGeneratedType = isTsProtoGeneratedType;\nfunction isPbjsGeneratedType(type) {\n  return !isTsProtoGeneratedType(type);\n}\nexports.isPbjsGeneratedType = isPbjsGeneratedType;\nconst defaultTypeUrls = {\n  cosmosCoin: \"/cosmos.base.v1beta1.Coin\",\n  cosmosMsgSend: \"/cosmos.bank.v1beta1.MsgSend\",\n  cosmosTxBody: \"/cosmos.tx.v1beta1.TxBody\",\n  googleAny: \"/google.protobuf.Any\"\n};\nclass Registry {\n  constructor() {\n    let customTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    const {\n      cosmosCoin,\n      cosmosMsgSend\n    } = defaultTypeUrls;\n    this.types = new Map([[cosmosCoin, coin_1.Coin], [cosmosMsgSend, tx_1.MsgSend], ...customTypes]);\n  }\n  register(typeUrl, type) {\n    this.types.set(typeUrl, type);\n  }\n  /**\n   * Looks up a type that was previously added to the registry.\n   *\n   * The generator information (ts-proto or pbjs) gets lost along the way.\n   * If you need to work with the result type in TypeScript, you can use:\n   *\n   * ```\n   * import { assert } from \"@cosmjs/utils\";\n   *\n   * const Coin = registry.lookupType(\"/cosmos.base.v1beta1.Coin\");\n   * assert(Coin); // Ensures not unset\n   * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect\n   *\n   * // Coin is typed TsProtoGeneratedType now.\n   * ```\n   */\n  lookupType(typeUrl) {\n    return this.types.get(typeUrl);\n  }\n  lookupTypeWithError(typeUrl) {\n    const type = this.lookupType(typeUrl);\n    if (!type) {\n      throw new Error(`Unregistered type url: ${typeUrl}`);\n    }\n    return type;\n  }\n  encode(_ref) {\n    let {\n      typeUrl,\n      value\n    } = _ref;\n    if (typeUrl === defaultTypeUrls.cosmosTxBody) {\n      return this.encodeTxBody(value);\n    }\n    const type = this.lookupTypeWithError(typeUrl);\n    const instance = isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);\n    return Uint8Array.from(type.encode(instance).finish());\n  }\n  encodeTxBody(txBodyFields) {\n    const wrappedMessages = txBodyFields.messages.map(message => {\n      const messageBytes = this.encode(message);\n      return any_1.Any.fromPartial({\n        typeUrl: message.typeUrl,\n        value: messageBytes\n      });\n    });\n    const txBody = tx_2.TxBody.fromPartial(Object.assign(Object.assign({}, txBodyFields), {\n      messages: wrappedMessages\n    }));\n    return Uint8Array.from(tx_2.TxBody.encode(txBody).finish());\n  }\n  decode(_ref2) {\n    let {\n      typeUrl,\n      value\n    } = _ref2;\n    if (typeUrl === defaultTypeUrls.cosmosTxBody) {\n      return this.decodeTxBody(value);\n    }\n    const type = this.lookupTypeWithError(typeUrl);\n    const decoded = type.decode(value);\n    Object.entries(decoded).forEach(_ref3 => {\n      let [key, val] = _ref3;\n      if (typeof Buffer !== \"undefined\" && typeof Buffer.isBuffer !== \"undefined\" && Buffer.isBuffer(val)) {\n        decoded[key] = Uint8Array.from(val);\n      }\n    });\n    return decoded;\n  }\n  decodeTxBody(txBody) {\n    const decodedTxBody = tx_2.TxBody.decode(txBody);\n    return Object.assign(Object.assign({}, decodedTxBody), {\n      messages: decodedTxBody.messages.map(_ref4 => {\n        let {\n          typeUrl: typeUrl,\n          value\n        } = _ref4;\n        if (!typeUrl) {\n          throw new Error(\"Missing type_url in Any\");\n        }\n        if (!value) {\n          throw new Error(\"Missing value in Any\");\n        }\n        return this.decode({\n          typeUrl,\n          value\n        });\n      })\n    });\n  }\n}\nexports.Registry = Registry;","map":{"version":3,"mappings":"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","names":["isTsProtoGeneratedType","type","fromPartial","exports","isPbjsGeneratedType","defaultTypeUrls","cosmosCoin","cosmosMsgSend","cosmosTxBody","googleAny","Registry","constructor","customTypes","types","Map","coin_1","tx_1","register","typeUrl","set","lookupType","get","lookupTypeWithError","Error","encode","value","encodeTxBody","instance","create","Uint8Array","from","finish","txBodyFields","wrappedMessages","messages","map","message","messageBytes","any_1","txBody","tx_2","decode","decodeTxBody","decoded","Object","entries","forEach","key","val","Buffer","isBuffer","decodedTxBody"],"sources":["../src/registry.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}