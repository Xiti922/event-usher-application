{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Crypto = void 0;\nconst aes_js_1 = __importStar(require(\"aes-js\"));\nconst crypto_1 = require(\"@keplr-wallet/crypto\");\nconst pbkdf2_1 = __importDefault(require(\"pbkdf2\"));\nconst buffer_1 = require(\"buffer/\");\nconst router_1 = require(\"@keplr-wallet/router\");\nclass Crypto {\n  static encrypt(crypto, kdf, type, text, password, meta, bip44HDPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let random = new Uint8Array(32);\n      const salt = buffer_1.Buffer.from(yield crypto.rng(random)).toString(\"hex\");\n      const scryptParams = {\n        salt,\n        dklen: 32,\n        n: 131072,\n        r: 8,\n        p: 1\n      };\n      const derivedKey = yield (() => __awaiter(this, void 0, void 0, function* () {\n        switch (kdf) {\n          case \"scrypt\":\n            return yield crypto.scrypt(password, scryptParams);\n          case \"sha256\":\n            return crypto_1.Hash.sha256(buffer_1.Buffer.from(`${salt}/${password}`));\n          case \"pbkdf2\":\n            return new Promise((resolve, reject) => {\n              pbkdf2_1.default.pbkdf2(password, salt, 4000, 32, \"sha256\", (err, derivedKey) => {\n                if (err) {\n                  reject(err);\n                } else {\n                  resolve(new Uint8Array(derivedKey));\n                }\n              });\n            });\n          default:\n            throw new router_1.KeplrError(\"keyring\", 220, \"Unknown kdf\");\n        }\n      }))();\n      const buf = buffer_1.Buffer.from(text);\n      random = new Uint8Array(16);\n      const iv = buffer_1.Buffer.from(yield crypto.rng(random));\n      const counter = new aes_js_1.Counter(0);\n      counter.setBytes(iv);\n      const aesCtr = new aes_js_1.default.ModeOfOperation.ctr(derivedKey, counter);\n      const ciphertext = buffer_1.Buffer.from(aesCtr.encrypt(buf));\n      // Mac is sha256(last 16 bytes of derived key + ciphertext)\n      const mac = crypto_1.Hash.sha256(buffer_1.Buffer.concat([buffer_1.Buffer.from(derivedKey.slice(derivedKey.length / 2)), ciphertext]));\n      return {\n        version: \"1.2\",\n        type,\n        coinTypeForChain: {},\n        bip44HDPath,\n        meta,\n        crypto: {\n          cipher: \"aes-128-ctr\",\n          cipherparams: {\n            iv: iv.toString(\"hex\")\n          },\n          ciphertext: ciphertext.toString(\"hex\"),\n          kdf,\n          kdfparams: scryptParams,\n          mac: buffer_1.Buffer.from(mac).toString(\"hex\")\n        }\n      };\n    });\n  }\n  static decrypt(crypto, keyStore, password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const derivedKey = yield (() => __awaiter(this, void 0, void 0, function* () {\n        switch (keyStore.crypto.kdf) {\n          case \"scrypt\":\n            return yield crypto.scrypt(password, keyStore.crypto.kdfparams);\n          case \"sha256\":\n            return crypto_1.Hash.sha256(buffer_1.Buffer.from(`${keyStore.crypto.kdfparams.salt}/${password}`));\n          case \"pbkdf2\":\n            return new Promise((resolve, reject) => {\n              pbkdf2_1.default.pbkdf2(password, keyStore.crypto.kdfparams.salt, 4000, 32, \"sha256\", (err, derivedKey) => {\n                if (err) {\n                  reject(err);\n                } else {\n                  resolve(new Uint8Array(derivedKey));\n                }\n              });\n            });\n          default:\n            throw new router_1.KeplrError(\"keyring\", 220, \"Unknown kdf\");\n        }\n      }))();\n      const counter = new aes_js_1.Counter(0);\n      counter.setBytes(buffer_1.Buffer.from(keyStore.crypto.cipherparams.iv, \"hex\"));\n      const aesCtr = new aes_js_1.default.ModeOfOperation.ctr(derivedKey, counter);\n      const mac = crypto_1.Hash.sha256(buffer_1.Buffer.concat([buffer_1.Buffer.from(derivedKey.slice(derivedKey.length / 2)), buffer_1.Buffer.from(keyStore.crypto.ciphertext, \"hex\")]));\n      if (!buffer_1.Buffer.from(mac).equals(buffer_1.Buffer.from(keyStore.crypto.mac, \"hex\"))) {\n        throw new router_1.KeplrError(\"keyring\", 222, \"Unmatched mac\");\n      }\n      return buffer_1.Buffer.from(aesCtr.decrypt(buffer_1.Buffer.from(keyStore.crypto.ciphertext, \"hex\")));\n    });\n  }\n}\nexports.Crypto = Crypto;","map":{"version":3,"mappings":"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","names":["Crypto","encrypt","crypto","kdf","type","text","password","meta","bip44HDPath","random","Uint8Array","salt","buffer_1","from","rng","toString","scryptParams","dklen","n","r","p","derivedKey","__awaiter","scrypt","crypto_1","sha256","Promise","resolve","reject","pbkdf2_1","pbkdf2","err","router_1","buf","iv","counter","aes_js_1","setBytes","aesCtr","ModeOfOperation","ctr","ciphertext","mac","concat","slice","length","version","coinTypeForChain","cipher","cipherparams","kdfparams","decrypt","keyStore","equals","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/background/src/keyring/crypto.ts"],"sourcesContent":["import AES, { Counter } from \"aes-js\";\nimport {\n  BIP44HDPath,\n  CoinTypeForChain,\n  ScryptParams,\n  CommonCrypto,\n} from \"./types\";\nimport { Hash } from \"@keplr-wallet/crypto\";\nimport pbkdf2 from \"pbkdf2\";\n\nimport { Buffer } from \"buffer/\";\nimport { KeplrError } from \"@keplr-wallet/router\";\n\n/**\n * This is similar to ethereum's key store.\n * But, the encryped data is not the private key, but the mnemonic words.\n */\nexport interface KeyStore {\n  version: \"1.2\";\n  /**\n   * Type can be \"mnemonic\" or \"privateKey\".\n   * Below version \"1\", type is not defined and it is considered as \"mnemonic\".\n   */\n  type?: \"mnemonic\" | \"privateKey\" | \"ledger\";\n  coinTypeForChain: CoinTypeForChain;\n  bip44HDPath?: BIP44HDPath;\n  meta?: {\n    [key: string]: string;\n  };\n  crypto: {\n    cipher: \"aes-128-ctr\";\n    cipherparams: {\n      iv: string;\n    };\n    ciphertext: string;\n    // Strength: scrypt >>> pbkdf2 > sha256\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\";\n    kdfparams: ScryptParams;\n    mac: string;\n  };\n}\n\nexport class Crypto {\n  public static async encrypt(\n    crypto: CommonCrypto,\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    type: \"mnemonic\" | \"privateKey\" | \"ledger\",\n    text: string,\n    password: string,\n    meta: Record<string, string>,\n    bip44HDPath?: BIP44HDPath\n  ): Promise<KeyStore> {\n    let random = new Uint8Array(32);\n    const salt = Buffer.from(await crypto.rng(random)).toString(\"hex\");\n\n    const scryptParams: ScryptParams = {\n      salt,\n      dklen: 32,\n      n: 131072,\n      r: 8,\n      p: 1,\n    };\n    const derivedKey = await (async () => {\n      switch (kdf) {\n        case \"scrypt\":\n          return await crypto.scrypt(password, scryptParams);\n        case \"sha256\":\n          return Hash.sha256(Buffer.from(`${salt}/${password}`));\n        case \"pbkdf2\":\n          return new Promise<Uint8Array>((resolve, reject) => {\n            pbkdf2.pbkdf2(\n              password,\n              salt,\n              4000,\n              32,\n              \"sha256\",\n              (err, derivedKey) => {\n                if (err) {\n                  reject(err);\n                } else {\n                  resolve(new Uint8Array(derivedKey));\n                }\n              }\n            );\n          });\n        default:\n          throw new KeplrError(\"keyring\", 220, \"Unknown kdf\");\n      }\n    })();\n    const buf = Buffer.from(text);\n\n    random = new Uint8Array(16);\n    const iv = Buffer.from(await crypto.rng(random));\n\n    const counter = new Counter(0);\n    counter.setBytes(iv);\n    const aesCtr = new AES.ModeOfOperation.ctr(derivedKey, counter);\n    const ciphertext = Buffer.from(aesCtr.encrypt(buf));\n    // Mac is sha256(last 16 bytes of derived key + ciphertext)\n    const mac = Hash.sha256(\n      Buffer.concat([\n        Buffer.from(derivedKey.slice(derivedKey.length / 2)),\n        ciphertext,\n      ])\n    );\n    return {\n      version: \"1.2\",\n      type,\n      coinTypeForChain: {},\n      bip44HDPath,\n      meta,\n      crypto: {\n        cipher: \"aes-128-ctr\",\n        cipherparams: {\n          iv: iv.toString(\"hex\"),\n        },\n        ciphertext: ciphertext.toString(\"hex\"),\n        kdf,\n        kdfparams: scryptParams,\n        mac: Buffer.from(mac).toString(\"hex\"),\n      },\n    };\n  }\n\n  public static async decrypt(\n    crypto: CommonCrypto,\n    keyStore: KeyStore,\n    password: string\n  ): Promise<Uint8Array> {\n    const derivedKey = await (async () => {\n      switch (keyStore.crypto.kdf) {\n        case \"scrypt\":\n          return await crypto.scrypt(password, keyStore.crypto.kdfparams);\n        case \"sha256\":\n          return Hash.sha256(\n            Buffer.from(`${keyStore.crypto.kdfparams.salt}/${password}`)\n          );\n        case \"pbkdf2\":\n          return new Promise<Uint8Array>((resolve, reject) => {\n            pbkdf2.pbkdf2(\n              password,\n              keyStore.crypto.kdfparams.salt,\n              4000,\n              32,\n              \"sha256\",\n              (err, derivedKey) => {\n                if (err) {\n                  reject(err);\n                } else {\n                  resolve(new Uint8Array(derivedKey));\n                }\n              }\n            );\n          });\n        default:\n          throw new KeplrError(\"keyring\", 220, \"Unknown kdf\");\n      }\n    })();\n\n    const counter = new Counter(0);\n    counter.setBytes(Buffer.from(keyStore.crypto.cipherparams.iv, \"hex\"));\n    const aesCtr = new AES.ModeOfOperation.ctr(derivedKey, counter);\n\n    const mac = Hash.sha256(\n      Buffer.concat([\n        Buffer.from(derivedKey.slice(derivedKey.length / 2)),\n        Buffer.from(keyStore.crypto.ciphertext, \"hex\"),\n      ])\n    );\n    if (!Buffer.from(mac).equals(Buffer.from(keyStore.crypto.mac, \"hex\"))) {\n      throw new KeplrError(\"keyring\", 222, \"Unmatched mac\");\n    }\n\n    return Buffer.from(\n      aesCtr.decrypt(Buffer.from(keyStore.crypto.ciphertext, \"hex\"))\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}