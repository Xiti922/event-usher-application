{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableQueryCw20BalanceRegistry = exports.ObservableQueryCw20BalanceInner = exports.ObservableQueryCw20Balance = void 0;\nconst mobx_1 = require(\"mobx\");\nconst common_1 = require(\"@keplr-wallet/common\");\nconst unit_1 = require(\"@keplr-wallet/unit\");\nconst balances_1 = require(\"../balances\");\nconst contract_query_1 = require(\"./contract-query\");\nclass ObservableQueryCw20Balance extends contract_query_1.ObservableCosmwasmContractChainQuery {\n  constructor(kvStore, chainId, chainGetter, contractAddress, bech32Address) {\n    super(kvStore, chainId, chainGetter, contractAddress, {\n      balance: {\n        address: bech32Address\n      }\n    });\n    this.contractAddress = contractAddress;\n    this.bech32Address = bech32Address;\n  }\n  canFetch() {\n    return super.canFetch() && this.bech32Address !== \"\";\n  }\n}\nexports.ObservableQueryCw20Balance = ObservableQueryCw20Balance;\nclass ObservableQueryCw20BalanceInner extends balances_1.ObservableQueryBalanceInner {\n  constructor(kvStore, chainId, chainGetter, denomHelper, bech32Address) {\n    super(kvStore, chainId, chainGetter,\n    // No need to set the url at initial.\n    \"\", denomHelper);\n    this.bech32Address = bech32Address;\n    mobx_1.makeObservable(this);\n    this.queryCw20Balance = new ObservableQueryCw20Balance(kvStore, chainId, chainGetter, denomHelper.contractAddress, bech32Address);\n  }\n  // This method doesn't have the role because the fetching is actually exeucnted in the `ObservableQueryCw20Balance`.\n  canFetch() {\n    return false;\n  }\n  *fetch() {\n    yield this.queryCw20Balance.fetch();\n  }\n  get balance() {\n    const denom = this.denomHelper.denom;\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    const currency = chainInfo.currencies.find(cur => cur.coinMinimalDenom === denom);\n    // TODO: Infer the currency according to its denom (such if denom is `uatom` -> `Atom` with decimal 6)?\n    if (!currency) {\n      throw new Error(`Unknown currency: ${denom}`);\n    }\n    if (!this.queryCw20Balance.response || !this.queryCw20Balance.response.data.balance) {\n      return new unit_1.CoinPretty(currency, new unit_1.Int(0)).ready(false);\n    }\n    return new unit_1.CoinPretty(currency, new unit_1.Int(this.queryCw20Balance.response.data.balance));\n  }\n}\n__decorate([mobx_1.override], ObservableQueryCw20BalanceInner.prototype, \"fetch\", null);\n__decorate([mobx_1.computed], ObservableQueryCw20BalanceInner.prototype, \"balance\", null);\nexports.ObservableQueryCw20BalanceInner = ObservableQueryCw20BalanceInner;\nclass ObservableQueryCw20BalanceRegistry {\n  constructor(kvStore) {\n    this.kvStore = kvStore;\n  }\n  getBalanceInner(chainId, chainGetter, bech32Address, minimalDenom) {\n    const denomHelper = new common_1.DenomHelper(minimalDenom);\n    if (denomHelper.type === \"cw20\") {\n      return new ObservableQueryCw20BalanceInner(this.kvStore, chainId, chainGetter, denomHelper, bech32Address);\n    }\n  }\n}\nexports.ObservableQueryCw20BalanceRegistry = ObservableQueryCw20BalanceRegistry;","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;AAEA;AAEA,MAAaA,0BAA2B,SAAQC,qDAAyD;EACvGC,YACEC,OAAgB,EAChBC,OAAe,EACfC,WAAwB,EACLC,eAAuB,EACvBC,aAAqB;IAExC,KAAK,CAACJ,OAAO,EAAEC,OAAO,EAAEC,WAAW,EAAEC,eAAe,EAAE;MACpDE,OAAO,EAAE;QAAEC,OAAO,EAAEF;MAAa;KAClC,CAAC;IALiB,oBAAe,GAAfD,eAAe;IACf,kBAAa,GAAbC,aAAa;EAKlC;EAEUG,QAAQ;IAChB,OAAO,KAAK,CAACA,QAAQ,EAAE,IAAI,IAAI,CAACH,aAAa,KAAK,EAAE;EACtD;;AAfFI;AAkBA,MAAaC,+BAAgC,SAAQC,sCAA2B;EAG9EX,YACEC,OAAgB,EAChBC,OAAe,EACfC,WAAwB,EACxBS,WAAwB,EACLP,aAAqB;IAExC,KAAK,CACHJ,OAAO,EACPC,OAAO,EACPC,WAAW;IACX;IACA,EAAE,EACFS,WAAW,CACZ;IATkB,kBAAa,GAAbP,aAAa;IAWhCQ,qBAAc,CAAC,IAAI,CAAC;IAEpB,IAAI,CAACC,gBAAgB,GAAG,IAAIhB,0BAA0B,CACpDG,OAAO,EACPC,OAAO,EACPC,WAAW,EACXS,WAAW,CAACR,eAAe,EAC3BC,aAAa,CACd;EACH;EAEA;EACUG,QAAQ;IAChB,OAAO,KAAK;EACd;EAGA,CAACO,KAAK;IACJ,MAAM,IAAI,CAACD,gBAAgB,CAACC,KAAK,EAAE;EACrC;EAGA,IAAIT,OAAO;IACT,MAAMU,KAAK,GAAG,IAAI,CAACJ,WAAW,CAACI,KAAK;IAEpC,MAAMC,SAAS,GAAG,IAAI,CAACd,WAAW,CAACe,QAAQ,CAAC,IAAI,CAAChB,OAAO,CAAC;IACzD,MAAMiB,QAAQ,GAAGF,SAAS,CAACG,UAAU,CAACC,IAAI,CACvCC,GAAG,IAAKA,GAAG,CAACC,gBAAgB,KAAKP,KAAK,CACxC;IAED;IACA,IAAI,CAACG,QAAQ,EAAE;MACb,MAAM,IAAIK,KAAK,CAAC,qBAAqBR,KAAK,EAAE,CAAC;;IAG/C,IACE,CAAC,IAAI,CAACF,gBAAgB,CAACW,QAAQ,IAC/B,CAAC,IAAI,CAACX,gBAAgB,CAACW,QAAQ,CAACC,IAAI,CAACpB,OAAO,EAC5C;MACA,OAAO,IAAIqB,iBAAU,CAACR,QAAQ,EAAE,IAAIQ,UAAG,CAAC,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC,KAAK,CAAC;;IAG1D,OAAO,IAAID,iBAAU,CACnBR,QAAQ,EACR,IAAIQ,UAAG,CAAC,IAAI,CAACb,gBAAgB,CAACW,QAAQ,CAACC,IAAI,CAACpB,OAAO,CAAC,CACrD;EACH;;AA7BAuB,YADChB,eAAQ,4DAGR;AAGDgB,YADChB,eAAQ,8DAyBR;AAjEHJ;AAoEA,MAAaqB,kCAAkC;EAC7C9B,YAA+BC,OAAgB;IAAhB,YAAO,GAAPA,OAAO;EAAY;EAElD8B,eAAe,CACb7B,OAAe,EACfC,WAAwB,EACxBE,aAAqB,EACrB2B,YAAoB;IAEpB,MAAMpB,WAAW,GAAG,IAAIqB,oBAAW,CAACD,YAAY,CAAC;IACjD,IAAIpB,WAAW,CAACsB,IAAI,KAAK,MAAM,EAAE;MAC/B,OAAO,IAAIxB,+BAA+B,CACxC,IAAI,CAACT,OAAO,EACZC,OAAO,EACPC,WAAW,EACXS,WAAW,EACXP,aAAa,CACd;;EAEL;;AAnBFI","names":["ObservableQueryCw20Balance","contract_query_1","constructor","kvStore","chainId","chainGetter","contractAddress","bech32Address","balance","address","canFetch","exports","ObservableQueryCw20BalanceInner","balances_1","denomHelper","mobx_1","queryCw20Balance","fetch","denom","chainInfo","getChain","currency","currencies","find","cur","coinMinimalDenom","Error","response","data","unit_1","ready","__decorate","ObservableQueryCw20BalanceRegistry","getBalanceInner","minimalDenom","common_1","type"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/query/cosmwasm/cw20-balance.ts"],"sourcesContent":["import { computed, makeObservable, override } from \"mobx\";\nimport { DenomHelper, KVStore } from \"@keplr-wallet/common\";\nimport { ChainGetter } from \"../../common\";\nimport { CoinPretty, Int } from \"@keplr-wallet/unit\";\nimport { BalanceRegistry, ObservableQueryBalanceInner } from \"../balances\";\nimport { Cw20ContractBalance } from \"./types\";\nimport { ObservableCosmwasmContractChainQuery } from \"./contract-query\";\n\nexport class ObservableQueryCw20Balance extends ObservableCosmwasmContractChainQuery<Cw20ContractBalance> {\n  constructor(\n    kvStore: KVStore,\n    chainId: string,\n    chainGetter: ChainGetter,\n    protected readonly contractAddress: string,\n    protected readonly bech32Address: string\n  ) {\n    super(kvStore, chainId, chainGetter, contractAddress, {\n      balance: { address: bech32Address },\n    });\n  }\n\n  protected canFetch(): boolean {\n    return super.canFetch() && this.bech32Address !== \"\";\n  }\n}\n\nexport class ObservableQueryCw20BalanceInner extends ObservableQueryBalanceInner {\n  protected readonly queryCw20Balance: ObservableQueryCw20Balance;\n\n  constructor(\n    kvStore: KVStore,\n    chainId: string,\n    chainGetter: ChainGetter,\n    denomHelper: DenomHelper,\n    protected readonly bech32Address: string\n  ) {\n    super(\n      kvStore,\n      chainId,\n      chainGetter,\n      // No need to set the url at initial.\n      \"\",\n      denomHelper\n    );\n\n    makeObservable(this);\n\n    this.queryCw20Balance = new ObservableQueryCw20Balance(\n      kvStore,\n      chainId,\n      chainGetter,\n      denomHelper.contractAddress,\n      bech32Address\n    );\n  }\n\n  // This method doesn't have the role because the fetching is actually exeucnted in the `ObservableQueryCw20Balance`.\n  protected canFetch(): boolean {\n    return false;\n  }\n\n  @override\n  *fetch() {\n    yield this.queryCw20Balance.fetch();\n  }\n\n  @computed\n  get balance(): CoinPretty {\n    const denom = this.denomHelper.denom;\n\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    const currency = chainInfo.currencies.find(\n      (cur) => cur.coinMinimalDenom === denom\n    );\n\n    // TODO: Infer the currency according to its denom (such if denom is `uatom` -> `Atom` with decimal 6)?\n    if (!currency) {\n      throw new Error(`Unknown currency: ${denom}`);\n    }\n\n    if (\n      !this.queryCw20Balance.response ||\n      !this.queryCw20Balance.response.data.balance\n    ) {\n      return new CoinPretty(currency, new Int(0)).ready(false);\n    }\n\n    return new CoinPretty(\n      currency,\n      new Int(this.queryCw20Balance.response.data.balance)\n    );\n  }\n}\n\nexport class ObservableQueryCw20BalanceRegistry implements BalanceRegistry {\n  constructor(protected readonly kvStore: KVStore) {}\n\n  getBalanceInner(\n    chainId: string,\n    chainGetter: ChainGetter,\n    bech32Address: string,\n    minimalDenom: string\n  ): ObservableQueryBalanceInner | undefined {\n    const denomHelper = new DenomHelper(minimalDenom);\n    if (denomHelper.type === \"cw20\") {\n      return new ObservableQueryCw20BalanceInner(\n        this.kvStore,\n        chainId,\n        chainGetter,\n        denomHelper,\n        bech32Address\n      );\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}