{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SignDocWrapper = void 0;\nconst decoder_1 = require(\"../decoder\");\nconst tx_1 = require(\"@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx\");\nconst adr_36_1 = require(\"../../adr-36\");\nclass SignDocWrapper {\n  constructor(signDoc) {\n    this.signDoc = signDoc;\n    if (\"msgs\" in signDoc) {\n      this.mode = \"amino\";\n    } else {\n      this.mode = \"direct\";\n    }\n    if (this.mode === \"amino\") {\n      // Check that the sign doc is for ADR-36.\n      // The validation should be performed on the background process.\n      // So, here, we check once more, but the validation related to bech32 is considered to be done in the background process.\n      this.isADR36SignDoc = adr_36_1.checkAndValidateADR36AminoSignDoc(this.aminoSignDoc);\n    } else {\n      // Currently, only support amino sign doc for ADR-36\n      this.isADR36SignDoc = false;\n    }\n  }\n  static fromAminoSignDoc(signDoc) {\n    return new SignDocWrapper(signDoc);\n  }\n  static fromDirectSignDoc(signDoc) {\n    return new SignDocWrapper(signDoc);\n  }\n  static fromDirectSignDocBytes(signDocBytes) {\n    return new SignDocWrapper(tx_1.SignDoc.decode(signDocBytes));\n  }\n  clone() {\n    return new SignDocWrapper(this.signDoc);\n  }\n  get protoSignDoc() {\n    if (this.mode === \"amino\") {\n      throw new Error(\"Sign doc is encoded as Amino Json\");\n    }\n    if (\"msgs\" in this.signDoc) {\n      throw new Error(\"Unexpected error\");\n    }\n    if (!this._protoSignDoc) {\n      this._protoSignDoc = new decoder_1.ProtoSignDocDecoder(this.signDoc);\n    }\n    return this._protoSignDoc;\n  }\n  get aminoSignDoc() {\n    if (this.mode === \"direct\") {\n      throw new Error(\"Sign doc is encoded as Protobuf\");\n    }\n    if (!(\"msgs\" in this.signDoc)) {\n      throw new Error(\"Unexpected error\");\n    }\n    return this.signDoc;\n  }\n  get chainId() {\n    if (this.mode === \"direct\") {\n      return this.protoSignDoc.chainId;\n    }\n    return this.aminoSignDoc.chain_id;\n  }\n  get memo() {\n    if (this.mode === \"direct\") {\n      return this.protoSignDoc.txBody.memo;\n    }\n    return this.aminoSignDoc.memo;\n  }\n  get fees() {\n    var _a, _b;\n    if (this.mode === \"direct\") {\n      const fees = [];\n      for (const coinObj of (_b = (_a = this.protoSignDoc.authInfo.fee) === null || _a === void 0 ? void 0 : _a.amount) !== null && _b !== void 0 ? _b : []) {\n        if (coinObj.denom == null || coinObj.amount == null) {\n          throw new Error(\"Invalid fee\");\n        }\n        fees.push({\n          denom: coinObj.denom,\n          amount: coinObj.amount\n        });\n      }\n      return fees;\n    }\n    return this.aminoSignDoc.fee.amount;\n  }\n  get gas() {\n    var _a;\n    if (this.mode === \"direct\") {\n      if ((_a = this.protoSignDoc.authInfo.fee) === null || _a === void 0 ? void 0 : _a.gasLimit) {\n        return parseInt(this.protoSignDoc.authInfo.fee.gasLimit);\n      } else {\n        return 0;\n      }\n    }\n    return parseInt(this.aminoSignDoc.fee.gas);\n  }\n}\nexports.SignDocWrapper = SignDocWrapper;","map":{"version":3,"mappings":"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","names":["SignDocWrapper","constructor","signDoc","mode","isADR36SignDoc","adr_36_1","aminoSignDoc","fromAminoSignDoc","fromDirectSignDoc","fromDirectSignDocBytes","signDocBytes","tx_1","decode","clone","protoSignDoc","Error","_protoSignDoc","decoder_1","chainId","chain_id","memo","txBody","fees","coinObj","authInfo","fee","amount","denom","push","gas","gasLimit","parseInt","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/node_modules/@keplr-wallet/cosmos/src/stargate/wrapper/index.ts"],"sourcesContent":["import { ProtoSignDocDecoder } from \"../decoder\";\nimport { Coin, StdSignDoc } from \"@cosmjs/launchpad\";\nimport { SignDoc } from \"@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx\";\nimport { checkAndValidateADR36AminoSignDoc } from \"../../adr-36\";\n\nexport class SignDocWrapper {\n  protected _protoSignDoc?: ProtoSignDocDecoder;\n\n  public readonly isADR36SignDoc: boolean;\n\n  public readonly mode: \"amino\" | \"direct\";\n\n  constructor(protected readonly signDoc: StdSignDoc | SignDoc) {\n    if (\"msgs\" in signDoc) {\n      this.mode = \"amino\";\n    } else {\n      this.mode = \"direct\";\n    }\n\n    if (this.mode === \"amino\") {\n      // Check that the sign doc is for ADR-36.\n      // The validation should be performed on the background process.\n      // So, here, we check once more, but the validation related to bech32 is considered to be done in the background process.\n      this.isADR36SignDoc = checkAndValidateADR36AminoSignDoc(\n        this.aminoSignDoc\n      );\n    } else {\n      // Currently, only support amino sign doc for ADR-36\n      this.isADR36SignDoc = false;\n    }\n  }\n\n  static fromAminoSignDoc(signDoc: StdSignDoc) {\n    return new SignDocWrapper(signDoc);\n  }\n\n  static fromDirectSignDoc(signDoc: SignDoc) {\n    return new SignDocWrapper(signDoc);\n  }\n\n  static fromDirectSignDocBytes(signDocBytes: Uint8Array) {\n    return new SignDocWrapper(SignDoc.decode(signDocBytes));\n  }\n\n  clone(): SignDocWrapper {\n    return new SignDocWrapper(this.signDoc);\n  }\n\n  get protoSignDoc(): ProtoSignDocDecoder {\n    if (this.mode === \"amino\") {\n      throw new Error(\"Sign doc is encoded as Amino Json\");\n    }\n    if (\"msgs\" in this.signDoc) {\n      throw new Error(\"Unexpected error\");\n    }\n\n    if (!this._protoSignDoc) {\n      this._protoSignDoc = new ProtoSignDocDecoder(this.signDoc);\n    }\n\n    return this._protoSignDoc;\n  }\n\n  get aminoSignDoc(): StdSignDoc {\n    if (this.mode === \"direct\") {\n      throw new Error(\"Sign doc is encoded as Protobuf\");\n    }\n    if (!(\"msgs\" in this.signDoc)) {\n      throw new Error(\"Unexpected error\");\n    }\n\n    return this.signDoc;\n  }\n\n  get chainId(): string {\n    if (this.mode === \"direct\") {\n      return this.protoSignDoc.chainId;\n    }\n\n    return this.aminoSignDoc.chain_id;\n  }\n\n  get memo(): string {\n    if (this.mode === \"direct\") {\n      return this.protoSignDoc.txBody.memo;\n    }\n\n    return this.aminoSignDoc.memo;\n  }\n\n  get fees(): readonly Coin[] {\n    if (this.mode === \"direct\") {\n      const fees: Coin[] = [];\n      for (const coinObj of this.protoSignDoc.authInfo.fee?.amount ?? []) {\n        if (coinObj.denom == null || coinObj.amount == null) {\n          throw new Error(\"Invalid fee\");\n        }\n        fees.push({\n          denom: coinObj.denom,\n          amount: coinObj.amount,\n        });\n      }\n\n      return fees;\n    }\n\n    return this.aminoSignDoc.fee.amount;\n  }\n\n  get gas(): number {\n    if (this.mode === \"direct\") {\n      if (this.protoSignDoc.authInfo.fee?.gasLimit) {\n        return parseInt(this.protoSignDoc.authInfo.fee.gasLimit);\n      } else {\n        return 0;\n      }\n    }\n\n    return parseInt(this.aminoSignDoc.fee.gas);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}