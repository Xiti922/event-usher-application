{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst crypto = require(\"./crypto\");\nconst bs58check = require('bs58check');\nconst ecc = require('tiny-secp256k1');\nconst typeforce = require('typeforce');\nconst wif = require('wif');\nconst UINT256_TYPE = typeforce.BufferN(32);\nconst NETWORK_TYPE = typeforce.compile({\n  wif: typeforce.UInt8,\n  bip32: {\n    public: typeforce.UInt32,\n    private: typeforce.UInt32\n  }\n});\nconst BITCOIN = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bc',\n  bip32: {\n    public: 0x0488b21e,\n    private: 0x0488ade4\n  },\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  wif: 0x80\n};\nconst HIGHEST_BIT = 0x80000000;\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction BIP32Path(value) {\n  return typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/) !== null;\n}\nfunction UInt31(value) {\n  return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nclass BIP32 {\n  constructor(__D, __Q, chainCode, network) {\n    let __DEPTH = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let __INDEX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    let __PARENT_FINGERPRINT = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0x00000000;\n    this.__D = __D;\n    this.__Q = __Q;\n    this.chainCode = chainCode;\n    this.network = network;\n    this.__DEPTH = __DEPTH;\n    this.__INDEX = __INDEX;\n    this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;\n    typeforce(NETWORK_TYPE, network);\n    this.lowR = false;\n  }\n  get depth() {\n    return this.__DEPTH;\n  }\n  get index() {\n    return this.__INDEX;\n  }\n  get parentFingerprint() {\n    return this.__PARENT_FINGERPRINT;\n  }\n  get publicKey() {\n    if (this.__Q === undefined) this.__Q = ecc.pointFromScalar(this.__D, true);\n    return this.__Q;\n  }\n  get privateKey() {\n    return this.__D;\n  }\n  get identifier() {\n    return crypto.hash160(this.publicKey);\n  }\n  get fingerprint() {\n    return this.identifier.slice(0, 4);\n  }\n  get compressed() {\n    return true;\n  }\n  // Private === not neutered\n  // Public === neutered\n  isNeutered() {\n    return this.__D === undefined;\n  }\n  neutered() {\n    return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);\n  }\n  toBase58() {\n    const network = this.network;\n    const version = !this.isNeutered() ? network.bip32.private : network.bip32.public;\n    const buffer = Buffer.allocUnsafe(78);\n    // 4 bytes: version bytes\n    buffer.writeUInt32BE(version, 0);\n    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n    buffer.writeUInt8(this.depth, 4);\n    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n    buffer.writeUInt32BE(this.parentFingerprint, 5);\n    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n    // This is encoded in big endian. (0x00000000 if master key)\n    buffer.writeUInt32BE(this.index, 9);\n    // 32 bytes: the chain code\n    this.chainCode.copy(buffer, 13);\n    // 33 bytes: the public key or private key data\n    if (!this.isNeutered()) {\n      // 0x00 + k for private keys\n      buffer.writeUInt8(0, 45);\n      this.privateKey.copy(buffer, 46);\n      // 33 bytes: the public key\n    } else {\n      // X9.62 encoding for public keys\n      this.publicKey.copy(buffer, 45);\n    }\n    return bs58check.encode(buffer);\n  }\n  toWIF() {\n    if (!this.privateKey) throw new TypeError('Missing private key');\n    return wif.encode(this.network.wif, this.privateKey, true);\n  }\n  // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n  derive(index) {\n    typeforce(typeforce.UInt32, index);\n    const isHardened = index >= HIGHEST_BIT;\n    const data = Buffer.allocUnsafe(37);\n    // Hardened child\n    if (isHardened) {\n      if (this.isNeutered()) throw new TypeError('Missing private key for hardened child key');\n      // data = 0x00 || ser256(kpar) || ser32(index)\n      data[0] = 0x00;\n      this.privateKey.copy(data, 1);\n      data.writeUInt32BE(index, 33);\n      // Normal child\n    } else {\n      // data = serP(point(kpar)) || ser32(index)\n      //      = serP(Kpar) || ser32(index)\n      this.publicKey.copy(data, 0);\n      data.writeUInt32BE(index, 33);\n    }\n    const I = crypto.hmacSHA512(this.chainCode, data);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    // if parse256(IL) >= n, proceed with the next value for i\n    if (!ecc.isPrivate(IL)) return this.derive(index + 1);\n    // Private parent key -> private child key\n    let hd;\n    if (!this.isNeutered()) {\n      // ki = parse256(IL) + kpar (mod n)\n      const ki = ecc.privateAdd(this.privateKey, IL);\n      // In case ki == 0, proceed with the next value for i\n      if (ki == null) return this.derive(index + 1);\n      hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n      // Public parent key -> public child key\n    } else {\n      // Ki = point(parse256(IL)) + Kpar\n      //    = G*IL + Kpar\n      const Ki = ecc.pointAddScalar(this.publicKey, IL, true);\n      // In case Ki is the point at infinity, proceed with the next value for i\n      if (Ki === null) return this.derive(index + 1);\n      hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n    }\n    return hd;\n  }\n  deriveHardened(index) {\n    typeforce(UInt31, index);\n    // Only derives hardened private keys by default\n    return this.derive(index + HIGHEST_BIT);\n  }\n  derivePath(path) {\n    typeforce(BIP32Path, path);\n    let splitPath = path.split('/');\n    if (splitPath[0] === 'm') {\n      if (this.parentFingerprint) throw new TypeError('Expected master, got child');\n      splitPath = splitPath.slice(1);\n    }\n    return splitPath.reduce((prevHd, indexStr) => {\n      let index;\n      if (indexStr.slice(-1) === `'`) {\n        index = parseInt(indexStr.slice(0, -1), 10);\n        return prevHd.deriveHardened(index);\n      } else {\n        index = parseInt(indexStr, 10);\n        return prevHd.derive(index);\n      }\n    }, this);\n  }\n  sign(hash, lowR) {\n    if (!this.privateKey) throw new Error('Missing private key');\n    if (lowR === undefined) lowR = this.lowR;\n    if (lowR === false) {\n      return ecc.sign(hash, this.privateKey);\n    } else {\n      let sig = ecc.sign(hash, this.privateKey);\n      const extraData = Buffer.alloc(32, 0);\n      let counter = 0;\n      // if first try is lowR, skip the loop\n      // for second try and on, add extra entropy counting up\n      while (sig[0] > 0x7f) {\n        counter++;\n        extraData.writeUIntLE(counter, 0, 6);\n        sig = ecc.signWithEntropy(hash, this.privateKey, extraData);\n      }\n      return sig;\n    }\n  }\n  verify(hash, signature) {\n    return ecc.verify(hash, this.publicKey, signature);\n  }\n}\nfunction fromBase58(inString, network) {\n  const buffer = bs58check.decode(inString);\n  if (buffer.length !== 78) throw new TypeError('Invalid buffer length');\n  network = network || BITCOIN;\n  // 4 bytes: version bytes\n  const version = buffer.readUInt32BE(0);\n  if (version !== network.bip32.private && version !== network.bip32.public) throw new TypeError('Invalid network version');\n  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n  const depth = buffer[4];\n  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n  const parentFingerprint = buffer.readUInt32BE(5);\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new TypeError('Invalid parent fingerprint');\n  }\n  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n  const index = buffer.readUInt32BE(9);\n  if (depth === 0 && index !== 0) throw new TypeError('Invalid index');\n  // 32 bytes: the chain code\n  const chainCode = buffer.slice(13, 45);\n  let hd;\n  // 33 bytes: private key data (0x00 + k)\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new TypeError('Invalid private key');\n    const k = buffer.slice(46, 78);\n    hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);\n    // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    const X = buffer.slice(45, 78);\n    hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);\n  }\n  return hd;\n}\nexports.fromBase58 = fromBase58;\nfunction fromPrivateKey(privateKey, chainCode, network) {\n  return fromPrivateKeyLocal(privateKey, chainCode, network);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {\n  typeforce({\n    privateKey: UINT256_TYPE,\n    chainCode: UINT256_TYPE\n  }, {\n    privateKey,\n    chainCode\n  });\n  network = network || BITCOIN;\n  if (!ecc.isPrivate(privateKey)) throw new TypeError('Private key not in range [1, n)');\n  return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromPublicKey(publicKey, chainCode, network) {\n  return fromPublicKeyLocal(publicKey, chainCode, network);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {\n  typeforce({\n    publicKey: typeforce.BufferN(33),\n    chainCode: UINT256_TYPE\n  }, {\n    publicKey,\n    chainCode\n  });\n  network = network || BITCOIN;\n  // verify the X coordinate is a point on the curve\n  if (!ecc.isPoint(publicKey)) throw new TypeError('Point is not on the curve');\n  return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromSeed(seed, network) {\n  typeforce(typeforce.Buffer, seed);\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits');\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits');\n  network = network || BITCOIN;\n  const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return fromPrivateKey(IL, IR, network);\n}\nexports.fromSeed = fromSeed;","map":{"version":3,"names":["Object","defineProperty","exports","value","crypto","require","bs58check","ecc","typeforce","wif","UINT256_TYPE","BufferN","NETWORK_TYPE","compile","UInt8","bip32","public","UInt32","private","BITCOIN","messagePrefix","bech32","pubKeyHash","scriptHash","HIGHEST_BIT","UINT31_MAX","Math","pow","BIP32Path","String","match","UInt31","BIP32","constructor","__D","__Q","chainCode","network","__DEPTH","__INDEX","__PARENT_FINGERPRINT","lowR","depth","index","parentFingerprint","publicKey","undefined","pointFromScalar","privateKey","identifier","hash160","fingerprint","slice","compressed","isNeutered","neutered","fromPublicKeyLocal","toBase58","version","buffer","Buffer","allocUnsafe","writeUInt32BE","writeUInt8","copy","encode","toWIF","TypeError","derive","isHardened","data","I","hmacSHA512","IL","IR","isPrivate","hd","ki","privateAdd","fromPrivateKeyLocal","readUInt32BE","Ki","pointAddScalar","deriveHardened","derivePath","path","splitPath","split","reduce","prevHd","indexStr","parseInt","sign","hash","Error","sig","extraData","alloc","counter","writeUIntLE","signWithEntropy","verify","signature","fromBase58","inString","decode","length","readUInt8","k","X","fromPrivateKey","fromPublicKey","isPoint","fromSeed","seed","from"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/bip32/src/bip32.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto = require(\"./crypto\");\nconst bs58check = require('bs58check');\nconst ecc = require('tiny-secp256k1');\nconst typeforce = require('typeforce');\nconst wif = require('wif');\nconst UINT256_TYPE = typeforce.BufferN(32);\nconst NETWORK_TYPE = typeforce.compile({\n    wif: typeforce.UInt8,\n    bip32: {\n        public: typeforce.UInt32,\n        private: typeforce.UInt32,\n    },\n});\nconst BITCOIN = {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'bc',\n    bip32: {\n        public: 0x0488b21e,\n        private: 0x0488ade4,\n    },\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n};\nconst HIGHEST_BIT = 0x80000000;\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction BIP32Path(value) {\n    return (typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/) !== null);\n}\nfunction UInt31(value) {\n    return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nclass BIP32 {\n    constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {\n        this.__D = __D;\n        this.__Q = __Q;\n        this.chainCode = chainCode;\n        this.network = network;\n        this.__DEPTH = __DEPTH;\n        this.__INDEX = __INDEX;\n        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;\n        typeforce(NETWORK_TYPE, network);\n        this.lowR = false;\n    }\n    get depth() {\n        return this.__DEPTH;\n    }\n    get index() {\n        return this.__INDEX;\n    }\n    get parentFingerprint() {\n        return this.__PARENT_FINGERPRINT;\n    }\n    get publicKey() {\n        if (this.__Q === undefined)\n            this.__Q = ecc.pointFromScalar(this.__D, true);\n        return this.__Q;\n    }\n    get privateKey() {\n        return this.__D;\n    }\n    get identifier() {\n        return crypto.hash160(this.publicKey);\n    }\n    get fingerprint() {\n        return this.identifier.slice(0, 4);\n    }\n    get compressed() {\n        return true;\n    }\n    // Private === not neutered\n    // Public === neutered\n    isNeutered() {\n        return this.__D === undefined;\n    }\n    neutered() {\n        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);\n    }\n    toBase58() {\n        const network = this.network;\n        const version = !this.isNeutered()\n            ? network.bip32.private\n            : network.bip32.public;\n        const buffer = Buffer.allocUnsafe(78);\n        // 4 bytes: version bytes\n        buffer.writeUInt32BE(version, 0);\n        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n        buffer.writeUInt8(this.depth, 4);\n        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n        buffer.writeUInt32BE(this.parentFingerprint, 5);\n        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n        // This is encoded in big endian. (0x00000000 if master key)\n        buffer.writeUInt32BE(this.index, 9);\n        // 32 bytes: the chain code\n        this.chainCode.copy(buffer, 13);\n        // 33 bytes: the public key or private key data\n        if (!this.isNeutered()) {\n            // 0x00 + k for private keys\n            buffer.writeUInt8(0, 45);\n            this.privateKey.copy(buffer, 46);\n            // 33 bytes: the public key\n        }\n        else {\n            // X9.62 encoding for public keys\n            this.publicKey.copy(buffer, 45);\n        }\n        return bs58check.encode(buffer);\n    }\n    toWIF() {\n        if (!this.privateKey)\n            throw new TypeError('Missing private key');\n        return wif.encode(this.network.wif, this.privateKey, true);\n    }\n    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n    derive(index) {\n        typeforce(typeforce.UInt32, index);\n        const isHardened = index >= HIGHEST_BIT;\n        const data = Buffer.allocUnsafe(37);\n        // Hardened child\n        if (isHardened) {\n            if (this.isNeutered())\n                throw new TypeError('Missing private key for hardened child key');\n            // data = 0x00 || ser256(kpar) || ser32(index)\n            data[0] = 0x00;\n            this.privateKey.copy(data, 1);\n            data.writeUInt32BE(index, 33);\n            // Normal child\n        }\n        else {\n            // data = serP(point(kpar)) || ser32(index)\n            //      = serP(Kpar) || ser32(index)\n            this.publicKey.copy(data, 0);\n            data.writeUInt32BE(index, 33);\n        }\n        const I = crypto.hmacSHA512(this.chainCode, data);\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n        // if parse256(IL) >= n, proceed with the next value for i\n        if (!ecc.isPrivate(IL))\n            return this.derive(index + 1);\n        // Private parent key -> private child key\n        let hd;\n        if (!this.isNeutered()) {\n            // ki = parse256(IL) + kpar (mod n)\n            const ki = ecc.privateAdd(this.privateKey, IL);\n            // In case ki == 0, proceed with the next value for i\n            if (ki == null)\n                return this.derive(index + 1);\n            hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n            // Public parent key -> public child key\n        }\n        else {\n            // Ki = point(parse256(IL)) + Kpar\n            //    = G*IL + Kpar\n            const Ki = ecc.pointAddScalar(this.publicKey, IL, true);\n            // In case Ki is the point at infinity, proceed with the next value for i\n            if (Ki === null)\n                return this.derive(index + 1);\n            hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n        }\n        return hd;\n    }\n    deriveHardened(index) {\n        typeforce(UInt31, index);\n        // Only derives hardened private keys by default\n        return this.derive(index + HIGHEST_BIT);\n    }\n    derivePath(path) {\n        typeforce(BIP32Path, path);\n        let splitPath = path.split('/');\n        if (splitPath[0] === 'm') {\n            if (this.parentFingerprint)\n                throw new TypeError('Expected master, got child');\n            splitPath = splitPath.slice(1);\n        }\n        return splitPath.reduce((prevHd, indexStr) => {\n            let index;\n            if (indexStr.slice(-1) === `'`) {\n                index = parseInt(indexStr.slice(0, -1), 10);\n                return prevHd.deriveHardened(index);\n            }\n            else {\n                index = parseInt(indexStr, 10);\n                return prevHd.derive(index);\n            }\n        }, this);\n    }\n    sign(hash, lowR) {\n        if (!this.privateKey)\n            throw new Error('Missing private key');\n        if (lowR === undefined)\n            lowR = this.lowR;\n        if (lowR === false) {\n            return ecc.sign(hash, this.privateKey);\n        }\n        else {\n            let sig = ecc.sign(hash, this.privateKey);\n            const extraData = Buffer.alloc(32, 0);\n            let counter = 0;\n            // if first try is lowR, skip the loop\n            // for second try and on, add extra entropy counting up\n            while (sig[0] > 0x7f) {\n                counter++;\n                extraData.writeUIntLE(counter, 0, 6);\n                sig = ecc.signWithEntropy(hash, this.privateKey, extraData);\n            }\n            return sig;\n        }\n    }\n    verify(hash, signature) {\n        return ecc.verify(hash, this.publicKey, signature);\n    }\n}\nfunction fromBase58(inString, network) {\n    const buffer = bs58check.decode(inString);\n    if (buffer.length !== 78)\n        throw new TypeError('Invalid buffer length');\n    network = network || BITCOIN;\n    // 4 bytes: version bytes\n    const version = buffer.readUInt32BE(0);\n    if (version !== network.bip32.private && version !== network.bip32.public)\n        throw new TypeError('Invalid network version');\n    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n    const depth = buffer[4];\n    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n    const parentFingerprint = buffer.readUInt32BE(5);\n    if (depth === 0) {\n        if (parentFingerprint !== 0x00000000)\n            throw new TypeError('Invalid parent fingerprint');\n    }\n    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n    // This is encoded in MSB order. (0x00000000 if master key)\n    const index = buffer.readUInt32BE(9);\n    if (depth === 0 && index !== 0)\n        throw new TypeError('Invalid index');\n    // 32 bytes: the chain code\n    const chainCode = buffer.slice(13, 45);\n    let hd;\n    // 33 bytes: private key data (0x00 + k)\n    if (version === network.bip32.private) {\n        if (buffer.readUInt8(45) !== 0x00)\n            throw new TypeError('Invalid private key');\n        const k = buffer.slice(46, 78);\n        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);\n        // 33 bytes: public key data (0x02 + X or 0x03 + X)\n    }\n    else {\n        const X = buffer.slice(45, 78);\n        hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);\n    }\n    return hd;\n}\nexports.fromBase58 = fromBase58;\nfunction fromPrivateKey(privateKey, chainCode, network) {\n    return fromPrivateKeyLocal(privateKey, chainCode, network);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        privateKey: UINT256_TYPE,\n        chainCode: UINT256_TYPE,\n    }, { privateKey, chainCode });\n    network = network || BITCOIN;\n    if (!ecc.isPrivate(privateKey))\n        throw new TypeError('Private key not in range [1, n)');\n    return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromPublicKey(publicKey, chainCode, network) {\n    return fromPublicKeyLocal(publicKey, chainCode, network);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        publicKey: typeforce.BufferN(33),\n        chainCode: UINT256_TYPE,\n    }, { publicKey, chainCode });\n    network = network || BITCOIN;\n    // verify the X coordinate is a point on the curve\n    if (!ecc.isPoint(publicKey))\n        throw new TypeError('Point is not on the curve');\n    return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromSeed(seed, network) {\n    typeforce(typeforce.Buffer, seed);\n    if (seed.length < 16)\n        throw new TypeError('Seed should be at least 128 bits');\n    if (seed.length > 64)\n        throw new TypeError('Seed should be at most 512 bits');\n    network = network || BITCOIN;\n    const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return fromPrivateKey(IL, IR, network);\n}\nexports.fromSeed = fromSeed;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}