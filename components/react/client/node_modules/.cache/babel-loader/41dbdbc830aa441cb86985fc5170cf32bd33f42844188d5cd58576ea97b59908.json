{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CosmwasmAccountImpl = exports.defaultCosmwasmMsgOpts = exports.CosmwasmAccount = void 0;\nconst common_1 = require(\"@keplr-wallet/common\");\nconst unit_1 = require(\"@keplr-wallet/unit\");\nconst tx_1 = require(\"@keplr-wallet/proto-types/cosmwasm/wasm/v1/tx\");\nconst buffer_1 = require(\"buffer/\");\nconst deepmerge_1 = __importDefault(require(\"deepmerge\"));\nconst utils_1 = require(\"./utils\");\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nexports.CosmwasmAccount = {\n  use(options) {\n    return (base, chainGetter, chainId) => {\n      const msgOptsFromCreator = options.msgOptsCreator ? options.msgOptsCreator(chainId) : undefined;\n      return {\n        cosmwasm: new CosmwasmAccountImpl(base, chainGetter, chainId, options.queriesStore, deepmerge_1.default(exports.defaultCosmwasmMsgOpts, msgOptsFromCreator ? msgOptsFromCreator : {}))\n      };\n    };\n  }\n};\n/**\n * @deprecated Predict gas through simulation rather than using a fixed gas.\n */\nexports.defaultCosmwasmMsgOpts = {\n  send: {\n    cw20: {\n      gas: 150000\n    }\n  },\n  executeWasm: {\n    type: \"wasm/MsgExecuteContract\"\n  }\n};\nclass CosmwasmAccountImpl {\n  constructor(base, chainGetter, chainId, queriesStore, _msgOpts) {\n    this.base = base;\n    this.chainGetter = chainGetter;\n    this.chainId = chainId;\n    this.queriesStore = queriesStore;\n    this._msgOpts = _msgOpts;\n    this.base.registerMakeSendTokenFn(this.processMakeSendTokenTx.bind(this));\n    this.base.registerSendTokenFn(this.processSendToken.bind(this));\n  }\n  /**\n   * @deprecated Predict gas through simulation rather than using a fixed gas.\n   */\n  get msgOpts() {\n    return this._msgOpts;\n  }\n  processMakeSendTokenTx(amount, currency, recipient) {\n    const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);\n    if (denomHelper.type === \"cw20\") {\n      const actualAmount = (() => {\n        let dec = new unit_1.Dec(amount);\n        dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n        return dec.truncate().toString();\n      })();\n      if (!(\"type\" in currency) || currency.type !== \"cw20\") {\n        throw new Error(\"Currency is not cw20\");\n      }\n      cosmos_1.Bech32Address.validate(recipient, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr);\n      return this.makeExecuteContractTx(\"send\", currency.contractAddress, {\n        transfer: {\n          recipient: recipient,\n          amount: actualAmount\n        }\n      }, [], tx => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to send token, refresh the balance.\n          const queryBalance = this.queries.queryBalances.getQueryBech32Address(this.base.bech32Address).balances.find(bal => {\n            return bal.currency.coinMinimalDenom === currency.coinMinimalDenom;\n          });\n          if (queryBalance) {\n            queryBalance.fetch();\n          }\n        }\n      });\n    }\n  }\n  /**\n   * @deprecated\n   */\n  processSendToken(amount, currency, recipient, memo, stdFee, signOptions, onTxEvents) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);\n      switch (denomHelper.type) {\n        case \"cw20\":\n          const actualAmount = (() => {\n            let dec = new unit_1.Dec(amount);\n            dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n            return dec.truncate().toString();\n          })();\n          if (!(\"type\" in currency) || currency.type !== \"cw20\") {\n            throw new Error(\"Currency is not cw20\");\n          }\n          yield this.sendExecuteContractMsg(\"send\", currency.contractAddress, {\n            transfer: {\n              recipient: recipient,\n              amount: actualAmount\n            }\n          }, [], memo, {\n            amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],\n            gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.send.cw20.gas.toString()\n          }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, tx => {\n            if (tx.code == null || tx.code === 0) {\n              // After succeeding to send token, refresh the balance.\n              const queryBalance = this.queries.queryBalances.getQueryBech32Address(this.base.bech32Address).balances.find(bal => {\n                return bal.currency.coinMinimalDenom === currency.coinMinimalDenom;\n              });\n              if (queryBalance) {\n                queryBalance.fetch();\n              }\n            }\n          }));\n          return true;\n      }\n      return false;\n    });\n  }\n  makeExecuteContractTx() {\n    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"executeWasm\";\n    let contractAddress = arguments.length > 1 ? arguments[1] : undefined;\n    let\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    obj = arguments.length > 2 ? arguments[2] : undefined;\n    let funds = arguments.length > 3 ? arguments[3] : undefined;\n    let preOnTxEvents = arguments.length > 4 ? arguments[4] : undefined;\n    cosmos_1.Bech32Address.validate(contractAddress, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr);\n    const msg = {\n      type: this.msgOpts.executeWasm.type,\n      value: {\n        sender: this.base.bech32Address,\n        contract: contractAddress,\n        msg: obj,\n        funds\n      }\n    };\n    return this.base.cosmos.makeTx(type, {\n      aminoMsgs: [msg],\n      protoMsgs: [{\n        typeUrl: \"/cosmwasm.wasm.v1.MsgExecuteContract\",\n        value: tx_1.MsgExecuteContract.encode({\n          sender: msg.value.sender,\n          contract: msg.value.contract,\n          msg: buffer_1.Buffer.from(JSON.stringify(msg.value.msg)),\n          funds: msg.value.funds\n        }).finish()\n      }]\n    }, preOnTxEvents);\n  }\n  /**\n   * @deprecated\n   */\n  sendExecuteContractMsg() {\n    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"executeWasm\";\n    let contractAddress = arguments.length > 1 ? arguments[1] : undefined;\n    let\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    obj = arguments.length > 2 ? arguments[2] : undefined;\n    let funds = arguments.length > 3 ? arguments[3] : undefined;\n    let memo = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    let stdFee = arguments.length > 5 ? arguments[5] : undefined;\n    let signOptions = arguments.length > 6 ? arguments[6] : undefined;\n    let onTxEvents = arguments.length > 7 ? arguments[7] : undefined;\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = {\n        type: this.msgOpts.executeWasm.type,\n        value: {\n          sender: this.base.bech32Address,\n          contract: contractAddress,\n          msg: obj,\n          funds\n        }\n      };\n      yield this.base.cosmos.sendMsgs(type, {\n        aminoMsgs: [msg],\n        protoMsgs: [{\n          typeUrl: \"/cosmwasm.wasm.v1.MsgExecuteContract\",\n          value: tx_1.MsgExecuteContract.encode({\n            sender: msg.value.sender,\n            contract: msg.value.contract,\n            msg: buffer_1.Buffer.from(JSON.stringify(msg.value.msg)),\n            funds: msg.value.funds\n          }).finish()\n        }]\n      }, memo, {\n        amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],\n        gas: stdFee.gas\n      }, signOptions, onTxEvents);\n    });\n  }\n  get queries() {\n    return this.queriesStore.get(this.chainId);\n  }\n}\nexports.CosmwasmAccountImpl = CosmwasmAccountImpl;","map":{"version":3,"mappings":"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","names":["exports","use","options","base","chainGetter","chainId","msgOptsFromCreator","msgOptsCreator","undefined","cosmwasm","CosmwasmAccountImpl","queriesStore","deepmerge_1","send","cw20","gas","executeWasm","type","constructor","_msgOpts","registerMakeSendTokenFn","processMakeSendTokenTx","bind","registerSendTokenFn","processSendToken","msgOpts","amount","currency","recipient","denomHelper","common_1","coinMinimalDenom","actualAmount","dec","unit_1","mul","getPrecisionDec","coinDecimals","truncate","toString","Error","cosmos_1","validate","getChain","bech32Config","bech32PrefixAccAddr","makeExecuteContractTx","contractAddress","transfer","tx","code","queryBalance","queries","queryBalances","getQueryBech32Address","bech32Address","balances","find","bal","fetch","memo","stdFee","signOptions","onTxEvents","sendExecuteContractMsg","utils_1","obj","funds","preOnTxEvents","msg","value","sender","contract","cosmos","makeTx","aminoMsgs","protoMsgs","typeUrl","tx_1","encode","buffer_1","from","JSON","stringify","finish","sendMsgs","get"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/account/cosmwasm.ts"],"sourcesContent":["import { AccountSetBase, AccountSetBaseSuper, MsgOpt } from \"./base\";\nimport { CosmwasmQueries, IQueriesStore, QueriesSetBase } from \"../query\";\nimport { ChainGetter, CoinPrimitive } from \"../common\";\nimport { StdFee } from \"@cosmjs/launchpad\";\nimport { DenomHelper } from \"@keplr-wallet/common\";\nimport { Dec, DecUtils } from \"@keplr-wallet/unit\";\nimport { AppCurrency, KeplrSignOptions } from \"@keplr-wallet/types\";\nimport { DeepPartial, DeepReadonly, Optional } from \"utility-types\";\nimport { MsgExecuteContract } from \"@keplr-wallet/proto-types/cosmwasm/wasm/v1/tx\";\nimport { Buffer } from \"buffer/\";\nimport deepmerge from \"deepmerge\";\nimport { CosmosAccount } from \"./cosmos\";\nimport { txEventsWithPreOnFulfill } from \"./utils\";\nimport { Bech32Address } from \"@keplr-wallet/cosmos\";\n\nexport interface CosmwasmAccount {\n  cosmwasm: CosmwasmAccountImpl;\n}\n\nexport const CosmwasmAccount = {\n  use(options: {\n    msgOptsCreator?: (\n      chainId: string\n    ) => DeepPartial<CosmwasmMsgOpts> | undefined;\n    queriesStore: IQueriesStore<CosmwasmQueries>;\n  }): (\n    base: AccountSetBaseSuper & CosmosAccount,\n    chainGetter: ChainGetter,\n    chainId: string\n  ) => CosmwasmAccount {\n    return (base, chainGetter, chainId) => {\n      const msgOptsFromCreator = options.msgOptsCreator\n        ? options.msgOptsCreator(chainId)\n        : undefined;\n\n      return {\n        cosmwasm: new CosmwasmAccountImpl(\n          base,\n          chainGetter,\n          chainId,\n          options.queriesStore,\n          deepmerge<CosmwasmMsgOpts, DeepPartial<CosmwasmMsgOpts>>(\n            defaultCosmwasmMsgOpts,\n            msgOptsFromCreator ? msgOptsFromCreator : {}\n          )\n        ),\n      };\n    };\n  },\n};\n\n/**\n * @deprecated Predict gas through simulation rather than using a fixed gas.\n */\nexport interface CosmwasmMsgOpts {\n  readonly send: {\n    readonly cw20: Pick<MsgOpt, \"gas\">;\n  };\n\n  readonly executeWasm: Pick<MsgOpt, \"type\">;\n}\n\n/**\n * @deprecated Predict gas through simulation rather than using a fixed gas.\n */\nexport const defaultCosmwasmMsgOpts: CosmwasmMsgOpts = {\n  send: {\n    cw20: {\n      gas: 150000,\n    },\n  },\n\n  executeWasm: {\n    type: \"wasm/MsgExecuteContract\",\n  },\n};\n\nexport class CosmwasmAccountImpl {\n  constructor(\n    protected readonly base: AccountSetBase & CosmosAccount,\n    protected readonly chainGetter: ChainGetter,\n    protected readonly chainId: string,\n    protected readonly queriesStore: IQueriesStore<CosmwasmQueries>,\n    protected readonly _msgOpts: CosmwasmMsgOpts\n  ) {\n    this.base.registerMakeSendTokenFn(this.processMakeSendTokenTx.bind(this));\n    this.base.registerSendTokenFn(this.processSendToken.bind(this));\n  }\n\n  /**\n   * @deprecated Predict gas through simulation rather than using a fixed gas.\n   */\n  get msgOpts(): CosmwasmMsgOpts {\n    return this._msgOpts;\n  }\n\n  protected processMakeSendTokenTx(\n    amount: string,\n    currency: AppCurrency,\n    recipient: string\n  ) {\n    const denomHelper = new DenomHelper(currency.coinMinimalDenom);\n\n    if (denomHelper.type === \"cw20\") {\n      const actualAmount = (() => {\n        let dec = new Dec(amount);\n        dec = dec.mul(DecUtils.getPrecisionDec(currency.coinDecimals));\n        return dec.truncate().toString();\n      })();\n\n      if (!(\"type\" in currency) || currency.type !== \"cw20\") {\n        throw new Error(\"Currency is not cw20\");\n      }\n\n      Bech32Address.validate(\n        recipient,\n        this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr\n      );\n\n      return this.makeExecuteContractTx(\n        \"send\",\n        currency.contractAddress,\n        {\n          transfer: {\n            recipient: recipient,\n            amount: actualAmount,\n          },\n        },\n        [],\n        (tx) => {\n          if (tx.code == null || tx.code === 0) {\n            // After succeeding to send token, refresh the balance.\n            const queryBalance = this.queries.queryBalances\n              .getQueryBech32Address(this.base.bech32Address)\n              .balances.find((bal) => {\n                return (\n                  bal.currency.coinMinimalDenom === currency.coinMinimalDenom\n                );\n              });\n\n            if (queryBalance) {\n              queryBalance.fetch();\n            }\n          }\n        }\n      );\n    }\n  }\n\n  /**\n   * @deprecated\n   */\n  protected async processSendToken(\n    amount: string,\n    currency: AppCurrency,\n    recipient: string,\n    memo: string,\n    stdFee: Partial<StdFee>,\n    signOptions?: KeplrSignOptions,\n    onTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ): Promise<boolean> {\n    const denomHelper = new DenomHelper(currency.coinMinimalDenom);\n\n    switch (denomHelper.type) {\n      case \"cw20\":\n        const actualAmount = (() => {\n          let dec = new Dec(amount);\n          dec = dec.mul(DecUtils.getPrecisionDec(currency.coinDecimals));\n          return dec.truncate().toString();\n        })();\n\n        if (!(\"type\" in currency) || currency.type !== \"cw20\") {\n          throw new Error(\"Currency is not cw20\");\n        }\n        await this.sendExecuteContractMsg(\n          \"send\",\n          currency.contractAddress,\n          {\n            transfer: {\n              recipient: recipient,\n              amount: actualAmount,\n            },\n          },\n          [],\n          memo,\n          {\n            amount: stdFee.amount ?? [],\n            gas: stdFee.gas ?? this.msgOpts.send.cw20.gas.toString(),\n          },\n          signOptions,\n          txEventsWithPreOnFulfill(onTxEvents, (tx) => {\n            if (tx.code == null || tx.code === 0) {\n              // After succeeding to send token, refresh the balance.\n              const queryBalance = this.queries.queryBalances\n                .getQueryBech32Address(this.base.bech32Address)\n                .balances.find((bal) => {\n                  return (\n                    bal.currency.coinMinimalDenom === currency.coinMinimalDenom\n                  );\n                });\n\n              if (queryBalance) {\n                queryBalance.fetch();\n              }\n            }\n          })\n        );\n        return true;\n    }\n\n    return false;\n  }\n\n  makeExecuteContractTx(\n    // This arg can be used to override the type of sending tx if needed.\n    type: keyof CosmwasmMsgOpts | \"unknown\" = \"executeWasm\",\n    contractAddress: string,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    obj: object,\n    funds: CoinPrimitive[],\n    preOnTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ) {\n    Bech32Address.validate(\n      contractAddress,\n      this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr\n    );\n\n    const msg = {\n      type: this.msgOpts.executeWasm.type,\n      value: {\n        sender: this.base.bech32Address,\n        contract: contractAddress,\n        msg: obj,\n        funds,\n      },\n    };\n\n    return this.base.cosmos.makeTx(\n      type,\n      {\n        aminoMsgs: [msg],\n        protoMsgs: [\n          {\n            typeUrl: \"/cosmwasm.wasm.v1.MsgExecuteContract\",\n            value: MsgExecuteContract.encode({\n              sender: msg.value.sender,\n              contract: msg.value.contract,\n              msg: Buffer.from(JSON.stringify(msg.value.msg)),\n              funds: msg.value.funds,\n            }).finish(),\n          },\n        ],\n      },\n      preOnTxEvents\n    );\n  }\n\n  /**\n   * @deprecated\n   */\n  async sendExecuteContractMsg(\n    // This arg can be used to override the type of sending tx if needed.\n    type: keyof CosmwasmMsgOpts | \"unknown\" = \"executeWasm\",\n    contractAddress: string,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    obj: object,\n    funds: CoinPrimitive[],\n    memo: string = \"\",\n    stdFee: Optional<StdFee, \"amount\">,\n    signOptions?: KeplrSignOptions,\n    onTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ): Promise<void> {\n    const msg = {\n      type: this.msgOpts.executeWasm.type,\n      value: {\n        sender: this.base.bech32Address,\n        contract: contractAddress,\n        msg: obj,\n        funds,\n      },\n    };\n\n    await this.base.cosmos.sendMsgs(\n      type,\n      {\n        aminoMsgs: [msg],\n        protoMsgs: [\n          {\n            typeUrl: \"/cosmwasm.wasm.v1.MsgExecuteContract\",\n            value: MsgExecuteContract.encode({\n              sender: msg.value.sender,\n              contract: msg.value.contract,\n              msg: Buffer.from(JSON.stringify(msg.value.msg)),\n              funds: msg.value.funds,\n            }).finish(),\n          },\n        ],\n      },\n      memo,\n      {\n        amount: stdFee.amount ?? [],\n        gas: stdFee.gas,\n      },\n      signOptions,\n      onTxEvents\n    );\n  }\n\n  protected get queries(): DeepReadonly<QueriesSetBase & CosmwasmQueries> {\n    return this.queriesStore.get(this.chainId);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}