{"ast":null,"code":"\"use strict\";\n\n// Copyright (C) 2016-2017 Dmitry Chestnykh, Tony Arcieri\n// MIT License. See LICENSE file for details.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst block_1 = require(\"../internals/block\");\nconst xor_1 = require(\"../internals/xor\");\n/**\n * The AES-CMAC message authentication code\n */\nclass CMAC {\n  constructor(_cipher, _subkey1, _subkey2) {\n    this._cipher = _cipher;\n    this._subkey1 = _subkey1;\n    this._subkey2 = _subkey2;\n    this._bufferPos = 0;\n    this._finished = false;\n    this._buffer = new block_1.default();\n  }\n  /** Create a new CMAC instance from the given key */\n  static importKey(provider, keyData) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const cipher = yield provider.importBlockCipherKey(keyData);\n      // Generate subkeys.\n      const subkey1 = new block_1.default();\n      yield cipher.encryptBlock(subkey1);\n      subkey1.dbl();\n      const subkey2 = subkey1.clone();\n      subkey2.dbl();\n      return new CMAC(cipher, subkey1, subkey2);\n    });\n  }\n  reset() {\n    this._buffer.clear();\n    this._bufferPos = 0;\n    this._finished = false;\n    return this;\n  }\n  clear() {\n    this.reset();\n    this._subkey1.clear();\n    this._subkey2.clear();\n  }\n  update(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const left = block_1.default.SIZE - this._bufferPos;\n      let dataPos = 0;\n      let dataLength = data.length;\n      if (dataLength > left) {\n        for (let i = 0; i < left; i++) {\n          this._buffer.data[this._bufferPos + i] ^= data[i];\n        }\n        dataLength -= left;\n        dataPos += left;\n        yield this._cipher.encryptBlock(this._buffer);\n        this._bufferPos = 0;\n      }\n      // TODO: use AES-CBC with a span of multiple blocks instead of encryptBlock\n      // to encrypt many blocks in a single call to the WebCrypto API\n      while (dataLength > block_1.default.SIZE) {\n        for (let i = 0; i < block_1.default.SIZE; i++) {\n          this._buffer.data[i] ^= data[dataPos + i];\n        }\n        dataLength -= block_1.default.SIZE;\n        dataPos += block_1.default.SIZE;\n        yield this._cipher.encryptBlock(this._buffer);\n      }\n      for (let i = 0; i < dataLength; i++) {\n        this._buffer.data[this._bufferPos++] ^= data[dataPos + i];\n      }\n      return this;\n    });\n  }\n  finish() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._finished) {\n        // Select which subkey to use.\n        const subkey = this._bufferPos < block_1.default.SIZE ? this._subkey2 : this._subkey1;\n        // XOR in the subkey.\n        xor_1.xor(this._buffer.data, subkey.data);\n        // Pad if needed.\n        if (this._bufferPos < block_1.default.SIZE) {\n          this._buffer.data[this._bufferPos] ^= 0x80;\n        }\n        // Encrypt buffer to get the final digest.\n        yield this._cipher.encryptBlock(this._buffer);\n        // Set finished flag.\n        this._finished = true;\n      }\n      return this._buffer.clone().data;\n    });\n  }\n}\nexports.CMAC = CMAC;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","block_1","require","xor_1","CMAC","constructor","_cipher","_subkey1","_subkey2","_bufferPos","_finished","_buffer","default","importKey","provider","keyData","cipher","importBlockCipherKey","subkey1","encryptBlock","dbl","subkey2","clone","reset","clear","update","data","left","SIZE","dataPos","dataLength","length","i","finish","subkey","xor"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/miscreant/release/mac/cmac.js"],"sourcesContent":["\"use strict\";\n// Copyright (C) 2016-2017 Dmitry Chestnykh, Tony Arcieri\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst block_1 = require(\"../internals/block\");\nconst xor_1 = require(\"../internals/xor\");\n/**\n * The AES-CMAC message authentication code\n */\nclass CMAC {\n    constructor(_cipher, _subkey1, _subkey2) {\n        this._cipher = _cipher;\n        this._subkey1 = _subkey1;\n        this._subkey2 = _subkey2;\n        this._bufferPos = 0;\n        this._finished = false;\n        this._buffer = new block_1.default();\n    }\n    /** Create a new CMAC instance from the given key */\n    static importKey(provider, keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cipher = yield provider.importBlockCipherKey(keyData);\n            // Generate subkeys.\n            const subkey1 = new block_1.default();\n            yield cipher.encryptBlock(subkey1);\n            subkey1.dbl();\n            const subkey2 = subkey1.clone();\n            subkey2.dbl();\n            return new CMAC(cipher, subkey1, subkey2);\n        });\n    }\n    reset() {\n        this._buffer.clear();\n        this._bufferPos = 0;\n        this._finished = false;\n        return this;\n    }\n    clear() {\n        this.reset();\n        this._subkey1.clear();\n        this._subkey2.clear();\n    }\n    update(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const left = block_1.default.SIZE - this._bufferPos;\n            let dataPos = 0;\n            let dataLength = data.length;\n            if (dataLength > left) {\n                for (let i = 0; i < left; i++) {\n                    this._buffer.data[this._bufferPos + i] ^= data[i];\n                }\n                dataLength -= left;\n                dataPos += left;\n                yield this._cipher.encryptBlock(this._buffer);\n                this._bufferPos = 0;\n            }\n            // TODO: use AES-CBC with a span of multiple blocks instead of encryptBlock\n            // to encrypt many blocks in a single call to the WebCrypto API\n            while (dataLength > block_1.default.SIZE) {\n                for (let i = 0; i < block_1.default.SIZE; i++) {\n                    this._buffer.data[i] ^= data[dataPos + i];\n                }\n                dataLength -= block_1.default.SIZE;\n                dataPos += block_1.default.SIZE;\n                yield this._cipher.encryptBlock(this._buffer);\n            }\n            for (let i = 0; i < dataLength; i++) {\n                this._buffer.data[this._bufferPos++] ^= data[dataPos + i];\n            }\n            return this;\n        });\n    }\n    finish() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._finished) {\n                // Select which subkey to use.\n                const subkey = (this._bufferPos < block_1.default.SIZE) ? this._subkey2 : this._subkey1;\n                // XOR in the subkey.\n                xor_1.xor(this._buffer.data, subkey.data);\n                // Pad if needed.\n                if (this._bufferPos < block_1.default.SIZE) {\n                    this._buffer.data[this._bufferPos] ^= 0x80;\n                }\n                // Encrypt buffer to get the final digest.\n                yield this._cipher.encryptBlock(this._buffer);\n                // Set finished flag.\n                this._finished = true;\n            }\n            return this._buffer.clone().data;\n        });\n    }\n}\nexports.CMAC = CMAC;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}