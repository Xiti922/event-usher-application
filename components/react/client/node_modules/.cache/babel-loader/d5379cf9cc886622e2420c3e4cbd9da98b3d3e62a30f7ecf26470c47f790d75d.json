{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableQueryAccount = exports.ObservableQueryAccountInner = void 0;\nconst chain_query_1 = require(\"../../chain-query\");\nconst mobx_1 = require(\"mobx\");\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nclass ObservableQueryAccountInner extends chain_query_1.ObservableChainQuery {\n  constructor(kvStore, chainId, chainGetter, bech32Address) {\n    super(kvStore, chainId, chainGetter, `/cosmos/auth/v1beta1/accounts/${bech32Address}`);\n    this.bech32Address = bech32Address;\n    mobx_1.makeObservable(this);\n  }\n  canFetch() {\n    // If bech32 address is empty, it will always fail, so don't need to fetch it.\n    return this.bech32Address.length > 0;\n  }\n  get sequence() {\n    if (!this.response) {\n      return \"0\";\n    }\n    // XXX: In launchpad, the status was 200 even if the account not exist.\n    //      However, from stargate, the status becomes 404 if the account not exist.\n    //      This case has not been dealt with yet.\n    //      However, in the case of 404, it will be treated as an error, and in this case the sequence should be 0.\n    try {\n      const account = cosmos_1.BaseAccount.fromProtoJSON(this.response.data, this.bech32Address);\n      return account.getSequence().toString();\n    } catch (_a) {\n      return \"0\";\n    }\n  }\n  get isVestingAccount() {\n    var _a;\n    if (!this.response) {\n      return false;\n    }\n    return !!((_a = this.response.data) === null || _a === void 0 ? void 0 : _a.account.base_vesting_account);\n  }\n}\n__decorate([mobx_1.computed], ObservableQueryAccountInner.prototype, \"sequence\", null);\n__decorate([mobx_1.computed], ObservableQueryAccountInner.prototype, \"isVestingAccount\", null);\nexports.ObservableQueryAccountInner = ObservableQueryAccountInner;\nclass ObservableQueryAccount extends chain_query_1.ObservableChainQueryMap {\n  constructor(kvStore, chainId, chainGetter) {\n    super(kvStore, chainId, chainGetter, bech32Address => {\n      return new ObservableQueryAccountInner(this.kvStore, this.chainId, this.chainGetter, bech32Address);\n    });\n    this.kvStore = kvStore;\n    this.chainId = chainId;\n    this.chainGetter = chainGetter;\n  }\n  getQueryBech32Address(bech32Address) {\n    return this.get(bech32Address);\n  }\n}\nexports.ObservableQueryAccount = ObservableQueryAccount;","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;AAOA;AACA;AAEA,MAAaA,2BAA4B,SAAQC,kCAAiC;EAChFC,YACEC,OAAgB,EAChBC,OAAe,EACfC,WAAwB,EACLC,aAAqB;IAExC,KAAK,CACHH,OAAO,EACPC,OAAO,EACPC,WAAW,EACX,iCAAiCC,aAAa,EAAE,CACjD;IAPkB,kBAAa,GAAbA,aAAa;IAShCC,qBAAc,CAAC,IAAI,CAAC;EACtB;EAEUC,QAAQ;IAChB;IACA,OAAO,IAAI,CAACF,aAAa,CAACG,MAAM,GAAG,CAAC;EACtC;EAGA,IAAIC,QAAQ;IACV,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE;MAClB,OAAO,GAAG;;IAGZ;IACA;IACA;IACA;IAEA,IAAI;MACF,MAAMC,OAAO,GAAGC,oBAAW,CAACC,aAAa,CACvC,IAAI,CAACH,QAAQ,CAACI,IAAI,EAClB,IAAI,CAACT,aAAa,CACnB;MACD,OAAOM,OAAO,CAACI,WAAW,EAAE,CAACC,QAAQ,EAAE;KACxC,CAAC,WAAM;MACN,OAAO,GAAG;;EAEd;EAGA,IAAIC,gBAAgB;;IAClB,IAAI,CAAC,IAAI,CAACP,QAAQ,EAAE;MAClB,OAAO,KAAK;;IAGd,OAAO,CAAC,QAAC,IAAI,CAACA,QAAQ,CAACI,IAAI,0CAAEH,OAAO,CAACO,oBAAoB;EAC3D;;AA5BAC,YADCb,eAAQ,2DAoBR;AAGDa,YADCb,eAAQ,mEAOR;AAnDHc;AAsDA,MAAaC,sBAAuB,SAAQrB,qCAAoC;EAC9EC,YACqBC,OAAgB,EAChBC,OAAe,EACfC,WAAwB;IAE3C,KAAK,CAACF,OAAO,EAAEC,OAAO,EAAEC,WAAW,EAAGC,aAAa,IAAI;MACrD,OAAO,IAAIN,2BAA2B,CACpC,IAAI,CAACG,OAAO,EACZ,IAAI,CAACC,OAAO,EACZ,IAAI,CAACC,WAAW,EAChBC,aAAa,CACd;IACH,CAAC,CAAC;IAXiB,YAAO,GAAPH,OAAO;IACP,YAAO,GAAPC,OAAO;IACP,gBAAW,GAAXC,WAAW;EAUhC;EAEAkB,qBAAqB,CAACjB,aAAqB;IACzC,OAAO,IAAI,CAACkB,GAAG,CAAClB,aAAa,CAAgC;EAC/D;;AAlBFe","names":["ObservableQueryAccountInner","chain_query_1","constructor","kvStore","chainId","chainGetter","bech32Address","mobx_1","canFetch","length","sequence","response","account","cosmos_1","fromProtoJSON","data","getSequence","toString","isVestingAccount","base_vesting_account","__decorate","exports","ObservableQueryAccount","getQueryBech32Address","get"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/query/cosmos/account/index.ts"],"sourcesContent":["import {\n  ObservableChainQuery,\n  ObservableChainQueryMap,\n} from \"../../chain-query\";\nimport { KVStore } from \"@keplr-wallet/common\";\nimport { ChainGetter } from \"../../../common\";\nimport { AuthAccount } from \"./types\";\nimport { computed, makeObservable } from \"mobx\";\nimport { BaseAccount } from \"@keplr-wallet/cosmos\";\n\nexport class ObservableQueryAccountInner extends ObservableChainQuery<AuthAccount> {\n  constructor(\n    kvStore: KVStore,\n    chainId: string,\n    chainGetter: ChainGetter,\n    protected readonly bech32Address: string\n  ) {\n    super(\n      kvStore,\n      chainId,\n      chainGetter,\n      `/cosmos/auth/v1beta1/accounts/${bech32Address}`\n    );\n\n    makeObservable(this);\n  }\n\n  protected canFetch(): boolean {\n    // If bech32 address is empty, it will always fail, so don't need to fetch it.\n    return this.bech32Address.length > 0;\n  }\n\n  @computed\n  get sequence(): string {\n    if (!this.response) {\n      return \"0\";\n    }\n\n    // XXX: In launchpad, the status was 200 even if the account not exist.\n    //      However, from stargate, the status becomes 404 if the account not exist.\n    //      This case has not been dealt with yet.\n    //      However, in the case of 404, it will be treated as an error, and in this case the sequence should be 0.\n\n    try {\n      const account = BaseAccount.fromProtoJSON(\n        this.response.data,\n        this.bech32Address\n      );\n      return account.getSequence().toString();\n    } catch {\n      return \"0\";\n    }\n  }\n\n  @computed\n  get isVestingAccount(): boolean {\n    if (!this.response) {\n      return false;\n    }\n\n    return !!this.response.data?.account.base_vesting_account;\n  }\n}\n\nexport class ObservableQueryAccount extends ObservableChainQueryMap<AuthAccount> {\n  constructor(\n    protected readonly kvStore: KVStore,\n    protected readonly chainId: string,\n    protected readonly chainGetter: ChainGetter\n  ) {\n    super(kvStore, chainId, chainGetter, (bech32Address) => {\n      return new ObservableQueryAccountInner(\n        this.kvStore,\n        this.chainId,\n        this.chainGetter,\n        bech32Address\n      );\n    });\n  }\n\n  getQueryBech32Address(bech32Address: string): ObservableQueryAccountInner {\n    return this.get(bech32Address) as ObservableQueryAccountInner;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}