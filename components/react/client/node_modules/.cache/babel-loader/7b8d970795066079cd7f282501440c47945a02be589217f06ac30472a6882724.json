{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decrypt = exports.encrypt = exports.supportedAlgorithms = exports.executeKdf = exports.cosmjsSalt = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\n/**\n * A fixed salt is chosen to archive a deterministic password to key derivation.\n * This reduces the scope of a potential rainbow attack to all CosmJS users.\n * Must be 16 bytes due to implementation limitations.\n */\nexports.cosmjsSalt = (0, encoding_1.toAscii)(\"The CosmJS salt.\");\nasync function executeKdf(password, configuration) {\n  switch (configuration.algorithm) {\n    case \"argon2id\":\n      {\n        const options = configuration.params;\n        if (!(0, crypto_1.isArgon2idOptions)(options)) throw new Error(\"Invalid format of argon2id params\");\n        return crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);\n      }\n    default:\n      throw new Error(\"Unsupported KDF algorithm\");\n  }\n}\nexports.executeKdf = executeKdf;\nexports.supportedAlgorithms = {\n  xchacha20poly1305Ietf: \"xchacha20poly1305-ietf\"\n};\nasync function encrypt(plaintext, encryptionKey, config) {\n  switch (config.algorithm) {\n    case exports.supportedAlgorithms.xchacha20poly1305Ietf:\n      {\n        const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);\n        // Prepend fixed-length nonce to ciphertext as suggested in the example from https://github.com/jedisct1/libsodium.js#api\n        return new Uint8Array([...nonce, ...(await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce))]);\n      }\n    default:\n      throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);\n  }\n}\nexports.encrypt = encrypt;\nasync function decrypt(ciphertext, encryptionKey, config) {\n  switch (config.algorithm) {\n    case exports.supportedAlgorithms.xchacha20poly1305Ietf:\n      {\n        const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);\n        return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);\n      }\n    default:\n      throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);\n  }\n}\nexports.decrypt = decrypt;","map":{"version":3,"mappings":";;;;;;AAAA;AAOA;AAEA;;;;;AAKaA,kBAAU,GAAG,sBAAO,EAAC,kBAAkB,CAAC;AAW9C,eAAeC,UAAU,CAACC,QAAgB,EAAEC,aAA+B;EAChF,QAAQA,aAAa,CAACC,SAAS;IAC7B,KAAK,UAAU;MAAE;QACf,MAAMC,OAAO,GAAGF,aAAa,CAACG,MAAM;QACpC,IAAI,CAAC,8BAAiB,EAACD,OAAO,CAAC,EAAE,MAAM,IAAIE,KAAK,CAAC,mCAAmC,CAAC;QACrF,OAAOC,iBAAQ,CAACC,OAAO,CAACP,QAAQ,EAAEF,kBAAU,EAAEK,OAAO,CAAC;;IAExD;MACE,MAAM,IAAIE,KAAK,CAAC,2BAA2B,CAAC;EAAC;AAEnD;AAVAP;AAyBaA,2BAAmB,GAAG;EACjCU,qBAAqB,EAAE;CACxB;AAEM,eAAeC,OAAO,CAC3BC,SAAqB,EACrBC,aAAyB,EACzBC,MAA+B;EAE/B,QAAQA,MAAM,CAACV,SAAS;IACtB,KAAKJ,2BAAmB,CAACU,qBAAqB;MAAE;QAC9C,MAAMK,KAAK,GAAGP,eAAM,CAACQ,QAAQ,CAACR,6BAAoB,CAAC;QACnD;QACA,OAAO,IAAIS,UAAU,CAAC,CACpB,GAAGF,KAAK,EACR,IAAI,MAAMP,8BAAqB,CAACG,OAAO,CAACC,SAAS,EAAEC,aAAa,EAAEE,KAAK,CAAC,CAAC,CAC1E,CAAC;;IAEJ;MACE,MAAM,IAAIR,KAAK,CAAC,sCAAsCO,MAAM,CAACV,SAAS,GAAG,CAAC;EAAC;AAEjF;AAjBAJ;AAmBO,eAAekB,OAAO,CAC3BC,UAAsB,EACtBN,aAAyB,EACzBC,MAA+B;EAE/B,QAAQA,MAAM,CAACV,SAAS;IACtB,KAAKJ,2BAAmB,CAACU,qBAAqB;MAAE;QAC9C,MAAMK,KAAK,GAAGI,UAAU,CAACC,KAAK,CAAC,CAAC,EAAEZ,6BAAoB,CAAC;QACvD,OAAOA,8BAAqB,CAACU,OAAO,CAACC,UAAU,CAACC,KAAK,CAACZ,6BAAoB,CAAC,EAAEK,aAAa,EAAEE,KAAK,CAAC;;IAEpG;MACE,MAAM,IAAIR,KAAK,CAAC,sCAAsCO,MAAM,CAACV,SAAS,GAAG,CAAC;EAAC;AAEjF;AAbAJ","names":["exports","executeKdf","password","configuration","algorithm","options","params","Error","crypto_1","execute","xchacha20poly1305Ietf","encrypt","plaintext","encryptionKey","config","nonce","getBytes","Uint8Array","decrypt","ciphertext","slice"],"sources":["../src/wallet.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}