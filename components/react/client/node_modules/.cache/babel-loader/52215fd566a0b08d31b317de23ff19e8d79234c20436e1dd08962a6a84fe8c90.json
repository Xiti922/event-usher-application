{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KeyRingStore = exports.KeyRingSelectablesStore = void 0;\nconst router_1 = require(\"@keplr-wallet/router\");\nconst background_1 = require(\"@keplr-wallet/background\");\nconst mobx_1 = require(\"mobx\");\nconst common_1 = require(\"@keplr-wallet/common\");\nclass KeyRingSelectablesStore {\n  constructor(chainGetter, requester, chainId, keyRingStore) {\n    this.chainGetter = chainGetter;\n    this.requester = requester;\n    this.chainId = chainId;\n    this.keyRingStore = keyRingStore;\n    this.isInitializing = false;\n    this._isKeyStoreCoinTypeSet = false;\n    this._selectables = [];\n    mobx_1.makeObservable(this);\n    this.refresh();\n  }\n  get needSelectCoinType() {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    if (!chainInfo.alternativeBIP44s || chainInfo.alternativeBIP44s.length === 0) {\n      return false;\n    }\n    return !this.isInitializing && !this._isKeyStoreCoinTypeSet;\n  }\n  get selectables() {\n    return this._selectables;\n  }\n  *refresh() {\n    var _a;\n    // No need to set the coin type if the key store type is not mnemonic.\n    if (this.keyRingStore.keyRingType !== \"mnemonic\") {\n      this.isInitializing = false;\n      this._isKeyStoreCoinTypeSet = true;\n      this._selectables = [];\n      return;\n    }\n    this.isInitializing = true;\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    const msg = new background_1.GetIsKeyStoreCoinTypeSetMsg(this.chainId, [chainInfo.bip44, ...((_a = chainInfo.alternativeBIP44s) !== null && _a !== void 0 ? _a : [])]);\n    const seletables = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));\n    if (seletables.length === 0) {\n      this._isKeyStoreCoinTypeSet = true;\n    } else if (seletables.length === 1) {\n      yield this.keyRingStore.setKeyStoreCoinType(this.chainId, seletables[0].path.coinType);\n      this._isKeyStoreCoinTypeSet = true;\n    } else {\n      this._selectables = seletables;\n      this._isKeyStoreCoinTypeSet = false;\n    }\n    this.isInitializing = false;\n  }\n}\n__decorate([mobx_1.observable], KeyRingSelectablesStore.prototype, \"isInitializing\", void 0);\n__decorate([mobx_1.observable], KeyRingSelectablesStore.prototype, \"_isKeyStoreCoinTypeSet\", void 0);\n__decorate([mobx_1.observable.ref], KeyRingSelectablesStore.prototype, \"_selectables\", void 0);\n__decorate([mobx_1.computed], KeyRingSelectablesStore.prototype, \"needSelectCoinType\", null);\n__decorate([mobx_1.flow], KeyRingSelectablesStore.prototype, \"refresh\", null);\nexports.KeyRingSelectablesStore = KeyRingSelectablesStore;\n/*\n Actual key ring logic is managed in persistent background. Refer \"src/common/message\" and \"src/background/keyring\"\n This store only interact with key ring in persistent background.\n */\nclass KeyRingStore {\n  constructor(eventDispatcher, defaultKdf, chainGetter, requester, interactionStore) {\n    this.eventDispatcher = eventDispatcher;\n    this.defaultKdf = defaultKdf;\n    this.chainGetter = chainGetter;\n    this.requester = requester;\n    this.interactionStore = interactionStore;\n    this.status = background_1.KeyRingStatus.NOTLOADED;\n    this.multiKeyStoreInfo = [];\n    this.selectablesMap = new Map();\n    this.keyStoreChangedListeners = [];\n    mobx_1.makeObservable(this);\n    this.restore();\n  }\n  get keyRingType() {\n    const keyStore = this.multiKeyStoreInfo.find(keyStore => keyStore.selected);\n    if (!keyStore) {\n      return \"none\";\n    } else {\n      return background_1.KeyRing.getTypeOfKeyStore(keyStore);\n    }\n  }\n  createMnemonicKey(mnemonic, password, meta, bip44HDPath) {\n    var _this = this;\n    let kdf = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.defaultKdf;\n    return function* () {\n      const msg = new background_1.CreateMnemonicKeyMsg(kdf, mnemonic, password, meta, bip44HDPath);\n      const result = yield* common_1.toGenerator(_this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));\n      _this.status = result.status;\n      _this.multiKeyStoreInfo = result.multiKeyStoreInfo;\n    }();\n  }\n  createPrivateKey(privateKey, password, meta) {\n    var _this2 = this;\n    let kdf = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.defaultKdf;\n    return function* () {\n      const msg = new background_1.CreatePrivateKeyMsg(kdf, privateKey, password, meta);\n      const result = yield* common_1.toGenerator(_this2.requester.sendMessage(router_1.BACKGROUND_PORT, msg));\n      _this2.status = result.status;\n      _this2.multiKeyStoreInfo = result.multiKeyStoreInfo;\n    }();\n  }\n  createLedgerKey(password, meta, bip44HDPath) {\n    var _this3 = this;\n    let kdf = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.defaultKdf;\n    return function* () {\n      const msg = new background_1.CreateLedgerKeyMsg(kdf, password, meta, bip44HDPath);\n      const result = yield* common_1.toGenerator(_this3.requester.sendMessage(router_1.BACKGROUND_PORT, msg));\n      _this3.status = result.status;\n      _this3.multiKeyStoreInfo = result.multiKeyStoreInfo;\n    }();\n  }\n  addMnemonicKey(mnemonic, meta, bip44HDPath) {\n    var _this4 = this;\n    let kdf = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.defaultKdf;\n    return function* () {\n      const msg = new background_1.AddMnemonicKeyMsg(kdf, mnemonic, meta, bip44HDPath);\n      _this4.multiKeyStoreInfo = (yield* common_1.toGenerator(_this4.requester.sendMessage(router_1.BACKGROUND_PORT, msg))).multiKeyStoreInfo;\n    }();\n  }\n  addPrivateKey(privateKey, meta) {\n    var _this5 = this;\n    let kdf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.defaultKdf;\n    return function* () {\n      const msg = new background_1.AddPrivateKeyMsg(kdf, privateKey, meta);\n      _this5.multiKeyStoreInfo = (yield* common_1.toGenerator(_this5.requester.sendMessage(router_1.BACKGROUND_PORT, msg))).multiKeyStoreInfo;\n    }();\n  }\n  addLedgerKey(meta, bip44HDPath) {\n    var _this6 = this;\n    let kdf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.defaultKdf;\n    return function* () {\n      const msg = new background_1.AddLedgerKeyMsg(kdf, meta, bip44HDPath);\n      _this6.multiKeyStoreInfo = (yield* common_1.toGenerator(_this6.requester.sendMessage(router_1.BACKGROUND_PORT, msg))).multiKeyStoreInfo;\n    }();\n  }\n  *changeKeyRing(index) {\n    const msg = new background_1.ChangeKeyRingMsg(index);\n    this.multiKeyStoreInfo = (yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg))).multiKeyStoreInfo;\n    // Emit the key store changed event manually.\n    this.dispatchKeyStoreChangeEvent();\n    this.selectablesMap.forEach(selectables => selectables.refresh());\n  }\n  *lock() {\n    const msg = new background_1.LockKeyRingMsg();\n    const result = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));\n    this.status = result.status;\n  }\n  *unlock(password) {\n    const msg = new background_1.UnlockKeyRingMsg(password);\n    const result = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));\n    this.status = result.status;\n    // Approve all waiting interaction for the enabling key ring.\n    for (const interaction of this.interactionStore.getDatas(\"unlock\")) {\n      yield this.interactionStore.approve(\"unlock\", interaction.id, {});\n    }\n    this.dispatchKeyStoreChangeEvent();\n    this.selectablesMap.forEach(selectables => selectables.refresh());\n  }\n  *rejectAll() {\n    yield this.interactionStore.rejectAll(\"unlock\");\n  }\n  *restore() {\n    const msg = new background_1.RestoreKeyRingMsg();\n    const result = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));\n    this.status = result.status;\n    this.multiKeyStoreInfo = result.multiKeyStoreInfo;\n  }\n  showKeyRing(index, password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = new background_1.ShowKeyRingMsg(index, password);\n      return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);\n    });\n  }\n  *deleteKeyRing(index, password) {\n    const selectedIndex = this.multiKeyStoreInfo.findIndex(keyStore => keyStore.selected);\n    const msg = new background_1.DeleteKeyRingMsg(index, password);\n    const result = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));\n    this.status = result.status;\n    this.multiKeyStoreInfo = result.multiKeyStoreInfo;\n    // Selected keystore may be changed if the selected one is deleted.\n    if (selectedIndex === index) {\n      this.dispatchKeyStoreChangeEvent();\n      this.selectablesMap.forEach(selectables => selectables.refresh());\n    }\n  }\n  *updateNameKeyRing(index, name) {\n    const msg = new background_1.UpdateNameKeyRingMsg(index, name);\n    const result = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));\n    this.multiKeyStoreInfo = result.multiKeyStoreInfo;\n    const selectedIndex = this.multiKeyStoreInfo.findIndex(keyStore => keyStore.selected);\n    // If selectedIndex and index are same, name could be changed, so dispatch keystore event\n    if (selectedIndex === index) {\n      this.dispatchKeyStoreChangeEvent();\n    }\n  }\n  checkPassword(password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new background_1.CheckPasswordMsg(password));\n    });\n  }\n  getKeyStoreSelectables(chainId) {\n    if (!this.selectablesMap.has(chainId)) {\n      mobx_1.runInAction(() => {\n        this.selectablesMap.set(chainId, new KeyRingSelectablesStore(this.chainGetter, this.requester, chainId, this));\n      });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.selectablesMap.get(chainId);\n  }\n  // Set the coin type to current key store.\n  // And, save it, refresh the key store.\n  *setKeyStoreCoinType(chainId, coinType) {\n    const status = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, new background_1.SetKeyStoreCoinTypeMsg(chainId, coinType)));\n    this.multiKeyStoreInfo = (yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, new background_1.GetMultiKeyStoreInfoMsg()))).multiKeyStoreInfo;\n    this.status = status;\n    // Emit the key store changed event manually.\n    this.dispatchKeyStoreChangeEvent();\n    this.selectablesMap.forEach(selectables => selectables.refresh());\n  }\n  exportKeyRingDatas(password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new background_1.ExportKeyRingDatasMsg(password));\n    });\n  }\n  dispatchKeyStoreChangeEvent() {\n    this.eventDispatcher.dispatchEvent(\"keplr_keystorechange\");\n    for (const listener of this.keyStoreChangedListeners) {\n      listener();\n    }\n  }\n  addKeyStoreChangedListener(listener) {\n    this.keyStoreChangedListeners.push(listener);\n  }\n  removeKeyStoreChangedListener(listener) {\n    const i = this.keyStoreChangedListeners.indexOf(listener);\n    if (i >= 0) {\n      this.keyStoreChangedListeners.splice(i, 1);\n    }\n  }\n}\n__decorate([mobx_1.observable], KeyRingStore.prototype, \"status\", void 0);\n__decorate([mobx_1.observable], KeyRingStore.prototype, \"multiKeyStoreInfo\", void 0);\n__decorate([mobx_1.observable.shallow], KeyRingStore.prototype, \"selectablesMap\", void 0);\n__decorate([mobx_1.computed], KeyRingStore.prototype, \"keyRingType\", null);\n__decorate([mobx_1.flow], KeyRingStore.prototype, \"createMnemonicKey\", null);\n__decorate([mobx_1.flow], KeyRingStore.prototype, \"createPrivateKey\", null);\n__decorate([mobx_1.flow], KeyRingStore.prototype, \"createLedgerKey\", null);\n__decorate([mobx_1.flow], KeyRingStore.prototype, \"addMnemonicKey\", null);\n__decorate([mobx_1.flow], KeyRingStore.prototype, \"addPrivateKey\", null);\n__decorate([mobx_1.flow], KeyRingStore.prototype, \"addLedgerKey\", null);\n__decorate([mobx_1.flow], KeyRingStore.prototype, \"changeKeyRing\", null);\n__decorate([mobx_1.flow], KeyRingStore.prototype, \"lock\", null);\n__decorate([mobx_1.flow], KeyRingStore.prototype, \"unlock\", null);\n__decorate([mobx_1.flow], KeyRingStore.prototype, \"rejectAll\", null);\n__decorate([mobx_1.flow], KeyRingStore.prototype, \"restore\", null);\n__decorate([mobx_1.flow], KeyRingStore.prototype, \"deleteKeyRing\", null);\n__decorate([mobx_1.flow], KeyRingStore.prototype, \"updateNameKeyRing\", null);\n__decorate([mobx_1.flow], KeyRingStore.prototype, \"setKeyStoreCoinType\", null);\nexports.KeyRingStore = KeyRingStore;","map":{"version":3,"mappings":"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","names":["KeyRingSelectablesStore","constructor","chainGetter","requester","chainId","keyRingStore","mobx_1","refresh","needSelectCoinType","chainInfo","getChain","alternativeBIP44s","length","isInitializing","_isKeyStoreCoinTypeSet","selectables","_selectables","keyRingType","msg","background_1","bip44","seletables","common_1","sendMessage","router_1","setKeyStoreCoinType","path","coinType","__decorate","ref","exports","KeyRingStore","eventDispatcher","defaultKdf","interactionStore","NOTLOADED","Map","restore","keyStore","multiKeyStoreInfo","find","selected","getTypeOfKeyStore","createMnemonicKey","mnemonic","password","meta","bip44HDPath","kdf","result","status","createPrivateKey","privateKey","createLedgerKey","addMnemonicKey","addPrivateKey","addLedgerKey","changeKeyRing","index","dispatchKeyStoreChangeEvent","selectablesMap","forEach","lock","unlock","interaction","getDatas","approve","id","rejectAll","showKeyRing","deleteKeyRing","selectedIndex","findIndex","updateNameKeyRing","name","checkPassword","getKeyStoreSelectables","has","set","get","exportKeyRingDatas","dispatchEvent","listener","keyStoreChangedListeners","addKeyStoreChangedListener","push","removeKeyStoreChangedListener","i","indexOf","splice","shallow"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/core/keyring.ts"],"sourcesContent":["import { BACKGROUND_PORT, MessageRequester } from \"@keplr-wallet/router\";\nimport {\n  AddLedgerKeyMsg,\n  AddMnemonicKeyMsg,\n  AddPrivateKeyMsg,\n  BIP44HDPath,\n  ChangeKeyRingMsg,\n  CreateLedgerKeyMsg,\n  CreateMnemonicKeyMsg,\n  CreatePrivateKeyMsg,\n  DeleteKeyRingMsg,\n  UpdateNameKeyRingMsg,\n  GetIsKeyStoreCoinTypeSetMsg,\n  GetMultiKeyStoreInfoMsg,\n  KeyRingStatus,\n  LockKeyRingMsg,\n  MultiKeyStoreInfoWithSelected,\n  RestoreKeyRingMsg,\n  SetKeyStoreCoinTypeMsg,\n  ShowKeyRingMsg,\n  UnlockKeyRingMsg,\n  KeyRing,\n  CheckPasswordMsg,\n  ExportKeyRingData,\n  ExportKeyRingDatasMsg,\n} from \"@keplr-wallet/background\";\n\nimport { computed, flow, makeObservable, observable, runInAction } from \"mobx\";\n\nimport { InteractionStore } from \"./interaction\";\nimport { ChainGetter } from \"../common\";\nimport { BIP44 } from \"@keplr-wallet/types\";\nimport { DeepReadonly } from \"utility-types\";\nimport { toGenerator } from \"@keplr-wallet/common\";\n\nexport class KeyRingSelectablesStore {\n  @observable\n  isInitializing: boolean = false;\n\n  @observable\n  protected _isKeyStoreCoinTypeSet: boolean = false;\n\n  @observable.ref\n  _selectables: {\n    path: BIP44;\n    bech32Address: string;\n  }[] = [];\n\n  constructor(\n    protected readonly chainGetter: ChainGetter,\n    protected readonly requester: MessageRequester,\n    protected readonly chainId: string,\n    protected readonly keyRingStore: KeyRingStore\n  ) {\n    makeObservable(this);\n\n    this.refresh();\n  }\n\n  @computed\n  get needSelectCoinType(): boolean {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    if (\n      !chainInfo.alternativeBIP44s ||\n      chainInfo.alternativeBIP44s.length === 0\n    ) {\n      return false;\n    }\n    return !this.isInitializing && !this._isKeyStoreCoinTypeSet;\n  }\n\n  get selectables(): DeepReadonly<\n    {\n      path: BIP44;\n      bech32Address: string;\n    }[]\n  > {\n    return this._selectables;\n  }\n\n  @flow\n  *refresh() {\n    // No need to set the coin type if the key store type is not mnemonic.\n    if (this.keyRingStore.keyRingType !== \"mnemonic\") {\n      this.isInitializing = false;\n      this._isKeyStoreCoinTypeSet = true;\n      this._selectables = [];\n\n      return;\n    }\n\n    this.isInitializing = true;\n\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n\n    const msg = new GetIsKeyStoreCoinTypeSetMsg(this.chainId, [\n      chainInfo.bip44,\n      ...(chainInfo.alternativeBIP44s ?? []),\n    ]);\n    const seletables = yield* toGenerator(\n      this.requester.sendMessage(BACKGROUND_PORT, msg)\n    );\n\n    if (seletables.length === 0) {\n      this._isKeyStoreCoinTypeSet = true;\n    } else if (seletables.length === 1) {\n      yield this.keyRingStore.setKeyStoreCoinType(\n        this.chainId,\n        seletables[0].path.coinType\n      );\n      this._isKeyStoreCoinTypeSet = true;\n    } else {\n      this._selectables = seletables;\n      this._isKeyStoreCoinTypeSet = false;\n    }\n\n    this.isInitializing = false;\n  }\n}\n\n/*\n Actual key ring logic is managed in persistent background. Refer \"src/common/message\" and \"src/background/keyring\"\n This store only interact with key ring in persistent background.\n */\nexport class KeyRingStore {\n  @observable\n  status: KeyRingStatus = KeyRingStatus.NOTLOADED;\n\n  @observable\n  multiKeyStoreInfo: MultiKeyStoreInfoWithSelected = [];\n\n  @observable.shallow\n  protected selectablesMap: Map<string, KeyRingSelectablesStore> = new Map();\n\n  protected keyStoreChangedListeners: (() => void)[] = [];\n\n  constructor(\n    protected readonly eventDispatcher: {\n      dispatchEvent: (type: string) => void;\n    },\n    public readonly defaultKdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    protected readonly chainGetter: ChainGetter,\n    protected readonly requester: MessageRequester,\n    protected readonly interactionStore: InteractionStore\n  ) {\n    makeObservable(this);\n\n    this.restore();\n  }\n\n  @computed\n  get keyRingType(): string {\n    const keyStore = this.multiKeyStoreInfo.find(\n      (keyStore) => keyStore.selected\n    );\n\n    if (!keyStore) {\n      return \"none\";\n    } else {\n      return KeyRing.getTypeOfKeyStore(keyStore);\n    }\n  }\n\n  @flow\n  *createMnemonicKey(\n    mnemonic: string,\n    password: string,\n    meta: Record<string, string>,\n    bip44HDPath: BIP44HDPath,\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\" = this.defaultKdf\n  ) {\n    const msg = new CreateMnemonicKeyMsg(\n      kdf,\n      mnemonic,\n      password,\n      meta,\n      bip44HDPath\n    );\n    const result = yield* toGenerator(\n      this.requester.sendMessage(BACKGROUND_PORT, msg)\n    );\n    this.status = result.status;\n    this.multiKeyStoreInfo = result.multiKeyStoreInfo;\n  }\n\n  @flow\n  *createPrivateKey(\n    privateKey: Uint8Array,\n    password: string,\n    meta: Record<string, string>,\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\" = this.defaultKdf\n  ) {\n    const msg = new CreatePrivateKeyMsg(kdf, privateKey, password, meta);\n    const result = yield* toGenerator(\n      this.requester.sendMessage(BACKGROUND_PORT, msg)\n    );\n    this.status = result.status;\n    this.multiKeyStoreInfo = result.multiKeyStoreInfo;\n  }\n\n  @flow\n  *createLedgerKey(\n    password: string,\n    meta: Record<string, string>,\n    bip44HDPath: BIP44HDPath,\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\" = this.defaultKdf\n  ) {\n    const msg = new CreateLedgerKeyMsg(kdf, password, meta, bip44HDPath);\n    const result = yield* toGenerator(\n      this.requester.sendMessage(BACKGROUND_PORT, msg)\n    );\n    this.status = result.status;\n    this.multiKeyStoreInfo = result.multiKeyStoreInfo;\n  }\n\n  @flow\n  *addMnemonicKey(\n    mnemonic: string,\n    meta: Record<string, string>,\n    bip44HDPath: BIP44HDPath,\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\" = this.defaultKdf\n  ) {\n    const msg = new AddMnemonicKeyMsg(kdf, mnemonic, meta, bip44HDPath);\n    this.multiKeyStoreInfo = (yield* toGenerator(\n      this.requester.sendMessage(BACKGROUND_PORT, msg)\n    )).multiKeyStoreInfo;\n  }\n\n  @flow\n  *addPrivateKey(\n    privateKey: Uint8Array,\n    meta: Record<string, string>,\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\" = this.defaultKdf\n  ) {\n    const msg = new AddPrivateKeyMsg(kdf, privateKey, meta);\n    this.multiKeyStoreInfo = (yield* toGenerator(\n      this.requester.sendMessage(BACKGROUND_PORT, msg)\n    )).multiKeyStoreInfo;\n  }\n\n  @flow\n  *addLedgerKey(\n    meta: Record<string, string>,\n    bip44HDPath: BIP44HDPath,\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\" = this.defaultKdf\n  ) {\n    const msg = new AddLedgerKeyMsg(kdf, meta, bip44HDPath);\n    this.multiKeyStoreInfo = (yield* toGenerator(\n      this.requester.sendMessage(BACKGROUND_PORT, msg)\n    )).multiKeyStoreInfo;\n  }\n\n  @flow\n  *changeKeyRing(index: number) {\n    const msg = new ChangeKeyRingMsg(index);\n    this.multiKeyStoreInfo = (yield* toGenerator(\n      this.requester.sendMessage(BACKGROUND_PORT, msg)\n    )).multiKeyStoreInfo;\n\n    // Emit the key store changed event manually.\n    this.dispatchKeyStoreChangeEvent();\n    this.selectablesMap.forEach((selectables) => selectables.refresh());\n  }\n\n  @flow\n  *lock() {\n    const msg = new LockKeyRingMsg();\n    const result = yield* toGenerator(\n      this.requester.sendMessage(BACKGROUND_PORT, msg)\n    );\n    this.status = result.status;\n  }\n\n  @flow\n  *unlock(password: string) {\n    const msg = new UnlockKeyRingMsg(password);\n    const result = yield* toGenerator(\n      this.requester.sendMessage(BACKGROUND_PORT, msg)\n    );\n    this.status = result.status;\n\n    // Approve all waiting interaction for the enabling key ring.\n    for (const interaction of this.interactionStore.getDatas(\"unlock\")) {\n      yield this.interactionStore.approve(\"unlock\", interaction.id, {});\n    }\n\n    this.dispatchKeyStoreChangeEvent();\n    this.selectablesMap.forEach((selectables) => selectables.refresh());\n  }\n\n  @flow\n  *rejectAll() {\n    yield this.interactionStore.rejectAll(\"unlock\");\n  }\n\n  @flow\n  protected *restore() {\n    const msg = new RestoreKeyRingMsg();\n    const result = yield* toGenerator(\n      this.requester.sendMessage(BACKGROUND_PORT, msg)\n    );\n    this.status = result.status;\n    this.multiKeyStoreInfo = result.multiKeyStoreInfo;\n  }\n\n  async showKeyRing(index: number, password: string) {\n    const msg = new ShowKeyRingMsg(index, password);\n    return await this.requester.sendMessage(BACKGROUND_PORT, msg);\n  }\n\n  @flow\n  *deleteKeyRing(index: number, password: string) {\n    const selectedIndex = this.multiKeyStoreInfo.findIndex(\n      (keyStore) => keyStore.selected\n    );\n    const msg = new DeleteKeyRingMsg(index, password);\n    const result = yield* toGenerator(\n      this.requester.sendMessage(BACKGROUND_PORT, msg)\n    );\n    this.status = result.status;\n    this.multiKeyStoreInfo = result.multiKeyStoreInfo;\n\n    // Selected keystore may be changed if the selected one is deleted.\n    if (selectedIndex === index) {\n      this.dispatchKeyStoreChangeEvent();\n      this.selectablesMap.forEach((selectables) => selectables.refresh());\n    }\n  }\n\n  @flow\n  *updateNameKeyRing(index: number, name: string) {\n    const msg = new UpdateNameKeyRingMsg(index, name);\n    const result = yield* toGenerator(\n      this.requester.sendMessage(BACKGROUND_PORT, msg)\n    );\n    this.multiKeyStoreInfo = result.multiKeyStoreInfo;\n    const selectedIndex = this.multiKeyStoreInfo.findIndex(\n      (keyStore) => keyStore.selected\n    );\n    // If selectedIndex and index are same, name could be changed, so dispatch keystore event\n    if (selectedIndex === index) {\n      this.dispatchKeyStoreChangeEvent();\n    }\n  }\n\n  async checkPassword(password: string): Promise<boolean> {\n    return await this.requester.sendMessage(\n      BACKGROUND_PORT,\n      new CheckPasswordMsg(password)\n    );\n  }\n\n  getKeyStoreSelectables(chainId: string): KeyRingSelectablesStore {\n    if (!this.selectablesMap.has(chainId)) {\n      runInAction(() => {\n        this.selectablesMap.set(\n          chainId,\n          new KeyRingSelectablesStore(\n            this.chainGetter,\n            this.requester,\n            chainId,\n            this\n          )\n        );\n      });\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.selectablesMap.get(chainId)!;\n  }\n\n  // Set the coin type to current key store.\n  // And, save it, refresh the key store.\n  @flow\n  *setKeyStoreCoinType(chainId: string, coinType: number) {\n    const status = yield* toGenerator(\n      this.requester.sendMessage(\n        BACKGROUND_PORT,\n        new SetKeyStoreCoinTypeMsg(chainId, coinType)\n      )\n    );\n\n    this.multiKeyStoreInfo = (yield* toGenerator(\n      this.requester.sendMessage(BACKGROUND_PORT, new GetMultiKeyStoreInfoMsg())\n    )).multiKeyStoreInfo;\n\n    this.status = status;\n\n    // Emit the key store changed event manually.\n    this.dispatchKeyStoreChangeEvent();\n    this.selectablesMap.forEach((selectables) => selectables.refresh());\n  }\n\n  async exportKeyRingDatas(password: string): Promise<ExportKeyRingData[]> {\n    return await this.requester.sendMessage(\n      BACKGROUND_PORT,\n      new ExportKeyRingDatasMsg(password)\n    );\n  }\n\n  protected dispatchKeyStoreChangeEvent() {\n    this.eventDispatcher.dispatchEvent(\"keplr_keystorechange\");\n\n    for (const listener of this.keyStoreChangedListeners) {\n      listener();\n    }\n  }\n\n  addKeyStoreChangedListener(listener: () => void) {\n    this.keyStoreChangedListeners.push(listener);\n  }\n\n  removeKeyStoreChangedListener(listener: () => void) {\n    const i = this.keyStoreChangedListeners.indexOf(listener);\n    if (i >= 0) {\n      this.keyStoreChangedListeners.splice(i, 1);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}