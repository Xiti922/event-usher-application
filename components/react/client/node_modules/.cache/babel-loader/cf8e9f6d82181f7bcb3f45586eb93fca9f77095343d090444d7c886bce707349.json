{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PhishingListService = void 0;\nconst axios_1 = __importDefault(require(\"axios\"));\nconst utils_1 = require(\"./utils\");\nclass PhishingListService {\n  constructor(opts) {\n    this.opts = opts;\n    this.map = new Map();\n    this._hasInited = false;\n    this._hasStopped = false;\n  }\n  get hasInited() {\n    return this._hasInited;\n  }\n  init() {\n    this.startFetchPhishingList();\n  }\n  stop() {\n    if (this.timeoutId != null) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = undefined;\n    }\n    this._hasStopped = true;\n  }\n  startFetchPhishingList() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.timeoutId != null) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = undefined;\n      }\n      if (this._hasStopped) {\n        return;\n      }\n      let failed = false;\n      try {\n        const res = yield axios_1.default.get(this.opts.blockListUrl);\n        const domains = res.data.split(/(\\r?\\n)|,|;|\\s|\\t/).filter(str => str != null).map(str => {\n          return str.trim();\n        }).filter(str => str.length > 0);\n        const map = new Map();\n        for (const domain of domains) {\n          try {\n            map.set(utils_1.parseDomainUntilSecondLevel(domain), true);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n        this._hasInited = true;\n        this.map = map;\n      } catch (e) {\n        failed = true;\n        console.log(e);\n      }\n      if (!this._hasStopped) {\n        this.timeoutId = setTimeout(() => {\n          this.startFetchPhishingList();\n        }, failed ? this.opts.retryIntervalMs : this.opts.fetchingIntervalMs);\n      }\n    });\n  }\n  checkURLIsPhishing(url) {\n    const parsed = new URL(url);\n    return this.map.get(utils_1.parseDomainUntilSecondLevel(parsed.origin)) === true;\n  }\n}\nexports.PhishingListService = PhishingListService;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA,MAAaA,mBAAmB;EAO9BC,YACkBC,IAIf;IAJe,SAAI,GAAJA,IAAI;IAPZ,QAAG,GAAyB,IAAIC,GAAG,EAAE;IAErC,eAAU,GAAY,KAAK;IAC3B,gBAAW,GAAY,KAAK;EASnC;EAEH,IAAIC,SAAS;IACX,OAAO,IAAI,CAACC,UAAU;EACxB;EAEAC,IAAI;IACF,IAAI,CAACC,sBAAsB,EAAE;EAC/B;EAEAC,IAAI;IACF,IAAI,IAAI,CAACC,SAAS,IAAI,IAAI,EAAE;MAC1BC,YAAY,CAAC,IAAI,CAACD,SAAS,CAAC;MAC5B,IAAI,CAACA,SAAS,GAAGE,SAAS;;IAE5B,IAAI,CAACC,WAAW,GAAG,IAAI;EACzB;EAEML,sBAAsB;;MAC1B,IAAI,IAAI,CAACE,SAAS,IAAI,IAAI,EAAE;QAC1BC,YAAY,CAAC,IAAI,CAACD,SAAS,CAAC;QAC5B,IAAI,CAACA,SAAS,GAAGE,SAAS;;MAG5B,IAAI,IAAI,CAACC,WAAW,EAAE;QACpB;;MAGF,IAAIC,MAAM,GAAG,KAAK;MAClB,IAAI;QACF,MAAMC,GAAG,GAAG,MAAMC,eAAK,CAACC,GAAG,CAAS,IAAI,CAACd,IAAI,CAACe,YAAY,CAAC;QAE3D,MAAMC,OAAO,GAAGJ,GAAG,CAACK,IAAI,CACrBC,KAAK,CAAC,mBAAmB,CAAC,CAC1BC,MAAM,CAAEC,GAAG,IAAKA,GAAG,IAAI,IAAI,CAAC,CAC5BC,GAAG,CAAED,GAAG,IAAI;UACX,OAAOA,GAAG,CAACE,IAAI,EAAE;QACnB,CAAC,CAAC,CACDH,MAAM,CAAEC,GAAG,IAAKA,GAAG,CAACG,MAAM,GAAG,CAAC,CAAC;QAElC,MAAMF,GAAG,GAAG,IAAIpB,GAAG,EAAmB;QAEtC,KAAK,MAAMuB,MAAM,IAAIR,OAAO,EAAE;UAC5B,IAAI;YACFK,GAAG,CAACI,GAAG,CAACC,mCAA2B,CAACF,MAAM,CAAC,EAAE,IAAI,CAAC;WACnD,CAAC,OAAOG,CAAC,EAAE;YACVC,OAAO,CAACC,GAAG,CAACF,CAAC,CAAC;;;QAIlB,IAAI,CAACxB,UAAU,GAAG,IAAI;QACtB,IAAI,CAACkB,GAAG,GAAGA,GAAG;OACf,CAAC,OAAOM,CAAC,EAAE;QACVhB,MAAM,GAAG,IAAI;QACbiB,OAAO,CAACC,GAAG,CAACF,CAAC,CAAC;;MAGhB,IAAI,CAAC,IAAI,CAACjB,WAAW,EAAE;QACrB,IAAI,CAACH,SAAS,GAAGuB,UAAU,CACzB,MAAK;UACH,IAAI,CAACzB,sBAAsB,EAAE;QAC/B,CAAC,EACDM,MAAM,GAAG,IAAI,CAACX,IAAI,CAAC+B,eAAe,GAAG,IAAI,CAAC/B,IAAI,CAACgC,kBAAkB,CAClE;;IAEL,CAAC;;EAEDC,kBAAkB,CAACC,GAAW;IAC5B,MAAMC,MAAM,GAAG,IAAIC,GAAG,CAACF,GAAG,CAAC;IAC3B,OAAO,IAAI,CAACb,GAAG,CAACP,GAAG,CAACY,mCAA2B,CAACS,MAAM,CAACE,MAAM,CAAC,CAAC,KAAK,IAAI;EAC1E;;AAnFFC","names":["PhishingListService","constructor","opts","Map","hasInited","_hasInited","init","startFetchPhishingList","stop","timeoutId","clearTimeout","undefined","_hasStopped","failed","res","axios_1","get","blockListUrl","domains","data","split","filter","str","map","trim","length","domain","set","utils_1","e","console","log","setTimeout","retryIntervalMs","fetchingIntervalMs","checkURLIsPhishing","url","parsed","URL","origin","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/background/src/phishing-list/service.ts"],"sourcesContent":["import Axios from \"axios\";\nimport { parseDomainUntilSecondLevel } from \"./utils\";\n\nexport class PhishingListService {\n  protected map: Map<string, boolean> = new Map();\n\n  protected _hasInited: boolean = false;\n  protected _hasStopped: boolean = false;\n  protected timeoutId?: NodeJS.Timeout;\n\n  constructor(\n    public readonly opts: {\n      readonly blockListUrl: string;\n      readonly fetchingIntervalMs: number;\n      readonly retryIntervalMs: number;\n    }\n  ) {}\n\n  get hasInited(): boolean {\n    return this._hasInited;\n  }\n\n  init() {\n    this.startFetchPhishingList();\n  }\n\n  stop() {\n    if (this.timeoutId != null) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = undefined;\n    }\n    this._hasStopped = true;\n  }\n\n  async startFetchPhishingList() {\n    if (this.timeoutId != null) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = undefined;\n    }\n\n    if (this._hasStopped) {\n      return;\n    }\n\n    let failed = false;\n    try {\n      const res = await Axios.get<string>(this.opts.blockListUrl);\n\n      const domains = res.data\n        .split(/(\\r?\\n)|,|;|\\s|\\t/)\n        .filter((str) => str != null)\n        .map((str) => {\n          return str.trim();\n        })\n        .filter((str) => str.length > 0);\n\n      const map = new Map<string, boolean>();\n\n      for (const domain of domains) {\n        try {\n          map.set(parseDomainUntilSecondLevel(domain), true);\n        } catch (e) {\n          console.log(e);\n        }\n      }\n\n      this._hasInited = true;\n      this.map = map;\n    } catch (e) {\n      failed = true;\n      console.log(e);\n    }\n\n    if (!this._hasStopped) {\n      this.timeoutId = setTimeout(\n        () => {\n          this.startFetchPhishingList();\n        },\n        failed ? this.opts.retryIntervalMs : this.opts.fetchingIntervalMs\n      );\n    }\n  }\n\n  checkURLIsPhishing(url: string): boolean {\n    const parsed = new URL(url);\n    return this.map.get(parseDomainUntilSecondLevel(parsed.origin)) === true;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}