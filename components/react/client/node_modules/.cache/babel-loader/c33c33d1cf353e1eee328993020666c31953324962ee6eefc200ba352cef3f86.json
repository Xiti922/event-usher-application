{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DirectSecp256k1HdWallet = exports.extractKdfConfiguration = void 0;\nconst amino_1 = require(\"@cosmjs/amino\");\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst signing_1 = require(\"./signing\");\nconst wallet_1 = require(\"./wallet\");\nconst serializationTypeV1 = \"directsecp256k1hdwallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.\n */\nconst basicPasswordHashingOptions = {\n  algorithm: \"argon2id\",\n  params: {\n    outputLength: 32,\n    opsLimit: 24,\n    memLimitKib: 12 * 1024\n  }\n};\nfunction isDerivationJson(thing) {\n  if (!(0, utils_1.isNonNullObject)(thing)) return false;\n  if (typeof thing.hdPath !== \"string\") return false;\n  if (typeof thing.prefix !== \"string\") return false;\n  return true;\n}\nfunction extractKdfConfigurationV1(doc) {\n  return doc.kdf;\n}\nfunction extractKdfConfiguration(serialization) {\n  const root = JSON.parse(serialization);\n  if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n  switch (root.type) {\n    case serializationTypeV1:\n      return extractKdfConfigurationV1(root);\n    default:\n      throw new Error(\"Unsupported serialization type\");\n  }\n}\nexports.extractKdfConfiguration = extractKdfConfiguration;\nconst defaultOptions = {\n  bip39Password: \"\",\n  hdPaths: [(0, amino_1.makeCosmoshubPath)(0)],\n  prefix: \"cosmos\"\n};\n/** A wallet for protobuf based signing using SIGN_MODE_DIRECT */\nclass DirectSecp256k1HdWallet {\n  constructor(mnemonic, options) {\n    var _a, _b;\n    const prefix = (_a = options.prefix) !== null && _a !== void 0 ? _a : defaultOptions.prefix;\n    const hdPaths = (_b = options.hdPaths) !== null && _b !== void 0 ? _b : defaultOptions.hdPaths;\n    this.secret = mnemonic;\n    this.seed = options.seed;\n    this.accounts = hdPaths.map(hdPath => ({\n      hdPath: hdPath,\n      prefix: prefix\n    }));\n  }\n  /**\n   * Restores a wallet from the given BIP39 mnemonic.\n   *\n   * @param mnemonic Any valid English mnemonic.\n   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n  static async fromMnemonic(mnemonic) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n    const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);\n    return new DirectSecp256k1HdWallet(mnemonicChecked, {\n      ...options,\n      seed: seed\n    });\n  }\n  /**\n   * Generates a new wallet with a BIP39 mnemonic of the given length.\n   *\n   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n  static async generate() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const entropyLength = 4 * Math.floor(11 * length / 33);\n    const entropy = crypto_1.Random.getBytes(entropyLength);\n    const mnemonic = crypto_1.Bip39.encode(entropy);\n    return DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n  static async deserialize(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n    switch (root.type) {\n      case serializationTypeV1:\n        return DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password);\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n   */\n  static async deserializeWithEncryptionKey(serialization, encryptionKey) {\n    const root = JSON.parse(serialization);\n    if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n    const untypedRoot = root;\n    switch (untypedRoot.type) {\n      case serializationTypeV1:\n        {\n          const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n          const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));\n          const {\n            mnemonic,\n            accounts\n          } = decryptedDocument;\n          (0, utils_1.assert)(typeof mnemonic === \"string\");\n          if (!Array.isArray(accounts)) throw new Error(\"Property 'accounts' is not an array\");\n          if (!accounts.every(account => isDerivationJson(account))) {\n            throw new Error(\"Account is not in the correct format.\");\n          }\n          const firstPrefix = accounts[0].prefix;\n          if (!accounts.every(_ref => {\n            let {\n              prefix\n            } = _ref;\n            return prefix === firstPrefix;\n          })) {\n            throw new Error(\"Accounts do not all have the same prefix\");\n          }\n          const hdPaths = accounts.map(_ref2 => {\n            let {\n              hdPath\n            } = _ref2;\n            return (0, crypto_1.stringToPath)(hdPath);\n          });\n          return DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {\n            hdPaths: hdPaths,\n            prefix: firstPrefix\n          });\n        }\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n  static async deserializeTypeV1(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n    const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);\n    return DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);\n  }\n  get mnemonic() {\n    return this.secret.toString();\n  }\n  async getAccounts() {\n    const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();\n    return accountsWithPrivkeys.map(_ref3 => {\n      let {\n        algo,\n        pubkey,\n        address\n      } = _ref3;\n      return {\n        algo: algo,\n        pubkey: pubkey,\n        address: address\n      };\n    });\n  }\n  async signDirect(signerAddress, signDoc) {\n    const accounts = await this.getAccountsWithPrivkeys();\n    const account = accounts.find(_ref4 => {\n      let {\n        address\n      } = _ref4;\n      return address === signerAddress;\n    });\n    if (account === undefined) {\n      throw new Error(`Address ${signerAddress} not found in wallet`);\n    }\n    const {\n      privkey,\n      pubkey\n    } = account;\n    const signBytes = (0, signing_1.makeSignBytes)(signDoc);\n    const hashedMessage = (0, crypto_1.sha256)(signBytes);\n    const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, privkey);\n    const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);\n    const stdSignature = (0, amino_1.encodeSecp256k1Signature)(pubkey, signatureBytes);\n    return {\n      signed: signDoc,\n      signature: stdSignature\n    };\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n  async serialize(password) {\n    const kdfConfiguration = basicPasswordHashingOptions;\n    const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);\n    return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n   * is not the case, the wallet cannot be restored with the original password.\n   */\n  async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {\n    const dataToEncrypt = {\n      mnemonic: this.mnemonic,\n      accounts: this.accounts.map(_ref5 => {\n        let {\n          hdPath,\n          prefix\n        } = _ref5;\n        return {\n          hdPath: (0, crypto_1.pathToString)(hdPath),\n          prefix: prefix\n        };\n      })\n    };\n    const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));\n    const encryptionConfiguration = {\n      algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf\n    };\n    const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n    const out = {\n      type: serializationTypeV1,\n      kdf: kdfConfiguration,\n      encryption: encryptionConfiguration,\n      data: (0, encoding_1.toBase64)(encryptedData)\n    };\n    return JSON.stringify(out);\n  }\n  async getKeyPair(hdPath) {\n    const {\n      privkey\n    } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);\n    const {\n      pubkey\n    } = await crypto_1.Secp256k1.makeKeypair(privkey);\n    return {\n      privkey: privkey,\n      pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)\n    };\n  }\n  async getAccountsWithPrivkeys() {\n    return Promise.all(this.accounts.map(async _ref6 => {\n      let {\n        hdPath,\n        prefix\n      } = _ref6;\n      const {\n        privkey,\n        pubkey\n      } = await this.getKeyPair(hdPath);\n      const address = (0, encoding_1.toBech32)(prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(pubkey));\n      return {\n        algo: \"secp256k1\",\n        privkey: privkey,\n        pubkey: pubkey,\n        address: address\n      };\n    }));\n  }\n}\nexports.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;","map":{"version":3,"mappings":"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","names":["serializationTypeV1","basicPasswordHashingOptions","algorithm","params","outputLength","opsLimit","memLimitKib","isDerivationJson","thing","hdPath","prefix","extractKdfConfigurationV1","doc","kdf","extractKdfConfiguration","serialization","root","JSON","parse","Error","type","exports","defaultOptions","bip39Password","hdPaths","DirectSecp256k1HdWallet","constructor","mnemonic","options","secret","seed","accounts","map","fromMnemonic","mnemonicChecked","crypto_1","mnemonicToSeed","generate","length","entropyLength","Math","floor","entropy","getBytes","encode","toString","deserialize","password","deserializeTypeV1","deserializeWithEncryptionKey","encryptionKey","untypedRoot","decryptedBytes","data","encryption","decryptedDocument","Array","isArray","every","account","firstPrefix","getAccounts","accountsWithPrivkeys","getAccountsWithPrivkeys","algo","pubkey","address","signDirect","signerAddress","signDoc","find","undefined","privkey","signBytes","hashedMessage","signature","createSignature","signatureBytes","Uint8Array","r","s","stdSignature","signed","serialize","kdfConfiguration","serializeWithEncryptionKey","dataToEncrypt","dataToEncryptRaw","stringify","encryptionConfiguration","wallet_1","xchacha20poly1305Ietf","encryptedData","out","getKeyPair","derivePath","Secp256k1","makeKeypair","compressPubkey","Promise","all"],"sources":["../src/directsecp256k1hdwallet.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}