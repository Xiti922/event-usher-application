{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableQueryUnbondingDelegations = exports.ObservableQueryUnbondingDelegationsInner = void 0;\nconst chain_query_1 = require(\"../../chain-query\");\nconst unit_1 = require(\"@keplr-wallet/unit\");\nconst mobx_1 = require(\"mobx\");\nclass ObservableQueryUnbondingDelegationsInner extends chain_query_1.ObservableChainQuery {\n  constructor(kvStore, chainId, chainGetter, bech32Address) {\n    super(kvStore, chainId, chainGetter, `/cosmos/staking/v1beta1/delegators/${bech32Address}/unbonding_delegations?pagination.limit=1000`);\n    mobx_1.makeObservable(this);\n    this.bech32Address = bech32Address;\n  }\n  canFetch() {\n    // If bech32 address is empty, it will always fail, so don't need to fetch it.\n    return this.bech32Address.length > 0;\n  }\n  get total() {\n    const stakeCurrency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n    if (!this.response) {\n      return new unit_1.CoinPretty(stakeCurrency, new unit_1.Int(0)).ready(false);\n    }\n    let totalBalance = new unit_1.Int(0);\n    for (const unbondingDelegation of this.response.data.unbonding_responses) {\n      for (const entry of unbondingDelegation.entries) {\n        totalBalance = totalBalance.add(new unit_1.Int(entry.balance));\n      }\n    }\n    return new unit_1.CoinPretty(stakeCurrency, totalBalance);\n  }\n  get unbondingBalances() {\n    const unbondings = this.unbondings;\n    const stakeCurrency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n    const result = [];\n    for (const unbonding of unbondings) {\n      const entries = [];\n      for (const entry of unbonding.entries) {\n        entries.push({\n          creationHeight: new unit_1.Int(entry.creation_height),\n          completionTime: entry.completion_time,\n          balance: new unit_1.CoinPretty(stakeCurrency, new unit_1.Int(entry.balance))\n        });\n      }\n      result.push({\n        validatorAddress: unbonding.validator_address,\n        entries\n      });\n    }\n    return result;\n  }\n  get unbondings() {\n    if (!this.response) {\n      return [];\n    }\n    return this.response.data.unbonding_responses;\n  }\n}\n__decorate([mobx_1.computed], ObservableQueryUnbondingDelegationsInner.prototype, \"total\", null);\n__decorate([mobx_1.computed], ObservableQueryUnbondingDelegationsInner.prototype, \"unbondingBalances\", null);\n__decorate([mobx_1.computed], ObservableQueryUnbondingDelegationsInner.prototype, \"unbondings\", null);\nexports.ObservableQueryUnbondingDelegationsInner = ObservableQueryUnbondingDelegationsInner;\nclass ObservableQueryUnbondingDelegations extends chain_query_1.ObservableChainQueryMap {\n  constructor(kvStore, chainId, chainGetter) {\n    super(kvStore, chainId, chainGetter, bech32Address => {\n      return new ObservableQueryUnbondingDelegationsInner(this.kvStore, this.chainId, this.chainGetter, bech32Address);\n    });\n    this.kvStore = kvStore;\n    this.chainId = chainId;\n    this.chainGetter = chainGetter;\n  }\n  getQueryBech32Address(bech32Address) {\n    return this.get(bech32Address);\n  }\n}\nexports.ObservableQueryUnbondingDelegations = ObservableQueryUnbondingDelegations;","map":{"version":3,"mappings":"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","names":["ObservableQueryUnbondingDelegationsInner","chain_query_1","constructor","kvStore","chainId","chainGetter","bech32Address","mobx_1","canFetch","length","total","stakeCurrency","getChain","response","unit_1","ready","totalBalance","unbondingDelegation","data","unbonding_responses","entry","entries","add","balance","unbondingBalances","unbondings","result","unbonding","push","creationHeight","creation_height","completionTime","completion_time","validatorAddress","validator_address","__decorate","exports","ObservableQueryUnbondingDelegations","getQueryBech32Address","get"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/query/cosmos/staking/unbonding-delegations.ts"],"sourcesContent":["import {\n  ObservableChainQuery,\n  ObservableChainQueryMap,\n} from \"../../chain-query\";\nimport { UnbondingDelegation, UnbondingDelegations } from \"./types\";\nimport { KVStore } from \"@keplr-wallet/common\";\nimport { ChainGetter } from \"../../../common\";\nimport { CoinPretty, Int } from \"@keplr-wallet/unit\";\nimport { computed, makeObservable } from \"mobx\";\n\nexport class ObservableQueryUnbondingDelegationsInner extends ObservableChainQuery<UnbondingDelegations> {\n  protected bech32Address: string;\n\n  constructor(\n    kvStore: KVStore,\n    chainId: string,\n    chainGetter: ChainGetter,\n    bech32Address: string\n  ) {\n    super(\n      kvStore,\n      chainId,\n      chainGetter,\n      `/cosmos/staking/v1beta1/delegators/${bech32Address}/unbonding_delegations?pagination.limit=1000`\n    );\n    makeObservable(this);\n\n    this.bech32Address = bech32Address;\n  }\n\n  protected canFetch(): boolean {\n    // If bech32 address is empty, it will always fail, so don't need to fetch it.\n    return this.bech32Address.length > 0;\n  }\n\n  @computed\n  get total(): CoinPretty {\n    const stakeCurrency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n\n    if (!this.response) {\n      return new CoinPretty(stakeCurrency, new Int(0)).ready(false);\n    }\n\n    let totalBalance = new Int(0);\n    for (const unbondingDelegation of this.response.data.unbonding_responses) {\n      for (const entry of unbondingDelegation.entries) {\n        totalBalance = totalBalance.add(new Int(entry.balance));\n      }\n    }\n\n    return new CoinPretty(stakeCurrency, totalBalance);\n  }\n\n  @computed\n  get unbondingBalances(): {\n    validatorAddress: string;\n    entries: {\n      creationHeight: Int;\n      completionTime: string;\n      balance: CoinPretty;\n    }[];\n  }[] {\n    const unbondings = this.unbondings;\n\n    const stakeCurrency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n\n    const result = [];\n    for (const unbonding of unbondings) {\n      const entries = [];\n      for (const entry of unbonding.entries) {\n        entries.push({\n          creationHeight: new Int(entry.creation_height),\n          completionTime: entry.completion_time,\n          balance: new CoinPretty(stakeCurrency, new Int(entry.balance)),\n        });\n      }\n\n      result.push({\n        validatorAddress: unbonding.validator_address,\n        entries,\n      });\n    }\n\n    return result;\n  }\n\n  @computed\n  get unbondings(): UnbondingDelegation[] {\n    if (!this.response) {\n      return [];\n    }\n\n    return this.response.data.unbonding_responses;\n  }\n}\n\nexport class ObservableQueryUnbondingDelegations extends ObservableChainQueryMap<UnbondingDelegations> {\n  constructor(\n    protected readonly kvStore: KVStore,\n    protected readonly chainId: string,\n    protected readonly chainGetter: ChainGetter\n  ) {\n    super(kvStore, chainId, chainGetter, (bech32Address: string) => {\n      return new ObservableQueryUnbondingDelegationsInner(\n        this.kvStore,\n        this.chainId,\n        this.chainGetter,\n        bech32Address\n      );\n    });\n  }\n\n  getQueryBech32Address(\n    bech32Address: string\n  ): ObservableQueryUnbondingDelegationsInner {\n    return this.get(bech32Address) as ObservableQueryUnbondingDelegationsInner;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}