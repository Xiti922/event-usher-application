{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableQueryInflation = void 0;\nconst mobx_1 = require(\"mobx\");\nconst unit_1 = require(\"@keplr-wallet/unit\");\nclass ObservableQueryInflation {\n  constructor(chainId, chainGetter, _queryMint, _queryPool, _querySupplyTotal, _queryIrisMint, _querySifchainAPY, _queryOsmosisEpochs, _queryOsmosisEpochProvisions, _queryOsmosisMintParams, _queryJunoAnnualProvisions, _queryDistributionParams) {\n    this.chainId = chainId;\n    this.chainGetter = chainGetter;\n    this._queryMint = _queryMint;\n    this._queryPool = _queryPool;\n    this._querySupplyTotal = _querySupplyTotal;\n    this._queryIrisMint = _queryIrisMint;\n    this._querySifchainAPY = _querySifchainAPY;\n    this._queryOsmosisEpochs = _queryOsmosisEpochs;\n    this._queryOsmosisEpochProvisions = _queryOsmosisEpochProvisions;\n    this._queryOsmosisMintParams = _queryOsmosisMintParams;\n    this._queryJunoAnnualProvisions = _queryJunoAnnualProvisions;\n    this._queryDistributionParams = _queryDistributionParams;\n    mobx_1.makeObservable(this);\n  }\n  get error() {\n    var _a, _b;\n    return (_b = (_a = this._queryMint.error) !== null && _a !== void 0 ? _a : this._queryPool.error) !== null && _b !== void 0 ? _b : this._querySupplyTotal.getQueryStakeDenom().error;\n  }\n  get isFetching() {\n    return this._queryMint.isFetching || this._queryPool.isFetching || this._querySupplyTotal.getQueryStakeDenom().isFetching;\n  }\n  // Return an inflation as `IntPrety`.\n  // If the staking pool info is fetched, this will consider this info for calculating the more accurate value.\n  get inflation() {\n    // TODO: Use `RatePretty`\n    var _a, _b, _c, _d;\n    try {\n      let dec;\n      // XXX: Hard coded part for the iris hub and sifchain.\n      // TODO: Remove this part.\n      const chainInfo = this.chainGetter.getChain(this.chainId);\n      if (chainInfo.chainId.startsWith(\"irishub\")) {\n        dec = new unit_1.Dec((_b = (_a = this._queryIrisMint.response) === null || _a === void 0 ? void 0 : _a.data.result.inflation) !== null && _b !== void 0 ? _b : \"0\").mul(unit_1.DecUtils.getPrecisionDec(2));\n      } else if (chainInfo.chainId.startsWith(\"sifchain\")) {\n        return new unit_1.IntPretty(new unit_1.Dec(this._querySifchainAPY.liquidityAPY.toString()));\n      } else if (chainInfo.chainId.startsWith(\"osmosis\")) {\n        /*\n          XXX: Temporary and unfinished implementation for the osmosis staking APY.\n               Osmosis has different minting method.\n               It mints the fixed token per epoch with deduction feature on the range of epoch.\n               And, it actually doesn't mint the token, it has the locked token that will be inflated.\n               So, currently, using the result of `supply total` to calculate the APY is actually not valid\n               because it included the locked token that is not yet inflated.\n               So, for now, just assume that the curreny supply is 100,000,000.\n         */\n        const mintParams = this._queryOsmosisMintParams;\n        if (mintParams.epochIdentifier) {\n          const epochDuration = this._queryOsmosisEpochs.getEpoch(mintParams.epochIdentifier).duration;\n          if (epochDuration) {\n            const epochProvision = this._queryOsmosisEpochProvisions.epochProvisions;\n            if (epochProvision && this._querySupplyTotal.getQueryStakeDenom().response) {\n              const mintingEpochProvision = new unit_1.Dec(epochProvision.toDec().mul(mintParams.distributionProportions.staking).truncate().toString());\n              const yearMintingProvision = mintingEpochProvision.mul(new unit_1.Dec((365 * 24 * 3600 / epochDuration).toString()));\n              const total = unit_1.DecUtils.getPrecisionDec(8);\n              dec = yearMintingProvision.quo(total).mul(unit_1.DecUtils.getPrecisionDec(2));\n            }\n          }\n        }\n      } else if (chainInfo.chainId.startsWith(\"juno\")) {\n        // In juno, the actual supply on chain and the supply recognized by the community are different.\n        // I don't know why, but it's annoying to deal with this problem.\n        if (this._queryJunoAnnualProvisions.annualProvisionsRaw && this._queryPool.response) {\n          const bondedToken = new unit_1.Dec(this._queryPool.response.data.pool.bonded_tokens);\n          const dec = this._queryJunoAnnualProvisions.annualProvisionsRaw.quo(bondedToken).mul(new unit_1.Dec(1).sub(this._queryDistributionParams.communityTax.toDec())).mul(unit_1.DecUtils.getTenExponentN(2));\n          return new unit_1.IntPretty(dec);\n        }\n      } else {\n        dec = new unit_1.Dec((_d = (_c = this._queryMint.response) === null || _c === void 0 ? void 0 : _c.data.inflation) !== null && _d !== void 0 ? _d : \"0\").mul(unit_1.DecUtils.getPrecisionDec(2));\n      }\n      if (!dec || dec.equals(new unit_1.Dec(0))) {\n        return new unit_1.IntPretty(new unit_1.Int(0)).ready(false);\n      }\n      if (this._queryPool.response && this._querySupplyTotal.getQueryStakeDenom().response) {\n        const bondedToken = new unit_1.Dec(this._queryPool.response.data.pool.bonded_tokens);\n        const totalStr = (() => {\n          if (chainInfo.chainId.startsWith(\"osmosis\")) {\n            // For osmosis, for now, just assume that the current supply is 100,000,000 with 6 decimals.\n            return unit_1.DecUtils.getPrecisionDec(8 + 6).toString();\n          }\n          return this._querySupplyTotal.getQueryStakeDenom().response.data.amount.amount;\n        })();\n        const total = new unit_1.Dec(totalStr);\n        if (total.gt(new unit_1.Dec(0))) {\n          // staking APR is calculated as:\n          //   new_coins_per_year = inflation_pct * total_supply * (1 - community_pool_tax)\n          //   apr = new_coins_per_year / total_bonded_tokens\n          const ratio = bondedToken.quo(total);\n          dec = dec.mul(new unit_1.Dec(1).sub(this._queryDistributionParams.communityTax.toDec())).quo(ratio);\n          // TODO: Rounding?\n        }\n      }\n\n      return new unit_1.IntPretty(dec);\n    } catch (e) {\n      console.log(e);\n      // XXX: There have been reported errors regarding Sifchain.\n      // However, I wasn’t able to reproduce the error so exact cause haven’t been identified.\n      // For now, use try-catch on suspect parts to resolve the issue. Will be on a lookout for a more permanent solution in the future.\n      return new unit_1.IntPretty(new unit_1.Int(0)).ready(false);\n    }\n  }\n}\n__decorate([mobx_1.computed], ObservableQueryInflation.prototype, \"inflation\", null);\nexports.ObservableQueryInflation = ObservableQueryInflation;","map":{"version":3,"mappings":"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","names":["ObservableQueryInflation","constructor","chainId","chainGetter","_queryMint","_queryPool","_querySupplyTotal","_queryIrisMint","_querySifchainAPY","_queryOsmosisEpochs","_queryOsmosisEpochProvisions","_queryOsmosisMintParams","_queryJunoAnnualProvisions","_queryDistributionParams","mobx_1","error","getQueryStakeDenom","isFetching","inflation","dec","chainInfo","getChain","startsWith","unit_1","response","data","result","mul","getPrecisionDec","liquidityAPY","toString","mintParams","epochIdentifier","epochDuration","getEpoch","duration","epochProvision","epochProvisions","mintingEpochProvision","toDec","distributionProportions","staking","truncate","yearMintingProvision","total","quo","annualProvisionsRaw","bondedToken","pool","bonded_tokens","sub","communityTax","getTenExponentN","equals","ready","totalStr","amount","gt","ratio","e","console","log","__decorate","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/query/cosmos/supply/inflation.ts"],"sourcesContent":["import { computed, makeObservable } from \"mobx\";\nimport { Dec, DecUtils, Int, IntPretty } from \"@keplr-wallet/unit\";\nimport { ObservableQuerySupplyTotal } from \"./supply\";\nimport { MintingInflation } from \"./types\";\nimport { ObservableChainQuery } from \"../../chain-query\";\nimport { ChainGetter } from \"../../../common\";\nimport { ObservableQueryIrisMintingInfation } from \"./iris-minting\";\nimport { ObservableQuerySifchainLiquidityAPY } from \"./sifchain\";\nimport {\n  ObservableQueryOsmosisEpochProvisions,\n  ObservableQueryOsmosisEpochs,\n  ObservableQueryOsmosisMintParmas,\n} from \"./osmosis\";\nimport { ObservableQueryDistributionParams } from \"../distribution\";\nimport { ObservableQueryStakingPool } from \"../staking\";\nimport { ObservableQueryJunoAnnualProvisions } from \"./juno/annual-provisions\";\n\nexport class ObservableQueryInflation {\n  constructor(\n    protected readonly chainId: string,\n    protected readonly chainGetter: ChainGetter,\n    protected readonly _queryMint: ObservableChainQuery<MintingInflation>,\n    protected readonly _queryPool: ObservableQueryStakingPool,\n    protected readonly _querySupplyTotal: ObservableQuerySupplyTotal,\n    protected readonly _queryIrisMint: ObservableQueryIrisMintingInfation,\n    protected readonly _querySifchainAPY: ObservableQuerySifchainLiquidityAPY,\n    protected readonly _queryOsmosisEpochs: ObservableQueryOsmosisEpochs,\n    protected readonly _queryOsmosisEpochProvisions: ObservableQueryOsmosisEpochProvisions,\n    protected readonly _queryOsmosisMintParams: ObservableQueryOsmosisMintParmas,\n    protected readonly _queryJunoAnnualProvisions: ObservableQueryJunoAnnualProvisions,\n    protected readonly _queryDistributionParams: ObservableQueryDistributionParams\n  ) {\n    makeObservable(this);\n  }\n\n  get error() {\n    return (\n      this._queryMint.error ??\n      this._queryPool.error ??\n      this._querySupplyTotal.getQueryStakeDenom().error\n    );\n  }\n\n  get isFetching() {\n    return (\n      this._queryMint.isFetching ||\n      this._queryPool.isFetching ||\n      this._querySupplyTotal.getQueryStakeDenom().isFetching\n    );\n  }\n\n  // Return an inflation as `IntPrety`.\n  // If the staking pool info is fetched, this will consider this info for calculating the more accurate value.\n  @computed\n  get inflation(): IntPretty {\n    // TODO: Use `RatePretty`\n\n    try {\n      let dec: Dec | undefined;\n\n      // XXX: Hard coded part for the iris hub and sifchain.\n      // TODO: Remove this part.\n      const chainInfo = this.chainGetter.getChain(this.chainId);\n      if (chainInfo.chainId.startsWith(\"irishub\")) {\n        dec = new Dec(\n          this._queryIrisMint.response?.data.result.inflation ?? \"0\"\n        ).mul(DecUtils.getPrecisionDec(2));\n      } else if (chainInfo.chainId.startsWith(\"sifchain\")) {\n        return new IntPretty(\n          new Dec(this._querySifchainAPY.liquidityAPY.toString())\n        );\n      } else if (chainInfo.chainId.startsWith(\"osmosis\")) {\n        /*\n          XXX: Temporary and unfinished implementation for the osmosis staking APY.\n               Osmosis has different minting method.\n               It mints the fixed token per epoch with deduction feature on the range of epoch.\n               And, it actually doesn't mint the token, it has the locked token that will be inflated.\n               So, currently, using the result of `supply total` to calculate the APY is actually not valid\n               because it included the locked token that is not yet inflated.\n               So, for now, just assume that the curreny supply is 100,000,000.\n         */\n        const mintParams = this._queryOsmosisMintParams;\n        if (mintParams.epochIdentifier) {\n          const epochDuration = this._queryOsmosisEpochs.getEpoch(\n            mintParams.epochIdentifier\n          ).duration;\n          if (epochDuration) {\n            const epochProvision = this._queryOsmosisEpochProvisions\n              .epochProvisions;\n            if (\n              epochProvision &&\n              this._querySupplyTotal.getQueryStakeDenom().response\n            ) {\n              const mintingEpochProvision = new Dec(\n                epochProvision\n                  .toDec()\n                  .mul(mintParams.distributionProportions.staking)\n                  .truncate()\n                  .toString()\n              );\n              const yearMintingProvision = mintingEpochProvision.mul(\n                new Dec(((365 * 24 * 3600) / epochDuration).toString())\n              );\n              const total = DecUtils.getPrecisionDec(8);\n              dec = yearMintingProvision\n                .quo(total)\n                .mul(DecUtils.getPrecisionDec(2));\n            }\n          }\n        }\n      } else if (chainInfo.chainId.startsWith(\"juno\")) {\n        // In juno, the actual supply on chain and the supply recognized by the community are different.\n        // I don't know why, but it's annoying to deal with this problem.\n        if (\n          this._queryJunoAnnualProvisions.annualProvisionsRaw &&\n          this._queryPool.response\n        ) {\n          const bondedToken = new Dec(\n            this._queryPool.response.data.pool.bonded_tokens\n          );\n\n          const dec = this._queryJunoAnnualProvisions.annualProvisionsRaw\n            .quo(bondedToken)\n            .mul(\n              new Dec(1).sub(this._queryDistributionParams.communityTax.toDec())\n            )\n            .mul(DecUtils.getTenExponentN(2));\n\n          return new IntPretty(dec);\n        }\n      } else {\n        dec = new Dec(this._queryMint.response?.data.inflation ?? \"0\").mul(\n          DecUtils.getPrecisionDec(2)\n        );\n      }\n\n      if (!dec || dec.equals(new Dec(0))) {\n        return new IntPretty(new Int(0)).ready(false);\n      }\n\n      if (\n        this._queryPool.response &&\n        this._querySupplyTotal.getQueryStakeDenom().response\n      ) {\n        const bondedToken = new Dec(\n          this._queryPool.response.data.pool.bonded_tokens\n        );\n\n        const totalStr = (() => {\n          if (chainInfo.chainId.startsWith(\"osmosis\")) {\n            // For osmosis, for now, just assume that the current supply is 100,000,000 with 6 decimals.\n            return DecUtils.getPrecisionDec(8 + 6).toString();\n          }\n\n          return this._querySupplyTotal.getQueryStakeDenom().response!.data\n            .amount.amount;\n        })();\n        const total = new Dec(totalStr);\n        if (total.gt(new Dec(0))) {\n          // staking APR is calculated as:\n          //   new_coins_per_year = inflation_pct * total_supply * (1 - community_pool_tax)\n          //   apr = new_coins_per_year / total_bonded_tokens\n\n          const ratio = bondedToken.quo(total);\n          dec = dec\n            .mul(\n              new Dec(1).sub(this._queryDistributionParams.communityTax.toDec())\n            )\n            .quo(ratio);\n          // TODO: Rounding?\n        }\n      }\n\n      return new IntPretty(dec);\n    } catch (e) {\n      console.log(e);\n      // XXX: There have been reported errors regarding Sifchain.\n      // However, I wasn’t able to reproduce the error so exact cause haven’t been identified.\n      // For now, use try-catch on suspect parts to resolve the issue. Will be on a lookout for a more permanent solution in the future.\n\n      return new IntPretty(new Int(0)).ready(false);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}