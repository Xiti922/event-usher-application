{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getHandler = void 0;\nconst router_1 = require(\"@keplr-wallet/router\");\nconst messages_1 = require(\"./messages\");\nconst getHandler = service => {\n  return (env, msg) => {\n    switch (msg.constructor) {\n      case messages_1.GetPubkeyMsg:\n        return handleGetPubkeyMsg(service)(env, msg);\n      case messages_1.ReqeustEncryptMsg:\n        return handleReqeustEncryptMsg(service)(env, msg);\n      case messages_1.RequestDecryptMsg:\n        return handleRequestDecryptMsg(service)(env, msg);\n      case messages_1.GetTxEncryptionKeyMsg:\n        return handleGetTxEncryptionKeyMsg(service)(env, msg);\n      default:\n        throw new router_1.KeplrError(\"secret-wasm\", 120, \"Unknown msg type\");\n    }\n  };\n};\nexports.getHandler = getHandler;\nconst handleGetPubkeyMsg = service => {\n  return (env, msg) => __awaiter(void 0, void 0, void 0, function* () {\n    yield service.permissionService.checkOrGrantBasicAccessPermission(env, msg.chainId, msg.origin);\n    return yield service.getPubkey(env, msg.chainId);\n  });\n};\nconst handleReqeustEncryptMsg = service => {\n  return (env, msg) => __awaiter(void 0, void 0, void 0, function* () {\n    yield service.permissionService.checkOrGrantBasicAccessPermission(env, msg.chainId, msg.origin);\n    // TODO: Should ask for user whether approve or reject to encrypt.\n    return yield service.encrypt(env, msg.chainId, msg.contractCodeHash, msg.msg);\n  });\n};\nconst handleRequestDecryptMsg = service => {\n  return (env, msg) => __awaiter(void 0, void 0, void 0, function* () {\n    yield service.permissionService.checkOrGrantBasicAccessPermission(env, msg.chainId, msg.origin);\n    // XXX: Is there need to ask for user whether approve or reject to decrypt?\n    return yield service.decrypt(env, msg.chainId, msg.cipherText, msg.nonce);\n  });\n};\nconst handleGetTxEncryptionKeyMsg = service => {\n  return (env, msg) => __awaiter(void 0, void 0, void 0, function* () {\n    yield service.permissionService.checkOrGrantBasicAccessPermission(env, msg.chainId, msg.origin);\n    // XXX: Is there need to ask for user whether approve or reject to getting tx encryption key?\n    return yield service.getTxEncryptionKey(env, msg.chainId, msg.nonce);\n  });\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAOA;AAQO,MAAMA,UAAU,GACrBC,OAA0B,IACxB;EACF,OAAO,CAACC,GAAQ,EAAEC,GAAqB,KAAI;IACzC,QAAQA,GAAG,CAACC,WAAW;MACrB,KAAKC,uBAAY;QACf,OAAOC,kBAAkB,CAACL,OAAO,CAAC,CAACC,GAAG,EAAEC,GAAmB,CAAC;MAC9D,KAAKE,4BAAiB;QACpB,OAAOE,uBAAuB,CAACN,OAAO,CAAC,CAACC,GAAG,EAAEC,GAAwB,CAAC;MACxE,KAAKE,4BAAiB;QACpB,OAAOG,uBAAuB,CAACP,OAAO,CAAC,CAACC,GAAG,EAAEC,GAAwB,CAAC;MACxE,KAAKE,gCAAqB;QACxB,OAAOI,2BAA2B,CAACR,OAAO,CAAC,CACzCC,GAAG,EACHC,GAA4B,CAC7B;MACH;QACE,MAAM,IAAIO,mBAAU,CAAC,aAAa,EAAE,GAAG,EAAE,kBAAkB,CAAC;IAAC;EAEnE,CAAC;AACH,CAAC;AApBYC,kBAAU;AAsBvB,MAAML,kBAAkB,GAEcL,OAAO,IAAI;EAC/C,OAAO,CAAOC,GAAG,EAAEC,GAAG,KAAIS;IACxB,MAAMX,OAAO,CAACY,iBAAiB,CAACC,iCAAiC,CAC/DZ,GAAG,EACHC,GAAG,CAACY,OAAO,EACXZ,GAAG,CAACa,MAAM,CACX;IAED,OAAO,MAAMf,OAAO,CAACgB,SAAS,CAACf,GAAG,EAAEC,GAAG,CAACY,OAAO,CAAC;EAClD,CAAC;AACH,CAAC;AAED,MAAMR,uBAAuB,GAEcN,OAAO,IAAI;EACpD,OAAO,CAAOC,GAAG,EAAEC,GAAG,KAAIS;IACxB,MAAMX,OAAO,CAACY,iBAAiB,CAACC,iCAAiC,CAC/DZ,GAAG,EACHC,GAAG,CAACY,OAAO,EACXZ,GAAG,CAACa,MAAM,CACX;IAED;IACA,OAAO,MAAMf,OAAO,CAACiB,OAAO,CAC1BhB,GAAG,EACHC,GAAG,CAACY,OAAO,EACXZ,GAAG,CAACgB,gBAAgB,EACpBhB,GAAG,CAACA,GAAG,CACR;EACH,CAAC;AACH,CAAC;AAED,MAAMK,uBAAuB,GAEcP,OAAO,IAAI;EACpD,OAAO,CAAOC,GAAG,EAAEC,GAAG,KAAIS;IACxB,MAAMX,OAAO,CAACY,iBAAiB,CAACC,iCAAiC,CAC/DZ,GAAG,EACHC,GAAG,CAACY,OAAO,EACXZ,GAAG,CAACa,MAAM,CACX;IAED;IACA,OAAO,MAAMf,OAAO,CAACmB,OAAO,CAAClB,GAAG,EAAEC,GAAG,CAACY,OAAO,EAAEZ,GAAG,CAACkB,UAAU,EAAElB,GAAG,CAACmB,KAAK,CAAC;EAC3E,CAAC;AACH,CAAC;AAED,MAAMb,2BAA2B,GAEcR,OAAO,IAAI;EACxD,OAAO,CAAOC,GAAG,EAAEC,GAAG,KAAIS;IACxB,MAAMX,OAAO,CAACY,iBAAiB,CAACC,iCAAiC,CAC/DZ,GAAG,EACHC,GAAG,CAACY,OAAO,EACXZ,GAAG,CAACa,MAAM,CACX;IAED;IACA,OAAO,MAAMf,OAAO,CAACsB,kBAAkB,CAACrB,GAAG,EAAEC,GAAG,CAACY,OAAO,EAAEZ,GAAG,CAACmB,KAAK,CAAC;EACtE,CAAC;AACH,CAAC","names":["getHandler","service","env","msg","constructor","messages_1","handleGetPubkeyMsg","handleReqeustEncryptMsg","handleRequestDecryptMsg","handleGetTxEncryptionKeyMsg","router_1","exports","__awaiter","permissionService","checkOrGrantBasicAccessPermission","chainId","origin","getPubkey","encrypt","contractCodeHash","decrypt","cipherText","nonce","getTxEncryptionKey"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/background/src/secret-wasm/handler.ts"],"sourcesContent":["import {\n  Env,\n  Handler,\n  InternalHandler,\n  KeplrError,\n  Message,\n} from \"@keplr-wallet/router\";\nimport {\n  GetPubkeyMsg,\n  GetTxEncryptionKeyMsg,\n  ReqeustEncryptMsg,\n  RequestDecryptMsg,\n} from \"./messages\";\nimport { SecretWasmService } from \"./service\";\n\nexport const getHandler: (service: SecretWasmService) => Handler = (\n  service: SecretWasmService\n) => {\n  return (env: Env, msg: Message<unknown>) => {\n    switch (msg.constructor) {\n      case GetPubkeyMsg:\n        return handleGetPubkeyMsg(service)(env, msg as GetPubkeyMsg);\n      case ReqeustEncryptMsg:\n        return handleReqeustEncryptMsg(service)(env, msg as ReqeustEncryptMsg);\n      case RequestDecryptMsg:\n        return handleRequestDecryptMsg(service)(env, msg as RequestDecryptMsg);\n      case GetTxEncryptionKeyMsg:\n        return handleGetTxEncryptionKeyMsg(service)(\n          env,\n          msg as GetTxEncryptionKeyMsg\n        );\n      default:\n        throw new KeplrError(\"secret-wasm\", 120, \"Unknown msg type\");\n    }\n  };\n};\n\nconst handleGetPubkeyMsg: (\n  service: SecretWasmService\n) => InternalHandler<GetPubkeyMsg> = (service) => {\n  return async (env, msg) => {\n    await service.permissionService.checkOrGrantBasicAccessPermission(\n      env,\n      msg.chainId,\n      msg.origin\n    );\n\n    return await service.getPubkey(env, msg.chainId);\n  };\n};\n\nconst handleReqeustEncryptMsg: (\n  service: SecretWasmService\n) => InternalHandler<ReqeustEncryptMsg> = (service) => {\n  return async (env, msg) => {\n    await service.permissionService.checkOrGrantBasicAccessPermission(\n      env,\n      msg.chainId,\n      msg.origin\n    );\n\n    // TODO: Should ask for user whether approve or reject to encrypt.\n    return await service.encrypt(\n      env,\n      msg.chainId,\n      msg.contractCodeHash,\n      msg.msg\n    );\n  };\n};\n\nconst handleRequestDecryptMsg: (\n  service: SecretWasmService\n) => InternalHandler<RequestDecryptMsg> = (service) => {\n  return async (env, msg) => {\n    await service.permissionService.checkOrGrantBasicAccessPermission(\n      env,\n      msg.chainId,\n      msg.origin\n    );\n\n    // XXX: Is there need to ask for user whether approve or reject to decrypt?\n    return await service.decrypt(env, msg.chainId, msg.cipherText, msg.nonce);\n  };\n};\n\nconst handleGetTxEncryptionKeyMsg: (\n  service: SecretWasmService\n) => InternalHandler<GetTxEncryptionKeyMsg> = (service) => {\n  return async (env, msg) => {\n    await service.permissionService.checkOrGrantBasicAccessPermission(\n      env,\n      msg.chainId,\n      msg.origin\n    );\n\n    // XXX: Is there need to ask for user whether approve or reject to getting tx encryption key?\n    return await service.getTxEncryptionKey(env, msg.chainId, msg.nonce);\n  };\n};\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}