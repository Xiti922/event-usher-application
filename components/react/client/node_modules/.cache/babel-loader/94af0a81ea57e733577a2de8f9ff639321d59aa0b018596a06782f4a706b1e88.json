{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChainStore = exports.ChainInfoInner = void 0;\nconst mobx_1 = require(\"mobx\");\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nconst mobx_utils_1 = require(\"mobx-utils\");\nclass ChainInfoInner {\n  constructor(chainInfo) {\n    this.unknownDenoms = [];\n    this.registeredCurrencies = [];\n    /**\n     * 위의 unknownDenoms에 값이 들어오면 밑의 배열의 함수를 순차적으로 실행한다.\n     * 만약 Currency 반환하면 그 registrar이 그 denom을 처리했다고 판단하고 순회를 멈춘다.\n     * 또한 AppCurrency가 아니라 [AppCurrency, boolean]의 튜플을 반활할 수 있는데\n     * 튜플을 반활할 경우 뒤의 boolean이 true일 때우(committed)까지 계속 observe한다.\n     * IBC 토큰을 처리하는 경우처럼 쿼리가 다 되기 전에 raw한 currency를 반환할 필요가 있는 경우처럼\n     * 등록된 currency가 나중에 replace될 수 있는 경우에 사용할 수 있다.\n     */\n    this.currencyRegistrars = [];\n    this._chainInfo = chainInfo;\n    mobx_1.makeObservable(this);\n    mobx_utils_1.keepAlive(this, \"currencyMap\");\n  }\n  getCurrencyFromRegistrars(coinMinimalDenom) {\n    for (let i = 0; i < this.currencyRegistrars.length; i++) {\n      const registrar = this.currencyRegistrars[i];\n      const currency = registrar(coinMinimalDenom);\n      if (currency) {\n        // AppCurrency일 경우\n        if (\"coinMinimalDenom\" in currency) {\n          return [currency, true];\n        }\n        return currency;\n      }\n    }\n    return undefined;\n  }\n  /*\n   * 해당되는 denom의 currency를 모를 때 이 메소드를 사용해서 등록을 요청할 수 있다.\n   * 이미 등록되어 있거나 등록을 시도 중이면 아무 행동도 하지 않는.\n   * 예를들어 네이티브 balance 쿼리에서 모르는 denom이 나오거나\n   * IBC denom의 등록을 요청할 때 쓸 수 있다.\n   */\n  addUnknownCurrencies() {\n    for (var _len = arguments.length, coinMinimalDenoms = new Array(_len), _key = 0; _key < _len; _key++) {\n      coinMinimalDenoms[_key] = arguments[_key];\n    }\n    for (const coinMinimalDenom of coinMinimalDenoms) {\n      if (this.unknownDenoms.find(denom => denom === coinMinimalDenom)) {\n        continue;\n      }\n      if (this.currencyMap.has(coinMinimalDenom)) {\n        continue;\n      }\n      this.unknownDenoms.push(coinMinimalDenom);\n      const disposer = mobx_1.autorun(() => {\n        const registered = this.getCurrencyFromRegistrars(coinMinimalDenom);\n        if (registered) {\n          const [currency, committed] = registered;\n          mobx_1.runInAction(() => {\n            if (currency) {\n              const index = this.unknownDenoms.findIndex(denom => denom === coinMinimalDenom);\n              if (index >= 0) {\n                this.unknownDenoms.splice(index, 1);\n              }\n              this.addOrReplaceCurrency(currency);\n            }\n            if (committed) {\n              disposer();\n            }\n          });\n        } else {\n          disposer();\n        }\n      });\n    }\n  }\n  registerCurrencyRegistrar(registrar) {\n    this.currencyRegistrars.push(registrar);\n  }\n  setChainInfo(chainInfo) {\n    this._chainInfo = chainInfo;\n  }\n  get raw() {\n    return this._chainInfo;\n  }\n  get chainId() {\n    return this._chainInfo.chainId;\n  }\n  get currencies() {\n    return this._chainInfo.currencies.concat(this.registeredCurrencies);\n  }\n  get currencyMap() {\n    const result = new Map();\n    for (const currency of this.currencies) {\n      result.set(currency.coinMinimalDenom, currency);\n    }\n    return result;\n  }\n  addCurrencies() {\n    const currencyMap = this.currencyMap;\n    for (var _len2 = arguments.length, currencies = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      currencies[_key2] = arguments[_key2];\n    }\n    for (const currency of currencies) {\n      if (!currencyMap.has(currency.coinMinimalDenom)) {\n        this.registeredCurrencies.push(currency);\n      }\n    }\n  }\n  removeCurrencies() {\n    const map = new Map();\n    for (var _len3 = arguments.length, coinMinimalDenoms = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      coinMinimalDenoms[_key3] = arguments[_key3];\n    }\n    for (const coinMinimalDenom of coinMinimalDenoms) {\n      map.set(coinMinimalDenom, true);\n    }\n    this.registeredCurrencies = this.registeredCurrencies.filter(currency => !map.get(currency.coinMinimalDenom));\n  }\n  /**\n   * Currency를 반환한다.\n   * 만약 해당 Currency가 없다면 unknown currency에 추가한다.\n   * @param coinMinimalDenom\n   */\n  findCurrency(coinMinimalDenom) {\n    if (this.currencyMap.has(coinMinimalDenom)) {\n      return this.currencyMap.get(coinMinimalDenom);\n    }\n    this.addUnknownCurrencies(coinMinimalDenom);\n    // Unknown denom can be registered synchronously in some cases.\n    // For this case, re-try to get currency.\n    if (this.currencyMap.has(coinMinimalDenom)) {\n      return this.currencyMap.get(coinMinimalDenom);\n    }\n  }\n  /**\n   * findCurrency와 비슷하지만 해당하는 currency가 존재하지 않을 경우 raw currency를 반환한다.\n   * @param coinMinimalDenom\n   */\n  forceFindCurrency(coinMinimalDenom) {\n    const currency = this.findCurrency(coinMinimalDenom);\n    if (!currency) {\n      return {\n        coinMinimalDenom,\n        coinDenom: coinMinimalDenom,\n        coinDecimals: 0\n      };\n    }\n    return currency;\n  }\n  addOrReplaceCurrency(currency) {\n    if (this.currencyMap.has(currency.coinMinimalDenom)) {\n      const index = this.registeredCurrencies.findIndex(cur => cur.coinMinimalDenom === currency.coinMinimalDenom);\n      if (index >= 0) {\n        this.registeredCurrencies.splice(index, 1, currency);\n      }\n    } else {\n      this.registeredCurrencies.push(currency);\n    }\n  }\n  get stakeCurrency() {\n    return this.raw.stakeCurrency;\n  }\n  get alternativeBIP44s() {\n    return this.raw.alternativeBIP44s;\n  }\n  get bech32Config() {\n    return this.raw.bech32Config;\n  }\n  get beta() {\n    return this.raw.beta;\n  }\n  get bip44() {\n    return this.raw.bip44;\n  }\n  get chainName() {\n    return this.raw.chainName;\n  }\n  get coinType() {\n    return this.raw.coinType;\n  }\n  get features() {\n    return this.raw.features;\n  }\n  get feeCurrencies() {\n    return this.raw.feeCurrencies;\n  }\n  get gasPriceStep() {\n    return this.raw.gasPriceStep;\n  }\n  get rest() {\n    return this.raw.rest;\n  }\n  get restConfig() {\n    return this.raw.restConfig;\n  }\n  get rpc() {\n    return this.raw.rpc;\n  }\n  get rpcConfig() {\n    return this.raw.rpcConfig;\n  }\n  get walletUrl() {\n    return this.raw.walletUrl;\n  }\n  get walletUrlForStaking() {\n    return this.raw.walletUrlForStaking;\n  }\n}\n__decorate([mobx_1.observable.ref], ChainInfoInner.prototype, \"_chainInfo\", void 0);\n__decorate([mobx_1.observable.shallow], ChainInfoInner.prototype, \"unknownDenoms\", void 0);\n__decorate([mobx_1.observable.shallow], ChainInfoInner.prototype, \"registeredCurrencies\", void 0);\n__decorate([mobx_1.observable], ChainInfoInner.prototype, \"currencyRegistrars\", void 0);\n__decorate([mobx_1.action], ChainInfoInner.prototype, \"addUnknownCurrencies\", null);\n__decorate([mobx_1.action], ChainInfoInner.prototype, \"registerCurrencyRegistrar\", null);\n__decorate([mobx_1.action], ChainInfoInner.prototype, \"setChainInfo\", null);\n__decorate([mobx_1.computed], ChainInfoInner.prototype, \"currencyMap\", null);\n__decorate([mobx_1.action], ChainInfoInner.prototype, \"addCurrencies\", null);\n__decorate([mobx_1.action], ChainInfoInner.prototype, \"removeCurrencies\", null);\n__decorate([mobx_1.action], ChainInfoInner.prototype, \"addOrReplaceCurrency\", null);\nexports.ChainInfoInner = ChainInfoInner;\nclass ChainStore {\n  constructor(embedChainInfos) {\n    this.setChainInfoHandlers = [];\n    this._cachedChainInfosMap = new Map();\n    this.setChainInfos(embedChainInfos);\n    mobx_1.makeObservable(this);\n  }\n  get chainInfos() {\n    return this._chainInfos;\n  }\n  getChain(chainId) {\n    const chainIdentifier = cosmos_1.ChainIdHelper.parse(chainId);\n    const find = this.chainInfos.find(info => {\n      return cosmos_1.ChainIdHelper.parse(info.chainId).identifier === chainIdentifier.identifier;\n    });\n    if (!find) {\n      throw new Error(`Unknown chain info: ${chainId}`);\n    }\n    return find;\n  }\n  hasChain(chainId) {\n    const chainIdentifier = cosmos_1.ChainIdHelper.parse(chainId);\n    const find = this.chainInfos.find(info => {\n      return cosmos_1.ChainIdHelper.parse(info.chainId).identifier === chainIdentifier.identifier;\n    });\n    return find != null;\n  }\n  addSetChainInfoHandler(handler) {\n    this.setChainInfoHandlers.push(handler);\n    for (const chainInfo of this.chainInfos) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const cached = this._cachedChainInfosMap.get(chainInfo.chainId);\n      handler(cached);\n    }\n  }\n  setChainInfos(chainInfos) {\n    const chainInfoInners = [];\n    for (const chainInfo of chainInfos) {\n      if (this._cachedChainInfosMap.has(chainInfo.chainId)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const cached = this._cachedChainInfosMap.get(chainInfo.chainId);\n        cached.setChainInfo(chainInfo);\n        chainInfoInners.push(cached);\n      } else {\n        const chainInfoInner = new ChainInfoInner(chainInfo);\n        this._cachedChainInfosMap.set(chainInfo.chainId, chainInfoInner);\n        chainInfoInners.push(chainInfoInner);\n        for (const handler of this.setChainInfoHandlers) {\n          handler(chainInfoInner);\n        }\n      }\n    }\n    this._chainInfos = chainInfoInners;\n  }\n}\n__decorate([mobx_1.observable.ref], ChainStore.prototype, \"_chainInfos\", void 0);\n__decorate([mobx_1.action], ChainStore.prototype, \"setChainInfos\", null);\nexports.ChainStore = ChainStore;","map":{"version":3,"mappings":"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","names":["ChainInfoInner","constructor","chainInfo","_chainInfo","mobx_1","mobx_utils_1","getCurrencyFromRegistrars","coinMinimalDenom","i","currencyRegistrars","length","registrar","currency","undefined","addUnknownCurrencies","coinMinimalDenoms","unknownDenoms","find","denom","currencyMap","has","push","disposer","registered","committed","index","findIndex","splice","addOrReplaceCurrency","registerCurrencyRegistrar","setChainInfo","raw","chainId","currencies","concat","registeredCurrencies","result","Map","set","addCurrencies","removeCurrencies","map","filter","get","findCurrency","forceFindCurrency","coinDenom","coinDecimals","cur","stakeCurrency","alternativeBIP44s","bech32Config","beta","bip44","chainName","coinType","features","feeCurrencies","gasPriceStep","rest","restConfig","rpc","rpcConfig","walletUrl","walletUrlForStaking","__decorate","ref","shallow","exports","ChainStore","embedChainInfos","setChainInfos","chainInfos","_chainInfos","getChain","chainIdentifier","cosmos_1","parse","info","identifier","Error","hasChain","addSetChainInfoHandler","handler","setChainInfoHandlers","cached","_cachedChainInfosMap","chainInfoInners","chainInfoInner"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/chain/index.ts"],"sourcesContent":["import {\n  action,\n  autorun,\n  computed,\n  makeObservable,\n  observable,\n  runInAction,\n} from \"mobx\";\nimport {\n  AppCurrency,\n  Bech32Config,\n  BIP44,\n  ChainInfo,\n  Currency,\n} from \"@keplr-wallet/types\";\nimport { ChainGetter } from \"../common\";\nimport { ChainIdHelper } from \"@keplr-wallet/cosmos\";\nimport { DeepReadonly } from \"utility-types\";\nimport { AxiosRequestConfig } from \"axios\";\nimport { keepAlive } from \"mobx-utils\";\n\ntype CurrencyRegistrar = (\n  coinMinimalDenom: string\n) => AppCurrency | [AppCurrency | undefined, boolean] | undefined;\n\nexport class ChainInfoInner<C extends ChainInfo = ChainInfo>\n  implements ChainInfo {\n  @observable.ref\n  protected _chainInfo: C;\n\n  @observable.shallow\n  protected unknownDenoms: string[] = [];\n\n  @observable.shallow\n  protected registeredCurrencies: AppCurrency[] = [];\n\n  /**\n   * 위의 unknownDenoms에 값이 들어오면 밑의 배열의 함수를 순차적으로 실행한다.\n   * 만약 Currency 반환하면 그 registrar이 그 denom을 처리했다고 판단하고 순회를 멈춘다.\n   * 또한 AppCurrency가 아니라 [AppCurrency, boolean]의 튜플을 반활할 수 있는데\n   * 튜플을 반활할 경우 뒤의 boolean이 true일 때우(committed)까지 계속 observe한다.\n   * IBC 토큰을 처리하는 경우처럼 쿼리가 다 되기 전에 raw한 currency를 반환할 필요가 있는 경우처럼\n   * 등록된 currency가 나중에 replace될 수 있는 경우에 사용할 수 있다.\n   */\n  @observable\n  protected currencyRegistrars: CurrencyRegistrar[] = [];\n\n  constructor(chainInfo: C) {\n    this._chainInfo = chainInfo;\n\n    makeObservable(this);\n\n    keepAlive(this, \"currencyMap\");\n  }\n\n  protected getCurrencyFromRegistrars(\n    coinMinimalDenom: string\n  ): [AppCurrency | undefined, boolean] | undefined {\n    for (let i = 0; i < this.currencyRegistrars.length; i++) {\n      const registrar = this.currencyRegistrars[i];\n      const currency = registrar(coinMinimalDenom);\n      if (currency) {\n        // AppCurrency일 경우\n        if (\"coinMinimalDenom\" in currency) {\n          return [currency, true];\n        }\n        return currency;\n      }\n    }\n    return undefined;\n  }\n\n  /*\n   * 해당되는 denom의 currency를 모를 때 이 메소드를 사용해서 등록을 요청할 수 있다.\n   * 이미 등록되어 있거나 등록을 시도 중이면 아무 행동도 하지 않는.\n   * 예를들어 네이티브 balance 쿼리에서 모르는 denom이 나오거나\n   * IBC denom의 등록을 요청할 때 쓸 수 있다.\n   */\n  @action\n  addUnknownCurrencies(...coinMinimalDenoms: string[]) {\n    for (const coinMinimalDenom of coinMinimalDenoms) {\n      if (this.unknownDenoms.find((denom) => denom === coinMinimalDenom)) {\n        continue;\n      }\n\n      if (this.currencyMap.has(coinMinimalDenom)) {\n        continue;\n      }\n\n      this.unknownDenoms.push(coinMinimalDenom);\n\n      const disposer = autorun(() => {\n        const registered = this.getCurrencyFromRegistrars(coinMinimalDenom);\n        if (registered) {\n          const [currency, committed] = registered;\n          runInAction(() => {\n            if (currency) {\n              const index = this.unknownDenoms.findIndex(\n                (denom) => denom === coinMinimalDenom\n              );\n              if (index >= 0) {\n                this.unknownDenoms.splice(index, 1);\n              }\n\n              this.addOrReplaceCurrency(currency);\n            }\n\n            if (committed) {\n              disposer();\n            }\n          });\n        } else {\n          disposer();\n        }\n      });\n    }\n  }\n\n  @action\n  registerCurrencyRegistrar(registrar: CurrencyRegistrar): void {\n    this.currencyRegistrars.push(registrar);\n  }\n\n  @action\n  setChainInfo(chainInfo: C) {\n    this._chainInfo = chainInfo;\n  }\n\n  get raw(): C {\n    return this._chainInfo;\n  }\n\n  get chainId(): string {\n    return this._chainInfo.chainId;\n  }\n\n  get currencies(): AppCurrency[] {\n    return this._chainInfo.currencies.concat(this.registeredCurrencies);\n  }\n\n  @computed\n  get currencyMap(): Map<string, AppCurrency> {\n    const result: Map<string, AppCurrency> = new Map();\n    for (const currency of this.currencies) {\n      result.set(currency.coinMinimalDenom, currency);\n    }\n    return result;\n  }\n\n  @action\n  addCurrencies(...currencies: AppCurrency[]) {\n    const currencyMap = this.currencyMap;\n    for (const currency of currencies) {\n      if (!currencyMap.has(currency.coinMinimalDenom)) {\n        this.registeredCurrencies.push(currency);\n      }\n    }\n  }\n\n  @action\n  removeCurrencies(...coinMinimalDenoms: string[]) {\n    const map = new Map<string, boolean>();\n    for (const coinMinimalDenom of coinMinimalDenoms) {\n      map.set(coinMinimalDenom, true);\n    }\n\n    this.registeredCurrencies = this.registeredCurrencies.filter(\n      (currency) => !map.get(currency.coinMinimalDenom)\n    );\n  }\n\n  /**\n   * Currency를 반환한다.\n   * 만약 해당 Currency가 없다면 unknown currency에 추가한다.\n   * @param coinMinimalDenom\n   */\n  findCurrency(coinMinimalDenom: string): AppCurrency | undefined {\n    if (this.currencyMap.has(coinMinimalDenom)) {\n      return this.currencyMap.get(coinMinimalDenom);\n    }\n    this.addUnknownCurrencies(coinMinimalDenom);\n\n    // Unknown denom can be registered synchronously in some cases.\n    // For this case, re-try to get currency.\n    if (this.currencyMap.has(coinMinimalDenom)) {\n      return this.currencyMap.get(coinMinimalDenom);\n    }\n  }\n\n  /**\n   * findCurrency와 비슷하지만 해당하는 currency가 존재하지 않을 경우 raw currency를 반환한다.\n   * @param coinMinimalDenom\n   */\n  forceFindCurrency(coinMinimalDenom: string): AppCurrency {\n    const currency = this.findCurrency(coinMinimalDenom);\n    if (!currency) {\n      return {\n        coinMinimalDenom,\n        coinDenom: coinMinimalDenom,\n        coinDecimals: 0,\n      };\n    }\n    return currency;\n  }\n\n  @action\n  protected addOrReplaceCurrency(currency: AppCurrency) {\n    if (this.currencyMap.has(currency.coinMinimalDenom)) {\n      const index = this.registeredCurrencies.findIndex(\n        (cur) => cur.coinMinimalDenom === currency.coinMinimalDenom\n      );\n      if (index >= 0) {\n        this.registeredCurrencies.splice(index, 1, currency);\n      }\n    } else {\n      this.registeredCurrencies.push(currency);\n    }\n  }\n\n  get stakeCurrency(): Currency {\n    return this.raw.stakeCurrency;\n  }\n\n  get alternativeBIP44s(): BIP44[] | undefined {\n    return this.raw.alternativeBIP44s;\n  }\n\n  get bech32Config(): Bech32Config {\n    return this.raw.bech32Config;\n  }\n  get beta(): boolean | undefined {\n    return this.raw.beta;\n  }\n\n  get bip44(): BIP44 {\n    return this.raw.bip44;\n  }\n\n  get chainName(): string {\n    return this.raw.chainName;\n  }\n\n  get coinType(): number | undefined {\n    return this.raw.coinType;\n  }\n\n  get features(): string[] | undefined {\n    return this.raw.features;\n  }\n\n  get feeCurrencies(): Currency[] {\n    return this.raw.feeCurrencies;\n  }\n\n  get gasPriceStep():\n    | { low: number; average: number; high: number }\n    | undefined {\n    return this.raw.gasPriceStep;\n  }\n\n  get rest(): string {\n    return this.raw.rest;\n  }\n\n  get restConfig(): AxiosRequestConfig | undefined {\n    return this.raw.restConfig;\n  }\n\n  get rpc(): string {\n    return this.raw.rpc;\n  }\n\n  get rpcConfig(): AxiosRequestConfig | undefined {\n    return this.raw.rpcConfig;\n  }\n\n  get walletUrl(): string | undefined {\n    return this.raw.walletUrl;\n  }\n\n  get walletUrlForStaking(): string | undefined {\n    return this.raw.walletUrlForStaking;\n  }\n}\n\nexport type ChainInfoOverrider<C extends ChainInfo = ChainInfo> = (\n  chainInfo: DeepReadonly<C>\n) => C;\n\nexport class ChainStore<C extends ChainInfo = ChainInfo>\n  implements ChainGetter {\n  @observable.ref\n  protected _chainInfos!: ChainInfoInner<C>[];\n\n  protected setChainInfoHandlers: ((\n    chainInfoInner: ChainInfoInner<C>\n  ) => void)[] = [];\n\n  protected _cachedChainInfosMap: Map<string, ChainInfoInner<C>> = new Map();\n\n  constructor(embedChainInfos: C[]) {\n    this.setChainInfos(embedChainInfos);\n\n    makeObservable(this);\n  }\n\n  get chainInfos(): ChainInfoInner<C>[] {\n    return this._chainInfos;\n  }\n\n  getChain(chainId: string): ChainInfoInner<C> {\n    const chainIdentifier = ChainIdHelper.parse(chainId);\n\n    const find = this.chainInfos.find((info) => {\n      return (\n        ChainIdHelper.parse(info.chainId).identifier ===\n        chainIdentifier.identifier\n      );\n    });\n\n    if (!find) {\n      throw new Error(`Unknown chain info: ${chainId}`);\n    }\n\n    return find;\n  }\n\n  hasChain(chainId: string): boolean {\n    const chainIdentifier = ChainIdHelper.parse(chainId);\n\n    const find = this.chainInfos.find((info) => {\n      return (\n        ChainIdHelper.parse(info.chainId).identifier ===\n        chainIdentifier.identifier\n      );\n    });\n\n    return find != null;\n  }\n\n  addSetChainInfoHandler(handler: (chainInfoInner: ChainInfoInner<C>) => void) {\n    this.setChainInfoHandlers.push(handler);\n\n    for (const chainInfo of this.chainInfos) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const cached = this._cachedChainInfosMap.get(chainInfo.chainId)!;\n      handler(cached);\n    }\n  }\n\n  @action\n  protected setChainInfos(chainInfos: C[]) {\n    const chainInfoInners: ChainInfoInner<C>[] = [];\n\n    for (const chainInfo of chainInfos) {\n      if (this._cachedChainInfosMap.has(chainInfo.chainId)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const cached = this._cachedChainInfosMap.get(chainInfo.chainId)!;\n        cached.setChainInfo(chainInfo);\n        chainInfoInners.push(cached);\n      } else {\n        const chainInfoInner = new ChainInfoInner(chainInfo);\n        this._cachedChainInfosMap.set(chainInfo.chainId, chainInfoInner);\n        chainInfoInners.push(chainInfoInner);\n\n        for (const handler of this.setChainInfoHandlers) {\n          handler(chainInfoInner);\n        }\n      }\n    }\n\n    this._chainInfos = chainInfoInners;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}