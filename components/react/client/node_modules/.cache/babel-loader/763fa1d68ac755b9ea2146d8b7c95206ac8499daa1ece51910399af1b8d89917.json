{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CoinUtils = void 0;\nconst coin_1 = require(\"./coin\");\nconst int_1 = require(\"./int\");\nconst decimal_1 = require(\"./decimal\");\nconst dec_utils_1 = require(\"./dec-utils\");\nclass CoinUtils {\n  static createCoinsFromPrimitives(coinPrimitives) {\n    return coinPrimitives.map(primitive => {\n      return new coin_1.Coin(primitive.denom, primitive.amount);\n    });\n  }\n  static amountOf(coins, denom) {\n    const coin = coins.find(coin => {\n      return coin.denom === denom;\n    });\n    if (!coin) {\n      return new int_1.Int(0);\n    } else {\n      return coin.amount;\n    }\n  }\n  static exclude(coins, demons) {\n    return coins.filter(coin => {\n      return demons.indexOf(coin.denom) === 0;\n    });\n  }\n  static concat() {\n    for (var _len = arguments.length, coins = new Array(_len), _key = 0; _key < _len; _key++) {\n      coins[_key] = arguments[_key];\n    }\n    if (coins.length === 0) {\n      return [];\n    }\n    const arr = coins.slice();\n    const reducer = (accumulator, coin) => {\n      // Find the duplicated denom.\n      const find = accumulator.find(c => c.denom === coin.denom);\n      // If duplicated coin exists, add the amount to duplicated one.\n      if (find) {\n        const newCoin = new coin_1.Coin(find.denom, find.amount.add(coin.amount));\n        accumulator.push(newCoin);\n      } else {\n        const newCoin = new coin_1.Coin(coin.denom, coin.amount);\n        accumulator.push(newCoin);\n      }\n      return accumulator;\n    };\n    return arr.reduce(reducer, []);\n  }\n  static getCoinFromDecimals(currencies, decAmountStr, denom) {\n    const currency = currencies.find(currency => {\n      return currency.coinDenom === denom;\n    });\n    if (!currency) {\n      throw new Error(\"Invalid currency\");\n    }\n    let precision = new decimal_1.Dec(1);\n    for (let i = 0; i < currency.coinDecimals; i++) {\n      precision = precision.mul(new decimal_1.Dec(10));\n    }\n    let decAmount = new decimal_1.Dec(decAmountStr);\n    decAmount = decAmount.mul(precision);\n    if (!new decimal_1.Dec(decAmount.truncate()).equals(decAmount)) {\n      throw new Error(\"Can't divide anymore\");\n    }\n    return new coin_1.Coin(currency.coinMinimalDenom, decAmount.truncate());\n  }\n  static parseDecAndDenomFromCoin(currencies, coin) {\n    let currency = currencies.find(currency => {\n      return currency.coinMinimalDenom === coin.denom;\n    });\n    if (!currency) {\n      // If the currency is unknown, just use the raw currency.\n      currency = {\n        coinDecimals: 0,\n        coinDenom: coin.denom,\n        coinMinimalDenom: coin.denom\n      };\n    }\n    let precision = new decimal_1.Dec(1);\n    for (let i = 0; i < currency.coinDecimals; i++) {\n      precision = precision.mul(new decimal_1.Dec(10));\n    }\n    const decAmount = new decimal_1.Dec(coin.amount).quoTruncate(precision);\n    return {\n      amount: decAmount.toString(currency.coinDecimals),\n      denom: currency.coinDenom\n    };\n  }\n  static shrinkDecimals(dec, minDecimals, maxDecimals) {\n    let locale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (dec.equals(new decimal_1.Dec(0))) {\n      return \"0\";\n    }\n    const isNeg = dec.isNegative();\n    const integer = dec.abs().truncate();\n    const fraction = dec.abs().sub(new decimal_1.Dec(integer));\n    const decimals = Math.max(maxDecimals - integer.toString().length + 1, minDecimals);\n    const fractionStr = decimals === 0 ? \"\" : fraction.toString(decimals).replace(\"0.\", \"\");\n    const integerStr = locale ? CoinUtils.integerStringToUSLocaleString(integer.toString()) : integer.toString();\n    return (isNeg ? \"-\" : \"\") + integerStr + (fractionStr.length > 0 ? \".\" : \"\") + fractionStr;\n  }\n  /**\n   * Change the non-locale integer string to locale string.\n   * Only support en-US format.\n   * This method uses the BigInt if the environment supports the BigInt.\n   * @param numberStr\n   */\n  static integerStringToUSLocaleString(numberStr) {\n    if (numberStr.indexOf(\".\") >= 0) {\n      throw new Error(`${numberStr} is not integer`);\n    }\n    if (typeof BigInt !== \"undefined\") {\n      return BigInt(numberStr).toLocaleString(\"en-US\");\n    }\n    const integer = numberStr;\n    const chunks = [];\n    for (let i = integer.length; i > 0; i -= 3) {\n      chunks.push(integer.slice(Math.max(0, i - 3), i));\n    }\n    return chunks.reverse().join(\",\");\n  }\n  static coinToTrimmedString(coin, currency) {\n    let separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \" \";\n    const dec = new decimal_1.Dec(coin.amount).quoTruncate(dec_utils_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n    return `${dec_utils_1.DecUtils.trim(dec)}${separator}${currency.coinDenom}`;\n  }\n}\nexports.CoinUtils = CoinUtils;","map":{"version":3,"mappings":"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","names":["CoinUtils","createCoinsFromPrimitives","coinPrimitives","map","primitive","coin_1","denom","amount","amountOf","coins","coin","find","int_1","exclude","demons","filter","indexOf","concat","length","arr","slice","reducer","accumulator","c","newCoin","add","push","reduce","getCoinFromDecimals","currencies","decAmountStr","currency","coinDenom","Error","precision","decimal_1","i","coinDecimals","mul","decAmount","truncate","equals","coinMinimalDenom","parseDecAndDenomFromCoin","quoTruncate","toString","shrinkDecimals","dec","minDecimals","maxDecimals","locale","isNeg","isNegative","integer","abs","fraction","sub","decimals","Math","max","fractionStr","replace","integerStr","integerStringToUSLocaleString","numberStr","BigInt","toLocaleString","chunks","reverse","join","coinToTrimmedString","separator","dec_utils_1","getPrecisionDec","trim","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/node_modules/@keplr-wallet/unit/src/coin-utils.ts"],"sourcesContent":["import { Coin } from \"./coin\";\nimport { Int } from \"./int\";\nimport { Dec } from \"./decimal\";\nimport { DecUtils } from \"./dec-utils\";\nimport { Currency } from \"@keplr-wallet/types\";\n\nexport class CoinUtils {\n  static createCoinsFromPrimitives(\n    coinPrimitives: {\n      denom: string;\n      amount: string;\n    }[]\n  ): Coin[] {\n    return coinPrimitives.map((primitive) => {\n      return new Coin(primitive.denom, primitive.amount);\n    });\n  }\n\n  static amountOf(coins: Coin[], denom: string): Int {\n    const coin = coins.find((coin) => {\n      return coin.denom === denom;\n    });\n\n    if (!coin) {\n      return new Int(0);\n    } else {\n      return coin.amount;\n    }\n  }\n\n  static exclude(coins: Coin[], demons: string[]): Coin[] {\n    return coins.filter((coin) => {\n      return demons.indexOf(coin.denom) === 0;\n    });\n  }\n\n  static concat(...coins: Coin[]): Coin[] {\n    if (coins.length === 0) {\n      return [];\n    }\n\n    const arr = coins.slice();\n    const reducer = (accumulator: Coin[], coin: Coin) => {\n      // Find the duplicated denom.\n      const find = accumulator.find((c) => c.denom === coin.denom);\n      // If duplicated coin exists, add the amount to duplicated one.\n      if (find) {\n        const newCoin = new Coin(find.denom, find.amount.add(coin.amount));\n        accumulator.push(newCoin);\n      } else {\n        const newCoin = new Coin(coin.denom, coin.amount);\n        accumulator.push(newCoin);\n      }\n\n      return accumulator;\n    };\n\n    return arr.reduce(reducer, []);\n  }\n\n  static getCoinFromDecimals(\n    currencies: Currency[],\n    decAmountStr: string,\n    denom: string\n  ): Coin {\n    const currency = currencies.find((currency) => {\n      return currency.coinDenom === denom;\n    });\n    if (!currency) {\n      throw new Error(\"Invalid currency\");\n    }\n\n    let precision = new Dec(1);\n    for (let i = 0; i < currency.coinDecimals; i++) {\n      precision = precision.mul(new Dec(10));\n    }\n\n    let decAmount = new Dec(decAmountStr);\n    decAmount = decAmount.mul(precision);\n\n    if (!new Dec(decAmount.truncate()).equals(decAmount)) {\n      throw new Error(\"Can't divide anymore\");\n    }\n\n    return new Coin(currency.coinMinimalDenom, decAmount.truncate());\n  }\n\n  static parseDecAndDenomFromCoin(\n    currencies: Currency[],\n    coin: Coin\n  ): { amount: string; denom: string } {\n    let currency = currencies.find((currency) => {\n      return currency.coinMinimalDenom === coin.denom;\n    });\n    if (!currency) {\n      // If the currency is unknown, just use the raw currency.\n      currency = {\n        coinDecimals: 0,\n        coinDenom: coin.denom,\n        coinMinimalDenom: coin.denom,\n      };\n    }\n\n    let precision = new Dec(1);\n    for (let i = 0; i < currency.coinDecimals; i++) {\n      precision = precision.mul(new Dec(10));\n    }\n\n    const decAmount = new Dec(coin.amount).quoTruncate(precision);\n    return {\n      amount: decAmount.toString(currency.coinDecimals),\n      denom: currency.coinDenom,\n    };\n  }\n\n  static shrinkDecimals(\n    dec: Dec,\n    minDecimals: number,\n    maxDecimals: number,\n    locale: boolean = false\n  ): string {\n    if (dec.equals(new Dec(0))) {\n      return \"0\";\n    }\n\n    const isNeg = dec.isNegative();\n\n    const integer = dec.abs().truncate();\n    const fraction = dec.abs().sub(new Dec(integer));\n\n    const decimals = Math.max(\n      maxDecimals - integer.toString().length + 1,\n      minDecimals\n    );\n\n    const fractionStr =\n      decimals === 0 ? \"\" : fraction.toString(decimals).replace(\"0.\", \"\");\n\n    const integerStr = locale\n      ? CoinUtils.integerStringToUSLocaleString(integer.toString())\n      : integer.toString();\n\n    return (\n      (isNeg ? \"-\" : \"\") +\n      integerStr +\n      (fractionStr.length > 0 ? \".\" : \"\") +\n      fractionStr\n    );\n  }\n\n  /**\n   * Change the non-locale integer string to locale string.\n   * Only support en-US format.\n   * This method uses the BigInt if the environment supports the BigInt.\n   * @param numberStr\n   */\n  static integerStringToUSLocaleString(numberStr: string): string {\n    if (numberStr.indexOf(\".\") >= 0) {\n      throw new Error(`${numberStr} is not integer`);\n    }\n\n    if (typeof BigInt !== \"undefined\") {\n      return BigInt(numberStr).toLocaleString(\"en-US\");\n    }\n\n    const integer = numberStr;\n\n    const chunks: string[] = [];\n    for (let i = integer.length; i > 0; i -= 3) {\n      chunks.push(integer.slice(Math.max(0, i - 3), i));\n    }\n\n    return chunks.reverse().join(\",\");\n  }\n\n  static coinToTrimmedString(\n    coin: Coin,\n    currency: Currency,\n    separator: string = \" \"\n  ): string {\n    const dec = new Dec(coin.amount).quoTruncate(\n      DecUtils.getPrecisionDec(currency.coinDecimals)\n    );\n\n    return `${DecUtils.trim(dec)}${separator}${currency.coinDenom}`;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}