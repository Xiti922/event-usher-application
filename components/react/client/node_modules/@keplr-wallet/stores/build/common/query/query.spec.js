"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DelayMemoryKVStore = exports.MockOnStartObservableQuery = exports.MockObservableQuery = void 0;
const query_1 = require("./query");
const common_1 = require("@keplr-wallet/common");
const axios_1 = __importDefault(require("axios"));
const http_1 = __importDefault(require("http"));
const mobx_1 = require("mobx");
class MockObservableQuery extends query_1.ObservableQuery {
    constructor(kvStore, port, options = {}, url = "/test") {
        const instance = axios_1.default.create({
            baseURL: `http://127.0.0.1:${port}`,
        });
        super(kvStore, instance, url, options);
    }
    changeURL(url) {
        this.setUrl(url);
    }
}
exports.MockObservableQuery = MockObservableQuery;
class MockOnStartObservableQuery extends query_1.ObservableQuery {
    constructor(kvStore, port, options = {}, url = "/test", onStartOptions = {}) {
        const instance = axios_1.default.create({
            baseURL: `http://127.0.0.1:${port}`,
        });
        super(kvStore, instance, url, options);
        this.onStartOptions = onStartOptions;
    }
    onStart() {
        super.onStart();
        if (this.onStartOptions.onStartDelay == null) {
            if (this.onStartOptions.onStartUrl) {
                this.setUrl(this.onStartOptions.onStartUrl);
            }
        }
        else {
            return new Promise((resolve) => {
                setTimeout(() => {
                    if (this.onStartOptions.onStartUrl) {
                        this.setUrl(this.onStartOptions.onStartUrl);
                    }
                    setTimeout(() => {
                        resolve();
                    }, this.onStartOptions.onStartDelay / 2);
                }, this.onStartOptions.onStartDelay / 2);
            });
        }
    }
    changeURL(url) {
        this.setUrl(url);
    }
}
exports.MockOnStartObservableQuery = MockOnStartObservableQuery;
class DelayMemoryKVStore extends common_1.MemoryKVStore {
    constructor(prefix, delay) {
        super(prefix);
        this.delay = delay;
    }
    get(key) {
        const _super = Object.create(null, {
            get: { get: () => super.get }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => {
                setTimeout(resolve, this.delay);
            });
            return _super.get.call(this, key);
        });
    }
    set(key, data) {
        const _super = Object.create(null, {
            set: { get: () => super.set }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => {
                setTimeout(resolve, this.delay);
            });
            return _super.set.call(this, key, data);
        });
    }
}
exports.DelayMemoryKVStore = DelayMemoryKVStore;
describe("Test observable query", () => {
    const createTestServer = (delay = 100) => {
        let num = 0;
        const server = http_1.default.createServer((req, resp) => {
            if (req.url === "/invalid") {
                throw new Error();
            }
            if (req.url === "/error1") {
                resp.writeHead(503);
                resp.end();
                return;
            }
            if (req.url === "/error2") {
                resp.writeHead(400, {
                    "content-type": "text/plain",
                });
                resp.end("message text");
                return;
            }
            if (req.url === "/error3") {
                resp.writeHead(400, {
                    "content-type": "application/json; charset=utf-8",
                });
                resp.end(JSON.stringify({ message: "message text" }));
                return;
            }
            let closed = false;
            req.once("close", () => {
                closed = true;
            });
            setTimeout(() => {
                if (!closed) {
                    resp.writeHead(200);
                    resp.end(num.toString());
                    num++;
                }
            }, delay);
        });
        server.listen();
        const address = server.address();
        if (!address || typeof address === "string") {
            throw new Error("Failed to get address for server");
        }
        const port = address.port;
        return {
            port,
            closeServer: () => {
                server.close();
            },
            getNum: () => num,
        };
    };
    it("basic test", () => __awaiter(void 0, void 0, void 0, function* () {
        const basicTestFn = (store) => __awaiter(void 0, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const abortSpy = jest.spyOn(AbortController.prototype, "abort");
            const { port, closeServer } = createTestServer();
            const query = new MockObservableQuery(store, port);
            // Nothing is being fetched because no value has been observed
            expect(query.isObserved).toBe(false);
            expect(query.isFetching).toBe(false);
            expect(query.isStarted).toBe(false);
            expect(query.error).toBeUndefined();
            expect(query.response).toBeUndefined();
            const disposer = mobx_1.autorun(() => {
                // This makes the response observed. Thus, fetching starts.
                if (query.response) {
                    expect(query.response.data).toBe(0);
                }
            }, {
                onError: (e) => {
                    throw e;
                },
            });
            // Above code make query starts, but the response not yet fetched
            expect(query.isObserved).toBe(true);
            expect(query.isFetching).toBe(true);
            expect(query.isStarted).toBe(true);
            expect(query.error).toBeUndefined();
            expect(query.response).toBeUndefined();
            // Make sure that the fetching complete
            yield new Promise((resolve) => setTimeout(resolve, 1000));
            // Not yet observer disposed. So the query is still in observation.
            expect(query.isObserved).toBe(true);
            expect(query.isFetching).toBe(false);
            expect(query.isStarted).toBe(true);
            expect(query.error).toBeUndefined();
            expect(query.response).not.toBeUndefined();
            expect((_a = query.response) === null || _a === void 0 ? void 0 : _a.data).toBe(0);
            disposer();
            // Not, the observation ends
            expect(query.isObserved).toBe(false);
            expect(query.isFetching).toBe(false);
            expect(query.isStarted).toBe(false);
            expect(query.error).toBeUndefined();
            expect(query.response).not.toBeUndefined();
            expect((_b = query.response) === null || _b === void 0 ? void 0 : _b.data).toBe(0);
            yield query.waitResponse();
            expect((_c = query.response) === null || _c === void 0 ? void 0 : _c.data).toBe(0);
            yield query.waitFreshResponse();
            expect((_d = query.response) === null || _d === void 0 ? void 0 : _d.data).toBe(1);
            expect(abortSpy).toBeCalledTimes(0);
            abortSpy.mockRestore();
            closeServer();
        });
        const memStore = new DelayMemoryKVStore("test", 1);
        yield basicTestFn(memStore);
        // The kvstore below has a delay of 3 seconds.
        // This is definitely slower than the query.
        // Even if the kvstore performs worse than the query, it should handle it well.
        const delayMemStore = new DelayMemoryKVStore("test", 3000);
        yield basicTestFn(delayMemStore);
    }));
    it("test waitResponse() can ignore other component unobserved", () => __awaiter(void 0, void 0, void 0, function* () {
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(500);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port);
        const disposer = mobx_1.autorun(() => {
            if (query.response) {
                throw new Error("not canceled");
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        setTimeout(() => {
            disposer();
        }, 200);
        const res = yield query.waitResponse();
        expect(res === null || res === void 0 ? void 0 : res.data).toBe(0);
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test waitResponse() can ignore fetch requests", () => __awaiter(void 0, void 0, void 0, function* () {
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(500);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port);
        const disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data !== 0) {
                throw new Error("not canceled");
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        // Below line makes cancel and refresh
        setTimeout(() => {
            query.fetch();
        }, 10);
        const res = yield query.waitResponse();
        expect(res === null || res === void 0 ? void 0 : res.data).toBe(0);
        expect(abortSpy).toBeCalledTimes(1);
        abortSpy.mockRestore();
        disposer();
        closeServer();
    }));
    it("test waitFreshResponse() can ignore other component unobserved", () => __awaiter(void 0, void 0, void 0, function* () {
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(500);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port);
        yield query.waitFreshResponse();
        const disposer = mobx_1.autorun(() => {
            var _a;
            if (((_a = query.response) === null || _a === void 0 ? void 0 : _a.data) !== 0) {
                throw new Error("not canceled");
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        setTimeout(() => {
            disposer();
        }, 200);
        const res = yield query.waitFreshResponse();
        expect(res === null || res === void 0 ? void 0 : res.data).toBe(1);
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test waitFreshResponse() can ignore fetch requests", () => __awaiter(void 0, void 0, void 0, function* () {
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(500);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port);
        yield query.waitFreshResponse();
        const disposer = mobx_1.autorun(() => {
            var _a, _b;
            // This makes the response observed. Thus, fetching starts.
            if (((_a = query.response) === null || _a === void 0 ? void 0 : _a.data) !== 0 && ((_b = query.response) === null || _b === void 0 ? void 0 : _b.data) !== 1) {
                throw new Error("not canceled");
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        // Below line makes cancel and refresh
        setTimeout(() => {
            query.fetch();
        }, 10);
        const res = yield query.waitFreshResponse();
        expect(res === null || res === void 0 ? void 0 : res.data).toBe(1);
        expect(abortSpy).toBeCalledTimes(1);
        abortSpy.mockRestore();
        disposer();
        closeServer();
    }));
    it("test waitFreshResponse()/waitFreshResponse()", () => __awaiter(void 0, void 0, void 0, function* () {
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer();
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port);
        let res = yield query.waitResponse();
        expect(res === null || res === void 0 ? void 0 : res.data).toBe(0);
        res = yield query.waitFreshResponse();
        expect(res === null || res === void 0 ? void 0 : res.data).toBe(1);
        res = yield query.waitResponse();
        expect(res === null || res === void 0 ? void 0 : res.data).toBe(1);
        res = yield query.waitFreshResponse();
        expect(res === null || res === void 0 ? void 0 : res.data).toBe(2);
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test basic cancellation", () => __awaiter(void 0, void 0, void 0, function* () {
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(500);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port);
        expect(query.isObserved).toBe(false);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(false);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        const disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response) {
                throw new Error("not canceled");
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        // Dispose the observer before the fetch completes.
        yield new Promise((resolve) => {
            setTimeout(() => {
                disposer();
                resolve();
            }, 100);
        });
        // Wait to close request.
        yield new Promise((resolve) => {
            setTimeout(resolve, 10);
        });
        // In this case, query should be canceled.
        expect(query.isObserved).toBe(false);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(false);
        // Cancellation should not make the error.
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        expect(abortSpy).toBeCalledTimes(1);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test restore from cache/query occurs at the same time if cache age not set", () => __awaiter(void 0, void 0, void 0, function* () {
        var _e, _f, _g, _h, _j, _k;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(500);
        const memStore = new DelayMemoryKVStore("test", 300);
        yield (() => __awaiter(void 0, void 0, void 0, function* () {
            // Make cache
            const query = new MockObservableQuery(memStore, port);
            yield query.waitFreshResponse();
        }))();
        const query = new MockObservableQuery(memStore, port);
        expect(query.isObserved).toBe(false);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(false);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        const disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data >= 2) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        yield new Promise((resolve) => {
            setTimeout(resolve, 100);
        });
        // Not yet cache restored due to delayed kv store.
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        yield new Promise((resolve) => {
            setTimeout(resolve, 210);
        });
        // Now, the cache should be restored.
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect((_e = query.response) === null || _e === void 0 ? void 0 : _e.data).toBe(0);
        expect((_f = query.response) === null || _f === void 0 ? void 0 : _f.staled).toBe(true);
        yield new Promise((resolve) => {
            setTimeout(resolve, 200);
        });
        // Now, total 510ms passed. If restoring from cache and querying occurs at the same time, query should be revalidated.
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect((_g = query.response) === null || _g === void 0 ? void 0 : _g.data).toBe(1);
        expect((_h = query.response) === null || _h === void 0 ? void 0 : _h.staled).toBe(false);
        disposer();
        expect(query.isObserved).toBe(false);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(false);
        expect(query.error).toBeUndefined();
        expect((_j = query.response) === null || _j === void 0 ? void 0 : _j.data).toBe(1);
        expect((_k = query.response) === null || _k === void 0 ? void 0 : _k.staled).toBe(false);
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test basic cache (valid)", () => __awaiter(void 0, void 0, void 0, function* () {
        var _l, _m, _o, _p, _q, _r, _s, _t;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(200);
        const memStore = new common_1.MemoryKVStore("test");
        yield (() => __awaiter(void 0, void 0, void 0, function* () {
            // Make cache
            const query = new MockObservableQuery(memStore, port);
            yield query.waitFreshResponse();
        }))();
        const query = new MockObservableQuery(memStore, port, {
            cacheMaxAge: 300,
        });
        yield new Promise((resolve) => {
            setTimeout(resolve, 150);
        });
        expect(query.isObserved).toBe(false);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(false);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        let disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data >= 1) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        yield new Promise((resolve) => {
            setTimeout(resolve, 10);
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect((_l = query.response) === null || _l === void 0 ? void 0 : _l.data).toBe(0);
        expect((_m = query.response) === null || _m === void 0 ? void 0 : _m.staled).toBe(true);
        yield new Promise((resolve) => {
            setTimeout(resolve, 200);
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect((_o = query.response) === null || _o === void 0 ? void 0 : _o.data).toBe(0);
        expect((_p = query.response) === null || _p === void 0 ? void 0 : _p.staled).toBe(true);
        disposer();
        expect(abortSpy).toBeCalledTimes(0);
        disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data >= 2) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect((_q = query.response) === null || _q === void 0 ? void 0 : _q.data).toBe(0);
        expect((_r = query.response) === null || _r === void 0 ? void 0 : _r.staled).toBe(true);
        yield new Promise((resolve) => {
            setTimeout(resolve, 250);
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect((_s = query.response) === null || _s === void 0 ? void 0 : _s.data).toBe(1);
        expect((_t = query.response) === null || _t === void 0 ? void 0 : _t.staled).toBe(false);
        disposer();
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test basic cache (invalidated)", () => __awaiter(void 0, void 0, void 0, function* () {
        var _u, _v;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(200);
        const memStore = new common_1.MemoryKVStore("test");
        yield (() => __awaiter(void 0, void 0, void 0, function* () {
            // Make cache
            const query = new MockObservableQuery(memStore, port);
            yield query.waitFreshResponse();
        }))();
        const query = new MockObservableQuery(memStore, port, {
            cacheMaxAge: 300,
        });
        yield new Promise((resolve) => {
            setTimeout(resolve, 350);
        });
        expect(query.isObserved).toBe(false);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(false);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        const disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data != 1) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        yield new Promise((resolve) => {
            setTimeout(resolve, 30);
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        yield new Promise((resolve) => {
            setTimeout(resolve, 200);
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect((_u = query.response) === null || _u === void 0 ? void 0 : _u.data).toBe(1);
        expect((_v = query.response) === null || _v === void 0 ? void 0 : _v.staled).toBe(false);
        disposer();
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test cache in age not make query", () => __awaiter(void 0, void 0, void 0, function* () {
        var _w, _x, _y, _z, _0, _1;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(10);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port, {
            cacheMaxAge: 300,
        });
        const tests = [
            {
                first: true,
                postDelay: 100,
                inCache: false,
                expect: 0,
            },
            {
                postDelay: 100,
                inCache: true,
                expect: 0,
            },
            {
                postDelay: 100,
                inCache: true,
                expect: 0,
            },
            {
                postDelay: 100,
                inCache: false,
                expect: 1,
            },
            {
                postDelay: 200,
                inCache: true,
                expect: 1,
            },
            {
                postDelay: 300,
                inCache: false,
                expect: 2,
            },
            {
                postDelay: 300,
                inCache: false,
                expect: 3,
            },
        ];
        for (const test of tests) {
            const disposer = mobx_1.autorun(() => {
                // This makes the response observed. Thus, fetching starts.
                if (query.response && query.response.data >= 4) {
                    throw new Error();
                }
            }, {
                onError: (e) => {
                    throw e;
                },
            });
            expect(query.isObserved).toBe(true);
            if (!test.inCache) {
                expect(query.isFetching).toBe(true);
            }
            else {
                expect(query.isFetching).toBe(false);
            }
            expect(query.isStarted).toBe(true);
            yield new Promise((resolve) => {
                setTimeout(resolve, 1);
            });
            const cached = (_w = query.response) === null || _w === void 0 ? void 0 : _w.data;
            expect(query.isObserved).toBe(true);
            if (!test.inCache) {
                expect(query.isFetching).toBe(true);
            }
            else {
                expect(query.isFetching).toBe(false);
            }
            expect(query.isStarted).toBe(true);
            if (!test.first) {
                if (!test.inCache) {
                    expect((_x = query.response) === null || _x === void 0 ? void 0 : _x.staled).toBe(true);
                }
                else {
                    expect((_y = query.response) === null || _y === void 0 ? void 0 : _y.staled).toBe(false);
                }
            }
            yield new Promise((resolve) => {
                setTimeout(resolve, 20);
            });
            expect(query.isObserved).toBe(true);
            expect(query.isFetching).toBe(false);
            expect(query.isStarted).toBe(true);
            expect((_z = query.response) === null || _z === void 0 ? void 0 : _z.staled).toBe(false);
            expect((_0 = query.response) === null || _0 === void 0 ? void 0 : _0.data).toBe(test.expect);
            if (test.inCache) {
                expect((_1 = query.response) === null || _1 === void 0 ? void 0 : _1.data).toBe(cached);
            }
            disposer();
            yield new Promise((resolve) => {
                setTimeout(resolve, test.postDelay);
            });
        }
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test cache in age not make query (via waitFreshResponse())", () => __awaiter(void 0, void 0, void 0, function* () {
        var _2;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(10);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port, {
            cacheMaxAge: 300,
        });
        const tests = [
            {
                postDelay: 100,
                expect: 0,
            },
            {
                postDelay: 100,
                expect: 0,
            },
            {
                postDelay: 100,
                expect: 0,
            },
            {
                postDelay: 100,
                expect: 1,
            },
            {
                postDelay: 200,
                expect: 1,
            },
            {
                postDelay: 300,
                expect: 2,
            },
            {
                postDelay: 300,
                expect: 3,
            },
        ];
        for (const test of tests) {
            yield query.waitFreshResponse();
            expect((_2 = query.response) === null || _2 === void 0 ? void 0 : _2.data).toBe(test.expect);
            yield new Promise((resolve) => {
                setTimeout(resolve, test.postDelay);
            });
        }
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test cache in age not make query (via waitResponse())", () => __awaiter(void 0, void 0, void 0, function* () {
        var _3, _4, _5, _6, _7, _8;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(1);
        const memStore = new common_1.MemoryKVStore("test");
        let query = new MockObservableQuery(memStore, port, {
            cacheMaxAge: 100,
        });
        yield query.waitResponse();
        expect((_3 = query.response) === null || _3 === void 0 ? void 0 : _3.data).toBe(0);
        // Create new query
        query = new MockObservableQuery(memStore, port, {
            cacheMaxAge: 100,
        });
        expect(query.response).toBeUndefined();
        // Cache is still valid.
        yield query.waitResponse();
        expect((_4 = query.response) === null || _4 === void 0 ? void 0 : _4.data).toBe(0);
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        // Cache is still valid.
        yield query.waitResponse();
        expect((_5 = query.response) === null || _5 === void 0 ? void 0 : _5.data).toBe(0);
        // Create new query
        query = new MockObservableQuery(memStore, port, {
            cacheMaxAge: 100,
        });
        expect(query.response).toBeUndefined();
        yield new Promise((resolve) => {
            setTimeout(resolve, 55);
        });
        // Cache is now invalidated.
        yield query.waitResponse();
        expect((_6 = query.response) === null || _6 === void 0 ? void 0 : _6.data).toBe(1);
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        // Create new query
        query = new MockObservableQuery(memStore, port, {
            cacheMaxAge: 100,
        });
        // Cache is still valid.
        yield query.waitResponse();
        expect((_7 = query.response) === null || _7 === void 0 ? void 0 : _7.data).toBe(1);
        // Create new query
        query = new MockObservableQuery(memStore, port, {
            cacheMaxAge: 100,
        });
        expect(query.response).toBeUndefined();
        yield new Promise((resolve) => {
            setTimeout(resolve, 55);
        });
        // Cache is now invalidated. (Prior cache should not change cache's timestamp)
        yield query.waitResponse();
        expect((_8 = query.response) === null || _8 === void 0 ? void 0 : _8.data).toBe(2);
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test basic auto refetching", () => __awaiter(void 0, void 0, void 0, function* () {
        var _9, _10, _11;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(10);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port, {
            fetchingInterval: 100,
        });
        yield new Promise((resolve) => {
            setTimeout(resolve, 150);
        });
        // Should not fetch until starting observed.
        expect(query.response).toBeUndefined();
        let disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data >= 5) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        yield new Promise((resolve) => {
            setTimeout(resolve, 450);
        });
        expect((_9 = query.response) === null || _9 === void 0 ? void 0 : _9.data).toBe(4);
        disposer();
        // After becoming unobserved, refetching should stop.
        yield new Promise((resolve) => {
            setTimeout(resolve, 150);
        });
        expect((_10 = query.response) === null || _10 === void 0 ? void 0 : _10.data).toBe(4);
        // Now, refetching should be restarted.
        disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response &&
                (query.response.data < 4 || query.response.data >= 8)) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        yield new Promise((resolve) => {
            setTimeout(resolve, 250);
        });
        expect((_11 = query.response) === null || _11 === void 0 ? void 0 : _11.data).toBe(7);
        disposer();
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test auto refetching with cache", () => __awaiter(void 0, void 0, void 0, function* () {
        var _12;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(10);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port, {
            cacheMaxAge: 150,
            fetchingInterval: 100,
        });
        yield new Promise((resolve) => {
            setTimeout(resolve, 150);
        });
        // Should not fetch until starting observed.
        expect(query.response).toBeUndefined();
        const disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data >= 3) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        yield new Promise((resolve) => {
            setTimeout(resolve, 450);
        });
        expect((_12 = query.response) === null || _12 === void 0 ? void 0 : _12.data).toBe(2);
        disposer();
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test set url before start not make query", () => __awaiter(void 0, void 0, void 0, function* () {
        // Setting url before `start` should not make a query.
        // This permits to determine the url conditionally before starting.
        var _13;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(10);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port, {}, "/invalid");
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        // Should not fetch until starting observed.
        expect(query.response).toBeUndefined();
        query.changeURL("/test");
        const disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data !== 0) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        expect((_13 = query.response) === null || _13 === void 0 ? void 0 : _13.data).toBe(0);
        disposer();
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test set url before query controller ready not make query", () => __awaiter(void 0, void 0, void 0, function* () {
        // Setting url before `DeferInitialQueryController` is ready should not make a query.
        // This permits to determine the url conditionally before query controller is ready.
        var _14;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer, getNum } = createTestServer(10);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port, {}, "/invalid");
        const queryController = new query_1.DeferInitialQueryController();
        query_1.ObservableQueryBase.experimentalDeferInitialQueryController = queryController;
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        expect(query.isObserved).toBe(false);
        expect(query.isStarted).toBe(false);
        expect(query.isFetching).toBe(false);
        // Should not fetch until starting observed.
        expect(query.response).toBeUndefined();
        const disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data !== 0) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        expect(query.isObserved).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        query.changeURL("/test");
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        query.changeURL("/invalid");
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        query.changeURL("/test");
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        expect(abortSpy).toBeCalledTimes(0);
        expect(getNum()).toBe(0);
        expect(query.isObserved).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        queryController.ready();
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        expect(query.isObserved).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.error).toBeUndefined();
        expect((_14 = query.response) === null || _14 === void 0 ? void 0 : _14.data).toBe(0);
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        disposer();
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        expect(getNum()).toBe(1);
        query_1.ObservableQuery.experimentalDeferInitialQueryController = undefined;
        closeServer();
    }));
    it("test set url before query controller ready not make query (with cache max age option)", () => __awaiter(void 0, void 0, void 0, function* () {
        // Setting url before `DeferInitialQueryController` is ready should not make a query.
        // This permits to determine the url conditionally before query controller is ready.
        var _15;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer, getNum } = createTestServer(10);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port, {
            cacheMaxAge: 100,
        }, "/invalid");
        const queryController = new query_1.DeferInitialQueryController();
        query_1.ObservableQueryBase.experimentalDeferInitialQueryController = queryController;
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        expect(query.isObserved).toBe(false);
        expect(query.isStarted).toBe(false);
        expect(query.isFetching).toBe(false);
        // Should not fetch until starting observed.
        expect(query.response).toBeUndefined();
        const disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data !== 0) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        expect(query.isObserved).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        query.changeURL("/test");
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        query.changeURL("/invalid");
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        query.changeURL("/test");
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        expect(abortSpy).toBeCalledTimes(0);
        expect(getNum()).toBe(0);
        expect(query.isObserved).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        queryController.ready();
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        expect(query.isObserved).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.error).toBeUndefined();
        expect((_15 = query.response) === null || _15 === void 0 ? void 0 : _15.data).toBe(0);
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        disposer();
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        expect(getNum()).toBe(1);
        query_1.ObservableQuery.experimentalDeferInitialQueryController = undefined;
        closeServer();
    }));
    it("test set url on start not make query", () => __awaiter(void 0, void 0, void 0, function* () {
        // Setting url on `onStart()` method should not make a query.
        // This permits to determine the url conditionally on `onStart()`.
        var _16;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer, getNum } = createTestServer(10);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockOnStartObservableQuery(memStore, port, {}, "/invalid", {
            onStartUrl: "/test",
            onStartDelay: 100,
        });
        expect(query.isObserved).toBe(false);
        expect(query.isStarted).toBe(false);
        expect(query.isFetching).toBe(false);
        // Should not fetch until starting observed.
        expect(query.response).toBeUndefined();
        const disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data !== 0) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        expect(query.isObserved).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        yield new Promise((resolve) => {
            setTimeout(resolve, 10);
        });
        // Not yet onStart() finished due to delay.
        expect(query.isObserved).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        expect(abortSpy).toBeCalledTimes(0);
        expect(getNum()).toBe(0);
        yield new Promise((resolve) => {
            setTimeout(resolve, 150);
        });
        expect(query.isObserved).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.error).toBeUndefined();
        expect((_16 = query.response) === null || _16 === void 0 ? void 0 : _16.data).toBe(0);
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        expect(getNum()).toBe(1);
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        disposer();
        closeServer();
    }));
    it("test set url on start not make query (cancellation before onStart() complete)", () => __awaiter(void 0, void 0, void 0, function* () {
        // Setting url on `onStart()` method should not make a query.
        // This permits to determine the url conditionally on `onStart()`.
        var _17;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer, getNum } = createTestServer(10);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockOnStartObservableQuery(memStore, port, {}, "/invalid", {
            onStartUrl: "/test",
            onStartDelay: 200,
        });
        expect(query.isObserved).toBe(false);
        expect(query.isStarted).toBe(false);
        expect(query.isFetching).toBe(false);
        // Should not fetch until starting observed.
        expect(query.response).toBeUndefined();
        let disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data !== 0) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        expect(query.isObserved).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        // Dispose the observer before the start delay passed.
        yield new Promise((resolve) => {
            setTimeout(() => {
                disposer();
                resolve();
            }, 50);
        });
        expect(query.isObserved).toBe(false);
        expect(query.isStarted).toBe(false);
        expect(query.isFetching).toBe(false);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        expect(abortSpy).toBeCalledTimes(0);
        expect(getNum()).toBe(0);
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data !== 0) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        expect(query.isObserved).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        yield new Promise((resolve) => {
            setTimeout(resolve, 300);
        });
        expect(query.isObserved).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.error).toBeUndefined();
        expect((_17 = query.response) === null || _17 === void 0 ? void 0 : _17.data).toBe(0);
        yield new Promise((resolve) => {
            setTimeout(resolve, 500);
        });
        expect(getNum()).toBe(1);
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        disposer();
        closeServer();
    }));
    it("test cancel not make query before onStart() complete", () => __awaiter(void 0, void 0, void 0, function* () {
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer, getNum } = createTestServer(10);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockOnStartObservableQuery(memStore, port, {}, "/test", {
            onStartDelay: 200,
        });
        expect(query.isObserved).toBe(false);
        expect(query.isStarted).toBe(false);
        expect(query.isFetching).toBe(false);
        // Should not fetch until starting observed.
        expect(query.response).toBeUndefined();
        const disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        expect(query.isObserved).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        yield new Promise((resolve) => {
            setTimeout(resolve, 10);
        });
        // Not yet onStart() finished due to delay.
        expect(query.isObserved).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        expect(abortSpy).toBeCalledTimes(0);
        expect(getNum()).toBe(0);
        disposer();
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        expect(query.isObserved).toBe(false);
        expect(query.isStarted).toBe(false);
        expect(query.isFetching).toBe(false);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        expect(getNum()).toBe(0);
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test synchronous setUrl not make multiple queries", () => __awaiter(void 0, void 0, void 0, function* () {
        var _18, _19, _20;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer, getNum } = createTestServer(10);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port);
        expect(query.isObserved).toBe(false);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(false);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        const disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data >= 2) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        // Wait query starts
        yield new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, 50);
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect((_18 = query.response) === null || _18 === void 0 ? void 0 : _18.data).toBe(0);
        query.changeURL("/invalid");
        query.changeURL("/error1");
        query.changeURL("/error2");
        query.changeURL("/error3");
        query.changeURL("/test");
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect((_19 = query.response) === null || _19 === void 0 ? void 0 : _19.data).toBe(0);
        // Wait before close.
        yield new Promise((resolve) => {
            setTimeout(resolve, 50);
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect((_20 = query.response) === null || _20 === void 0 ? void 0 : _20.data).toBe(1);
        disposer();
        expect(getNum()).toBe(2);
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test synchronous setUrl not make multiple queries when onStart is async", () => __awaiter(void 0, void 0, void 0, function* () {
        var _21, _22, _23;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer, getNum } = createTestServer(50);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockOnStartObservableQuery(memStore, port, {}, "/test", {
            onStartDelay: 50,
            onStartUrl: "/test",
        });
        query.changeURL("/invalid");
        expect(query.isObserved).toBe(false);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(false);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        const disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response && query.response.data >= 2) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        query.changeURL("/error1");
        query.changeURL("/error2");
        yield new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, 20);
        });
        query.changeURL("/error2");
        query.changeURL("/error3");
        query.changeURL("/test");
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect(query.response).toBeUndefined();
        // Wait query starts
        yield new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, 150);
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect((_21 = query.response) === null || _21 === void 0 ? void 0 : _21.data).toBe(0);
        query.changeURL("/invalid");
        query.changeURL("/error1");
        query.changeURL("/error2");
        query.changeURL("/error3");
        query.changeURL("/test");
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(true);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect((_22 = query.response) === null || _22 === void 0 ? void 0 : _22.data).toBe(0);
        // Wait before close.
        yield new Promise((resolve) => {
            setTimeout(resolve, 150);
        });
        expect(query.isObserved).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.isStarted).toBe(true);
        expect(query.error).toBeUndefined();
        expect((_23 = query.response) === null || _23 === void 0 ? void 0 : _23.data).toBe(1);
        disposer();
        expect(getNum()).toBe(2);
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
    it("test error message", () => __awaiter(void 0, void 0, void 0, function* () {
        var _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35;
        const abortSpy = jest.spyOn(AbortController.prototype, "abort");
        const { port, closeServer } = createTestServer(1);
        const memStore = new common_1.MemoryKVStore("test");
        const query = new MockObservableQuery(memStore, port, {}, "/error1");
        const disposer = mobx_1.autorun(() => {
            // This makes the response observed. Thus, fetching starts.
            if (query.response) {
                throw new Error();
            }
        }, {
            onError: (e) => {
                throw e;
            },
        });
        yield new Promise((resolve) => {
            setTimeout(resolve, 20);
        });
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.isObserved).toBe(true);
        expect(query.response).toBeUndefined();
        expect((_24 = query.error) === null || _24 === void 0 ? void 0 : _24.status).toBe(503);
        expect((_25 = query.error) === null || _25 === void 0 ? void 0 : _25.statusText).toBe("Service Unavailable");
        expect((_26 = query.error) === null || _26 === void 0 ? void 0 : _26.message).toBe("Service Unavailable");
        expect((_27 = query.error) === null || _27 === void 0 ? void 0 : _27.data).toBe("");
        query.changeURL("/error2");
        yield new Promise((resolve) => {
            setTimeout(resolve, 20);
        });
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.isObserved).toBe(true);
        expect(query.response).toBeUndefined();
        expect((_28 = query.error) === null || _28 === void 0 ? void 0 : _28.status).toBe(400);
        expect((_29 = query.error) === null || _29 === void 0 ? void 0 : _29.statusText).toBe("Bad Request");
        expect((_30 = query.error) === null || _30 === void 0 ? void 0 : _30.message).toBe("message text");
        expect((_31 = query.error) === null || _31 === void 0 ? void 0 : _31.data).toBe("message text");
        query.changeURL("/error3");
        yield new Promise((resolve) => {
            setTimeout(resolve, 20);
        });
        expect(query.isStarted).toBe(true);
        expect(query.isFetching).toBe(false);
        expect(query.isObserved).toBe(true);
        expect(query.response).toBeUndefined();
        expect((_32 = query.error) === null || _32 === void 0 ? void 0 : _32.status).toBe(400);
        expect((_33 = query.error) === null || _33 === void 0 ? void 0 : _33.statusText).toBe("Bad Request");
        expect((_34 = query.error) === null || _34 === void 0 ? void 0 : _34.message).toBe("message text");
        expect((_35 = query.error) === null || _35 === void 0 ? void 0 : _35.data).toStrictEqual({ message: "message text" });
        disposer();
        expect(abortSpy).toBeCalledTimes(0);
        abortSpy.mockRestore();
        closeServer();
    }));
});
//# sourceMappingURL=query.spec.js.map