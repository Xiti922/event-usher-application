{"ast":null,"code":"\"use strict\";\n\n// Copyright (C) 2016-2017 Tony Arcieri, Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst block_1 = require(\"../internals/block\");\nconst constant_time_1 = require(\"../internals/constant-time\");\nconst ctz_1 = require(\"../internals/ctz\");\nconst xor_1 = require(\"../internals/xor\");\n// Number of L blocks to precompute (i.e. µ in the PMAC paper)\n// TODO: dynamically compute these as needed\nconst PRECOMPUTED_BLOCKS = 31;\n/**\n * Polyfill for the AES-PMAC message authentication code\n *\n * Uses a non-constant-time (lookup table-based) AES polyfill.\n * See polyfill/aes.ts for more information on the security impact.\n */\nclass PMAC {\n  constructor(cipher, l, lInv) {\n    /**\n     * finished is set true when we are done processing a message, and forbids\n     * any subsequent writes until we reset the internal state\n     */\n    this._finished = false;\n    this._cipher = cipher;\n    this._L = l;\n    this._LInv = lInv;\n    this._buffer = new block_1.default();\n    this._bufferPos = 0;\n    this._counter = 0;\n    this._offset = new block_1.default();\n    this._tag = new block_1.default();\n  }\n  /** Create a new CMAC instance from the given key */\n  static importKey(provider, keyData) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const cipher = yield provider.importBlockCipherKey(keyData);\n      /**\n       * L is defined as follows (quoted from the PMAC paper):\n       *\n       * Equation 1:\n       *\n       *     a · x =\n       *         a<<1 if firstbit(a)=0\n       *         (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n       *\n       * Equation 2:\n       *\n       *     a · x⁻¹ =\n       *         a>>1 if lastbit(a)=0\n       *         (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n       *\n       * Let L(0) ← L. For i ∈ [1..µ], compute L(i) ← L(i − 1) · x by\n       * Equation (1) using a shift and a conditional xor.\n       *\n       * Compute L(−1) ← L · x⁻¹ by Equation (2), using a shift and a\n       * conditional xor.\n       *\n       * Save the values L(−1), L(0), L(1), L(2), ..., L(µ) in a table.\n       * (Alternatively, [ed: as we have done in this codebase] defer computing\n       * some or  all of these L(i) values until the value is actually needed.)\n       */\n      const tmp = new block_1.default();\n      yield cipher.encryptBlock(tmp);\n      const l = new Array(PRECOMPUTED_BLOCKS);\n      for (let i = 0; i < PRECOMPUTED_BLOCKS; i++) {\n        l[i] = tmp.clone();\n        tmp.dbl();\n      }\n      /**\n       * Compute L(−1) ← L · x⁻¹:\n       *\n       *     a>>1 if lastbit(a)=0\n       *     (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n       */\n      const lInv = l[0].clone();\n      const lastBit = lInv.data[block_1.default.SIZE - 1] & 0x01;\n      for (let i = block_1.default.SIZE - 1; i > 0; i--) {\n        const carry = constant_time_1.select(lInv.data[i - 1] & 1, 0x80, 0);\n        lInv.data[i] = lInv.data[i] >>> 1 | carry;\n      }\n      lInv.data[0] >>>= 1;\n      lInv.data[0] ^= constant_time_1.select(lastBit, 0x80, 0);\n      lInv.data[block_1.default.SIZE - 1] ^= constant_time_1.select(lastBit, block_1.default.R >>> 1, 0);\n      return new PMAC(cipher, l, lInv);\n    });\n  }\n  reset() {\n    this._buffer.clear();\n    this._bufferPos = 0;\n    this._counter = 0;\n    this._offset.clear();\n    this._tag.clear();\n    this._finished = false;\n    return this;\n  }\n  clear() {\n    this.reset();\n    this._cipher.clear();\n  }\n  update(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._finished) {\n        throw new Error(\"pmac: already finished\");\n      }\n      const left = block_1.default.SIZE - this._bufferPos;\n      let dataPos = 0;\n      let dataLength = data.length;\n      // Finish filling the internal buf with the message\n      if (dataLength > left) {\n        this._buffer.data.set(data.slice(0, left), this._bufferPos);\n        dataPos += left;\n        dataLength -= left;\n        yield this._processBuffer();\n      }\n      // So long as we have more than a blocks worth of data, compute\n      // whole-sized blocks at a time.\n      while (dataLength > block_1.default.SIZE) {\n        this._buffer.data.set(data.slice(dataPos, dataPos + block_1.default.SIZE));\n        dataPos += block_1.default.SIZE;\n        dataLength -= block_1.default.SIZE;\n        yield this._processBuffer();\n      }\n      if (dataLength > 0) {\n        this._buffer.data.set(data.slice(dataPos, dataPos + dataLength), this._bufferPos);\n        this._bufferPos += dataLength;\n      }\n      return this;\n    });\n  }\n  finish() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._finished) {\n        throw new Error(\"pmac: already finished\");\n      }\n      if (this._bufferPos === block_1.default.SIZE) {\n        xor_1.xor(this._tag.data, this._buffer.data);\n        xor_1.xor(this._tag.data, this._LInv.data);\n      } else {\n        xor_1.xor(this._tag.data, this._buffer.data.slice(0, this._bufferPos));\n        this._tag.data[this._bufferPos] ^= 0x80;\n      }\n      yield this._cipher.encryptBlock(this._tag);\n      this._finished = true;\n      return this._tag.clone().data;\n    });\n  }\n  // Update the internal tag state based on the buffer contents\n  _processBuffer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      xor_1.xor(this._offset.data, this._L[ctz_1.ctz(this._counter + 1)].data);\n      xor_1.xor(this._buffer.data, this._offset.data);\n      this._counter++;\n      yield this._cipher.encryptBlock(this._buffer);\n      xor_1.xor(this._tag.data, this._buffer.data);\n      this._bufferPos = 0;\n    });\n  }\n}\nexports.PMAC = PMAC;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","block_1","require","constant_time_1","ctz_1","xor_1","PRECOMPUTED_BLOCKS","PMAC","constructor","cipher","l","lInv","_finished","_cipher","_L","_LInv","_buffer","default","_bufferPos","_counter","_offset","_tag","importKey","provider","keyData","importBlockCipherKey","tmp","encryptBlock","Array","i","clone","dbl","lastBit","data","SIZE","carry","select","R","reset","clear","update","Error","left","dataPos","dataLength","length","set","slice","_processBuffer","finish","xor","ctz"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/miscreant/release/mac/pmac.js"],"sourcesContent":["\"use strict\";\n// Copyright (C) 2016-2017 Tony Arcieri, Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst block_1 = require(\"../internals/block\");\nconst constant_time_1 = require(\"../internals/constant-time\");\nconst ctz_1 = require(\"../internals/ctz\");\nconst xor_1 = require(\"../internals/xor\");\n// Number of L blocks to precompute (i.e. µ in the PMAC paper)\n// TODO: dynamically compute these as needed\nconst PRECOMPUTED_BLOCKS = 31;\n/**\n * Polyfill for the AES-PMAC message authentication code\n *\n * Uses a non-constant-time (lookup table-based) AES polyfill.\n * See polyfill/aes.ts for more information on the security impact.\n */\nclass PMAC {\n    constructor(cipher, l, lInv) {\n        /**\n         * finished is set true when we are done processing a message, and forbids\n         * any subsequent writes until we reset the internal state\n         */\n        this._finished = false;\n        this._cipher = cipher;\n        this._L = l;\n        this._LInv = lInv;\n        this._buffer = new block_1.default();\n        this._bufferPos = 0;\n        this._counter = 0;\n        this._offset = new block_1.default();\n        this._tag = new block_1.default();\n    }\n    /** Create a new CMAC instance from the given key */\n    static importKey(provider, keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cipher = yield provider.importBlockCipherKey(keyData);\n            /**\n             * L is defined as follows (quoted from the PMAC paper):\n             *\n             * Equation 1:\n             *\n             *     a · x =\n             *         a<<1 if firstbit(a)=0\n             *         (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n             *\n             * Equation 2:\n             *\n             *     a · x⁻¹ =\n             *         a>>1 if lastbit(a)=0\n             *         (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n             *\n             * Let L(0) ← L. For i ∈ [1..µ], compute L(i) ← L(i − 1) · x by\n             * Equation (1) using a shift and a conditional xor.\n             *\n             * Compute L(−1) ← L · x⁻¹ by Equation (2), using a shift and a\n             * conditional xor.\n             *\n             * Save the values L(−1), L(0), L(1), L(2), ..., L(µ) in a table.\n             * (Alternatively, [ed: as we have done in this codebase] defer computing\n             * some or  all of these L(i) values until the value is actually needed.)\n             */\n            const tmp = new block_1.default();\n            yield cipher.encryptBlock(tmp);\n            const l = new Array(PRECOMPUTED_BLOCKS);\n            for (let i = 0; i < PRECOMPUTED_BLOCKS; i++) {\n                l[i] = tmp.clone();\n                tmp.dbl();\n            }\n            /**\n             * Compute L(−1) ← L · x⁻¹:\n             *\n             *     a>>1 if lastbit(a)=0\n             *     (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n             */\n            const lInv = l[0].clone();\n            const lastBit = lInv.data[block_1.default.SIZE - 1] & 0x01;\n            for (let i = block_1.default.SIZE - 1; i > 0; i--) {\n                const carry = constant_time_1.select(lInv.data[i - 1] & 1, 0x80, 0);\n                lInv.data[i] = (lInv.data[i] >>> 1) | carry;\n            }\n            lInv.data[0] >>>= 1;\n            lInv.data[0] ^= constant_time_1.select(lastBit, 0x80, 0);\n            lInv.data[block_1.default.SIZE - 1] ^= constant_time_1.select(lastBit, block_1.default.R >>> 1, 0);\n            return new PMAC(cipher, l, lInv);\n        });\n    }\n    reset() {\n        this._buffer.clear();\n        this._bufferPos = 0;\n        this._counter = 0;\n        this._offset.clear();\n        this._tag.clear();\n        this._finished = false;\n        return this;\n    }\n    clear() {\n        this.reset();\n        this._cipher.clear();\n    }\n    update(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._finished) {\n                throw new Error(\"pmac: already finished\");\n            }\n            const left = block_1.default.SIZE - this._bufferPos;\n            let dataPos = 0;\n            let dataLength = data.length;\n            // Finish filling the internal buf with the message\n            if (dataLength > left) {\n                this._buffer.data.set(data.slice(0, left), this._bufferPos);\n                dataPos += left;\n                dataLength -= left;\n                yield this._processBuffer();\n            }\n            // So long as we have more than a blocks worth of data, compute\n            // whole-sized blocks at a time.\n            while (dataLength > block_1.default.SIZE) {\n                this._buffer.data.set(data.slice(dataPos, dataPos + block_1.default.SIZE));\n                dataPos += block_1.default.SIZE;\n                dataLength -= block_1.default.SIZE;\n                yield this._processBuffer();\n            }\n            if (dataLength > 0) {\n                this._buffer.data.set(data.slice(dataPos, dataPos + dataLength), this._bufferPos);\n                this._bufferPos += dataLength;\n            }\n            return this;\n        });\n    }\n    finish() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._finished) {\n                throw new Error(\"pmac: already finished\");\n            }\n            if (this._bufferPos === block_1.default.SIZE) {\n                xor_1.xor(this._tag.data, this._buffer.data);\n                xor_1.xor(this._tag.data, this._LInv.data);\n            }\n            else {\n                xor_1.xor(this._tag.data, this._buffer.data.slice(0, this._bufferPos));\n                this._tag.data[this._bufferPos] ^= 0x80;\n            }\n            yield this._cipher.encryptBlock(this._tag);\n            this._finished = true;\n            return this._tag.clone().data;\n        });\n    }\n    // Update the internal tag state based on the buffer contents\n    _processBuffer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            xor_1.xor(this._offset.data, this._L[ctz_1.ctz(this._counter + 1)].data);\n            xor_1.xor(this._buffer.data, this._offset.data);\n            this._counter++;\n            yield this._cipher.encryptBlock(this._buffer);\n            xor_1.xor(this._tag.data, this._buffer.data);\n            this._bufferPos = 0;\n        });\n    }\n}\nexports.PMAC = PMAC;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}