{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InteractionService = void 0;\nconst router_1 = require(\"@keplr-wallet/router\");\nconst foreground_1 = require(\"./foreground\");\nclass InteractionService {\n  constructor(eventMsgRequester, rng) {\n    this.eventMsgRequester = eventMsgRequester;\n    this.rng = rng;\n    this.waitingMap = new Map();\n    this.resolverMap = new Map();\n  }\n  init() {\n    // noop\n  }\n  // Dispatch the event to the frontend. Don't wait any interaction.\n  // And, don't ensure that the event is delivered successfully, just ignore the any errors.\n  dispatchEvent(port, type, data) {\n    if (!type) {\n      throw new router_1.KeplrError(\"interaction\", 101, \"Type should not be empty\");\n    }\n    const msg = new foreground_1.PushEventDataMsg({\n      type,\n      data\n    });\n    this.eventMsgRequester.sendMessage(port, msg).catch(e => {\n      console.log(`Failed to send the event to ${port}: ${e.message}`);\n    });\n  }\n  waitApprove(env, url, type, data, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!type) {\n        throw new router_1.KeplrError(\"interaction\", 101, \"Type should not be empty\");\n      }\n      // TODO: Add timeout?\n      const interactionWaitingData = yield this.addDataToMap(type, env.isInternalMsg, data);\n      const msg = new foreground_1.PushInteractionDataMsg(interactionWaitingData);\n      return yield this.wait(msg.data.id, () => {\n        env.requestInteraction(url, msg, options);\n      });\n    });\n  }\n  wait(id, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.resolverMap.has(id)) {\n        throw new router_1.KeplrError(\"interaction\", 100, \"Id is aleady in use\");\n      }\n      return new Promise((resolve, reject) => {\n        this.resolverMap.set(id, {\n          onApprove: resolve,\n          onReject: reject\n        });\n        fn();\n      });\n    });\n  }\n  approve(id, result) {\n    if (this.resolverMap.has(id)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.resolverMap.get(id).onApprove(result);\n      this.resolverMap.delete(id);\n    }\n    this.removeDataFromMap(id);\n  }\n  reject(id) {\n    if (this.resolverMap.has(id)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.resolverMap.get(id).onReject(new Error(\"Request rejected\"));\n      this.resolverMap.delete(id);\n    }\n    this.removeDataFromMap(id);\n  }\n  addDataToMap(type, isInternal, data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const bytes = new Uint8Array(8);\n      const id = Array.from(yield this.rng(bytes)).map(value => {\n        return value.toString(16);\n      }).join(\"\");\n      const interactionWaitingData = {\n        id,\n        type,\n        isInternal,\n        data\n      };\n      if (this.waitingMap.has(id)) {\n        throw new router_1.KeplrError(\"interaction\", 100, \"Id is aleady in use\");\n      }\n      this.waitingMap.set(id, interactionWaitingData);\n      return interactionWaitingData;\n    });\n  }\n  removeDataFromMap(id) {\n    this.waitingMap.delete(id);\n  }\n}\nexports.InteractionService = InteractionService;","map":{"version":3,"mappings":"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","names":["InteractionService","constructor","eventMsgRequester","rng","Map","init","dispatchEvent","port","type","data","router_1","msg","foreground_1","sendMessage","catch","e","console","log","message","waitApprove","env","url","options","interactionWaitingData","addDataToMap","isInternalMsg","wait","id","requestInteraction","fn","resolverMap","has","Promise","resolve","reject","set","onApprove","onReject","approve","result","get","delete","removeDataFromMap","Error","isInternal","bytes","Uint8Array","Array","from","map","value","toString","join","waitingMap","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/background/src/interaction/service.ts"],"sourcesContent":["import { InteractionWaitingData } from \"./types\";\nimport {\n  Env,\n  FnRequestInteractionOptions,\n  KeplrError,\n  MessageRequester,\n} from \"@keplr-wallet/router\";\nimport { PushEventDataMsg, PushInteractionDataMsg } from \"./foreground\";\nimport { RNG } from \"@keplr-wallet/crypto\";\n\nexport class InteractionService {\n  protected waitingMap: Map<string, InteractionWaitingData> = new Map();\n  protected resolverMap: Map<\n    string,\n    { onApprove: (result: unknown) => void; onReject: (e: Error) => void }\n  > = new Map();\n\n  constructor(\n    protected readonly eventMsgRequester: MessageRequester,\n    protected readonly rng: RNG\n  ) {}\n\n  init() {\n    // noop\n  }\n\n  // Dispatch the event to the frontend. Don't wait any interaction.\n  // And, don't ensure that the event is delivered successfully, just ignore the any errors.\n  dispatchEvent(port: string, type: string, data: unknown) {\n    if (!type) {\n      throw new KeplrError(\"interaction\", 101, \"Type should not be empty\");\n    }\n\n    const msg = new PushEventDataMsg({\n      type,\n      data,\n    });\n\n    this.eventMsgRequester.sendMessage(port, msg).catch((e) => {\n      console.log(`Failed to send the event to ${port}: ${e.message}`);\n    });\n  }\n\n  async waitApprove(\n    env: Env,\n    url: string,\n    type: string,\n    data: unknown,\n    options?: FnRequestInteractionOptions\n  ): Promise<unknown> {\n    if (!type) {\n      throw new KeplrError(\"interaction\", 101, \"Type should not be empty\");\n    }\n\n    // TODO: Add timeout?\n    const interactionWaitingData = await this.addDataToMap(\n      type,\n      env.isInternalMsg,\n      data\n    );\n\n    const msg = new PushInteractionDataMsg(interactionWaitingData);\n\n    return await this.wait(msg.data.id, () => {\n      env.requestInteraction(url, msg, options);\n    });\n  }\n\n  protected async wait(id: string, fn: () => void): Promise<unknown> {\n    if (this.resolverMap.has(id)) {\n      throw new KeplrError(\"interaction\", 100, \"Id is aleady in use\");\n    }\n\n    return new Promise<unknown>((resolve, reject) => {\n      this.resolverMap.set(id, {\n        onApprove: resolve,\n        onReject: reject,\n      });\n\n      fn();\n    });\n  }\n\n  approve(id: string, result: unknown) {\n    if (this.resolverMap.has(id)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.resolverMap.get(id)!.onApprove(result);\n      this.resolverMap.delete(id);\n    }\n\n    this.removeDataFromMap(id);\n  }\n\n  reject(id: string) {\n    if (this.resolverMap.has(id)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.resolverMap.get(id)!.onReject(new Error(\"Request rejected\"));\n      this.resolverMap.delete(id);\n    }\n\n    this.removeDataFromMap(id);\n  }\n\n  protected async addDataToMap(\n    type: string,\n    isInternal: boolean,\n    data: unknown\n  ): Promise<InteractionWaitingData> {\n    const bytes = new Uint8Array(8);\n    const id: string = Array.from(await this.rng(bytes))\n      .map((value) => {\n        return value.toString(16);\n      })\n      .join(\"\");\n\n    const interactionWaitingData: InteractionWaitingData = {\n      id,\n      type,\n      isInternal,\n      data,\n    };\n\n    if (this.waitingMap.has(id)) {\n      throw new KeplrError(\"interaction\", 100, \"Id is aleady in use\");\n    }\n\n    this.waitingMap.set(id, interactionWaitingData);\n    return interactionWaitingData;\n  }\n\n  protected removeDataFromMap(id: string) {\n    this.waitingMap.delete(id);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}