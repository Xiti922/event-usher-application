{"ast":null,"code":"import { action, extendObservable, observable, _allowStateChanges, createAtom, computed, observe, makeObservable, runInAction, keys, isObservableArray, isObservableMap, isComputed, isObservableObject, $mobx, isComputedProp, _getAdministration, getAtom, isAction, autorun, _isComputingDerivation, onBecomeUnobserved, entries, values, transaction, reaction, ObservableMap } from 'mobx';\nvar NOOP = function () {};\nvar IDENTITY = function (_) {\n  return _;\n};\nfunction fail(message) {\n  throw new Error(\"[mobx-utils] \" + message);\n}\nfunction invariant(cond, message) {\n  if (message === void 0) {\n    message = \"Illegal state\";\n  }\n  if (!cond) fail(message);\n}\nfunction addHiddenProp(object, propName, value) {\n  Object.defineProperty(object, propName, {\n    enumerable: false,\n    writable: true,\n    configurable: true,\n    value: value\n  });\n}\nvar deepFields = function (x) {\n  return x && x !== Object.prototype && Object.getOwnPropertyNames(x).concat(deepFields(Object.getPrototypeOf(x)) || []);\n};\nvar distinctDeepFields = function (x) {\n  var deepFieldsIndistinct = deepFields(x);\n  var deepFieldsDistinct = deepFieldsIndistinct.filter(function (item, index) {\n    return deepFieldsIndistinct.indexOf(item) === index;\n  });\n  return deepFieldsDistinct;\n};\nvar getAllMethodsAndProperties = function (x) {\n  return distinctDeepFields(x).filter(function (name) {\n    return name !== \"constructor\" && !~name.indexOf(\"__\");\n  });\n};\nvar PENDING = \"pending\";\nvar FULFILLED = \"fulfilled\";\nvar REJECTED = \"rejected\";\nfunction caseImpl(handlers) {\n  switch (this.state) {\n    case PENDING:\n      return handlers.pending && handlers.pending(this.value);\n    case REJECTED:\n      return handlers.rejected && handlers.rejected(this.value);\n    case FULFILLED:\n      return handlers.fulfilled ? handlers.fulfilled(this.value) : this.value;\n  }\n}\n/**\n * `fromPromise` takes a Promise, extends it with 2 observable properties that track\n * the status of the promise and returns it. The returned object has the following observable properties:\n *  - `value`: either the initial value, the value the Promise resolved to, or the value the Promise was rejected with. use `.state` if you need to be able to tell the difference.\n *  - `state`: one of `\"pending\"`, `\"fulfilled\"` or `\"rejected\"`\n *\n * And the following methods:\n * - `case({fulfilled, rejected, pending})`: maps over the result using the provided handlers, or returns `undefined` if a handler isn't available for the current promise state.\n * - `then((value: TValue) => TResult1 | PromiseLike<TResult1>, [(rejectReason: any) => any])`: chains additional handlers to the provided promise.\n *\n * The returned object implements `PromiseLike<TValue>`, so you can chain additional `Promise` handlers using `then`. You may also use it with `await` in `async` functions.\n *\n * Note that the status strings are available as constants:\n * `mobxUtils.PENDING`, `mobxUtils.REJECTED`, `mobxUtil.FULFILLED`\n *\n * fromPromise takes an optional second argument, a previously created `fromPromise` based observable.\n * This is useful to replace one promise based observable with another, without going back to an intermediate\n * \"pending\" promise state while fetching data. For example:\n *\n * @example\n * \\@observer\n * class SearchResults extends React.Component {\n *   \\@observable.ref searchResults\n *\n *   componentDidUpdate(nextProps) {\n *     if (nextProps.query !== this.props.query)\n *       this.searchResults = fromPromise(\n *         window.fetch(\"/search?q=\" + nextProps.query),\n *         // by passing, we won't render a pending state if we had a successful search query before\n *         // rather, we will keep showing the previous search results, until the new promise resolves (or rejects)\n *         this.searchResults\n *       )\n *   }\n *\n *   render() {\n *     return this.searchResults.case({\n *        pending: (staleValue) => {\n *          return staleValue || \"searching\" // <- value might set to previous results while the promise is still pending\n *        },\n *        fulfilled: (value) => {\n *          return value // the fresh results\n *        },\n *        rejected: (error) => {\n *          return \"Oops: \" + error\n *        }\n *     })\n *   }\n * }\n *\n * Observable promises can be created immediately in a certain state using\n * `fromPromise.reject(reason)` or `fromPromise.resolve(value?)`.\n * The main advantage of `fromPromise.resolve(value)` over `fromPromise(Promise.resolve(value))` is that the first _synchronously_ starts in the desired state.\n *\n * It is possible to directly create a promise using a resolve, reject function:\n * `fromPromise((resolve, reject) => setTimeout(() => resolve(true), 1000))`\n *\n * @example\n * const fetchResult = fromPromise(fetch(\"http://someurl\"))\n *\n * // combine with when..\n * when(\n *   () => fetchResult.state !== \"pending\",\n *   () => {\n *     console.log(\"Got \", fetchResult.value)\n *   }\n * )\n *\n * // or a mobx-react component..\n * const myComponent = observer(({ fetchResult }) => {\n *   switch(fetchResult.state) {\n *      case \"pending\": return <div>Loading...</div>\n *      case \"rejected\": return <div>Ooops... {fetchResult.value}</div>\n *      case \"fulfilled\": return <div>Gotcha: {fetchResult.value}</div>\n *   }\n * })\n *\n * // or using the case method instead of switch:\n *\n * const myComponent = observer(({ fetchResult }) =>\n *   fetchResult.case({\n *     pending:   () => <div>Loading...</div>,\n *     rejected:  error => <div>Ooops.. {error}</div>,\n *     fulfilled: value => <div>Gotcha: {value}</div>,\n *   }))\n *\n * // chain additional handler(s) to the resolve/reject:\n *\n * fetchResult.then(\n *   (result) =>  doSomeTransformation(result),\n *   (rejectReason) => console.error('fetchResult was rejected, reason: ' + rejectReason)\n * ).then(\n *   (transformedResult) => console.log('transformed fetchResult: ' + transformedResult)\n * )\n *\n * @param {IThenable<T>} promise The promise which will be observed\n * @param {IThenable<T>} oldPromise? The previously observed promise\n * @returns {IPromiseBasedObservable<T>}\n */\nfunction fromPromise(origPromise, oldPromise) {\n  invariant(arguments.length <= 2, \"fromPromise expects up to two arguments\");\n  invariant(typeof origPromise === \"function\" || typeof origPromise === \"object\" && origPromise && typeof origPromise.then === \"function\", \"Please pass a promise or function to fromPromise\");\n  if (origPromise.isPromiseBasedObservable === true) return origPromise;\n  if (typeof origPromise === \"function\") {\n    // If it is a (reject, resolve function, wrap it)\n    origPromise = new Promise(origPromise);\n  }\n  var promise = origPromise;\n  origPromise.then(action(\"observableFromPromise-resolve\", function (value) {\n    promise.value = value;\n    promise.state = FULFILLED;\n  }), action(\"observableFromPromise-reject\", function (reason) {\n    promise.value = reason;\n    promise.state = REJECTED;\n  }));\n  promise.isPromiseBasedObservable = true;\n  promise.case = caseImpl;\n  var oldData = oldPromise && oldPromise.state === FULFILLED ? oldPromise.value : undefined;\n  extendObservable(promise, {\n    value: oldData,\n    state: PENDING\n  }, {}, {\n    deep: false\n  });\n  return promise;\n}\n(function (fromPromise) {\n  fromPromise.reject = action(\"fromPromise.reject\", function (reason) {\n    var p = fromPromise(Promise.reject(reason));\n    p.state = REJECTED;\n    p.value = reason;\n    return p;\n  });\n  function resolveBase(value) {\n    if (value === void 0) {\n      value = undefined;\n    }\n    var p = fromPromise(Promise.resolve(value));\n    p.state = FULFILLED;\n    p.value = value;\n    return p;\n  }\n  fromPromise.resolve = action(\"fromPromise.resolve\", resolveBase);\n})(fromPromise || (fromPromise = {}));\n/**\n * Returns true if the provided value is a promise-based observable.\n * @param value any\n * @returns {boolean}\n */\nfunction isPromiseBasedObservable(value) {\n  return value && value.isPromiseBasedObservable === true;\n}\nvar __spreadArrays = undefined && undefined.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n  return r;\n};\n/**\n * Moves an item from one position to another, checking that the indexes given are within bounds.\n *\n * @example\n * const source = observable([1, 2, 3])\n * moveItem(source, 0, 1)\n * console.log(source.map(x => x)) // [2, 1, 3]\n *\n * @export\n * @param {ObservableArray<T>} target\n * @param {number} fromIndex\n * @param {number} toIndex\n * @returns {ObservableArray<T>}\n */\nfunction moveItem(target, fromIndex, toIndex) {\n  checkIndex(target, fromIndex);\n  checkIndex(target, toIndex);\n  if (fromIndex === toIndex) {\n    return;\n  }\n  var oldItems = target.slice();\n  var newItems;\n  if (fromIndex < toIndex) {\n    newItems = __spreadArrays(oldItems.slice(0, fromIndex), oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1));\n  } else {\n    // toIndex < fromIndex\n    newItems = __spreadArrays(oldItems.slice(0, toIndex), [oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n  }\n  target.replace(newItems);\n  return target;\n}\n/**\n * Checks whether the specified index is within bounds. Throws if not.\n *\n * @private\n * @param {ObservableArray<any>} target\n * @param {number }index\n */\nfunction checkIndex(target, index) {\n  if (index < 0) {\n    throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n  }\n  var length = target.length;\n  if (index >= length) {\n    throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n  }\n}\n\n/**\n * `lazyObservable` creates an observable around a `fetch` method that will not be invoked\n * until the observable is needed the first time.\n * The fetch method receives a `sink` callback which can be used to replace the\n * current value of the lazyObservable. It is allowed to call `sink` multiple times\n * to keep the lazyObservable up to date with some external resource.\n *\n * Note that it is the `current()` call itself which is being tracked by MobX,\n * so make sure that you don't dereference to early.\n *\n * @example\n * const userProfile = lazyObservable(\n *   sink => fetch(\"/myprofile\").then(profile => sink(profile))\n * )\n *\n * // use the userProfile in a React component:\n * const Profile = observer(({ userProfile }) =>\n *   userProfile.current() === undefined\n *   ? <div>Loading user profile...</div>\n *   : <div>{userProfile.current().displayName}</div>\n * )\n *\n * // triggers refresh the userProfile\n * userProfile.refresh()\n *\n * @param {(sink: (newValue: T) => void) => void} fetch method that will be called the first time the value of this observable is accessed. The provided sink can be used to produce a new value, synchronously or asynchronously\n * @param {T} [initialValue=undefined] optional initialValue that will be returned from `current` as long as the `sink` has not been called at least once\n * @returns {{\n *     current(): T,\n *     refresh(): T,\n *     reset(): T\n *     pending: boolean\n * }}\n */\nfunction lazyObservable(fetch, initialValue) {\n  if (initialValue === void 0) {\n    initialValue = undefined;\n  }\n  var started = false;\n  var value = observable.box(initialValue, {\n    deep: false\n  });\n  var pending = observable.box(false);\n  var currentFnc = function () {\n    if (!started) {\n      started = true;\n      _allowStateChanges(true, function () {\n        pending.set(true);\n      });\n      fetch(function (newValue) {\n        _allowStateChanges(true, function () {\n          value.set(newValue);\n          pending.set(false);\n        });\n      });\n    }\n    return value.get();\n  };\n  var resetFnc = action(\"lazyObservable-reset\", function () {\n    started = false;\n    value.set(initialValue);\n    return value.get();\n  });\n  return {\n    current: currentFnc,\n    refresh: function () {\n      if (started) {\n        started = false;\n        return currentFnc();\n      } else {\n        return value.get();\n      }\n    },\n    reset: function () {\n      return resetFnc();\n    },\n    get pending() {\n      return pending.get();\n    }\n  };\n}\n\n/**\n * `fromResource` creates an observable whose current state can be inspected using `.current()`,\n * and which can be kept in sync with some external datasource that can be subscribed to.\n *\n * The created observable will only subscribe to the datasource if it is in use somewhere,\n * (un)subscribing when needed. To enable `fromResource` to do that two callbacks need to be provided,\n * one to subscribe, and one to unsubscribe. The subscribe callback itself will receive a `sink` callback, which can be used\n * to update the current state of the observable, allowing observes to react.\n *\n * Whatever is passed to `sink` will be returned by `current()`. The values passed to the sink will not be converted to\n * observables automatically, but feel free to do so.\n * It is the `current()` call itself which is being tracked,\n * so make sure that you don't dereference to early.\n *\n * For inspiration, an example integration with the apollo-client on [github](https://github.com/apollostack/apollo-client/issues/503#issuecomment-241101379),\n * or the [implementation](https://github.com/mobxjs/mobx-utils/blob/1d17cf7f7f5200937f68cc0b5e7ec7f3f71dccba/src/now.ts#L43-L57) of `mobxUtils.now`\n *\n * The following example code creates an observable that connects to a `dbUserRecord`,\n * which comes from an imaginary database and notifies when it has changed.\n *\n * @example\n * function createObservableUser(dbUserRecord) {\n *   let currentSubscription;\n *   return fromResource(\n *     (sink) => {\n *       // sink the current state\n *       sink(dbUserRecord.fields)\n *       // subscribe to the record, invoke the sink callback whenever new data arrives\n *       currentSubscription = dbUserRecord.onUpdated(() => {\n *         sink(dbUserRecord.fields)\n *       })\n *     },\n *     () => {\n *       // the user observable is not in use at the moment, unsubscribe (for now)\n *       dbUserRecord.unsubscribe(currentSubscription)\n *     }\n *   )\n * }\n *\n * // usage:\n * const myUserObservable = createObservableUser(myDatabaseConnector.query(\"name = 'Michel'\"))\n *\n * // use the observable in autorun\n * autorun(() => {\n *   // printed everytime the database updates its records\n *   console.log(myUserObservable.current().displayName)\n * })\n *\n * // ... or a component\n * const userComponent = observer(({ user }) =>\n *   <div>{user.current().displayName}</div>\n * )\n *\n * @export\n * @template T\n * @param {(sink: (newValue: T) => void) => void} subscriber\n * @param {IDisposer} [unsubscriber=NOOP]\n * @param {T} [initialValue=undefined] the data that will be returned by `get()` until the `sink` has emitted its first data\n * @returns {{\n *     current(): T;\n *     dispose(): void;\n *     isAlive(): boolean;\n * }}\n */\nfunction fromResource(subscriber, unsubscriber, initialValue) {\n  if (unsubscriber === void 0) {\n    unsubscriber = NOOP;\n  }\n  if (initialValue === void 0) {\n    initialValue = undefined;\n  }\n  var isActive = false;\n  var isDisposed = false;\n  var value = initialValue;\n  var suspender = function () {\n    if (isActive) {\n      isActive = false;\n      unsubscriber();\n    }\n  };\n  var atom = createAtom(\"ResourceBasedObservable\", function () {\n    invariant(!isActive && !isDisposed);\n    isActive = true;\n    subscriber(function (newValue) {\n      _allowStateChanges(true, function () {\n        value = newValue;\n        atom.reportChanged();\n      });\n    });\n  }, suspender);\n  return {\n    current: function () {\n      invariant(!isDisposed, \"subscribingObservable has already been disposed\");\n      var isBeingTracked = atom.reportObserved();\n      if (!isBeingTracked && !isActive) console.warn(\"Called `get` of a subscribingObservable outside a reaction. Current value will be returned but no new subscription has started\");\n      return value;\n    },\n    dispose: function () {\n      isDisposed = true;\n      suspender();\n    },\n    isAlive: function () {\n      return isActive;\n    }\n  };\n}\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nfunction observableSymbol() {\n  return typeof Symbol === \"function\" && Symbol.observable || \"@@observable\";\n}\n/**\n * Converts an expression to an observable stream (a.k.a. TC 39 Observable / RxJS observable).\n * The provided expression is tracked by mobx as long as there are subscribers, automatically\n * emitting when new values become available. The expressions respect (trans)actions.\n *\n * @example\n *\n * const user = observable({\n *   firstName: \"C.S\",\n *   lastName: \"Lewis\"\n * })\n *\n * Rx.Observable\n *   .from(mobxUtils.toStream(() => user.firstname + user.lastName))\n *   .scan(nameChanges => nameChanges + 1, 0)\n *   .subscribe(nameChanges => console.log(\"Changed name \", nameChanges, \"times\"))\n *\n * @export\n * @template T\n * @param {() => T} expression\n * @param {boolean} fireImmediately (by default false)\n * @returns {IObservableStream<T>}\n */\nfunction toStream(expression, fireImmediately) {\n  var _a;\n  if (fireImmediately === void 0) {\n    fireImmediately = false;\n  }\n  var computedValue = computed(expression);\n  return _a = {\n    subscribe: function (observer) {\n      if (\"function\" === typeof observer) {\n        return {\n          unsubscribe: observe(computedValue, function (_a) {\n            var newValue = _a.newValue;\n            return observer(newValue);\n          }, fireImmediately)\n        };\n      }\n      if (observer && \"object\" === typeof observer && observer.next) {\n        return {\n          unsubscribe: observe(computedValue, function (_a) {\n            var newValue = _a.newValue;\n            return observer.next(newValue);\n          }, fireImmediately)\n        };\n      }\n      return {\n        unsubscribe: function () {}\n      };\n    }\n  }, _a[observableSymbol()] = function () {\n    return this;\n  }, _a;\n}\nvar StreamListener = /** @class */function () {\n  function StreamListener(observable, initialValue) {\n    var _this = this;\n    Object.defineProperty(this, \"current\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"subscription\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    makeObservable(this);\n    runInAction(function () {\n      _this.current = initialValue;\n      _this.subscription = observable.subscribe(_this);\n    });\n  }\n  Object.defineProperty(StreamListener.prototype, \"dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n    }\n  });\n  Object.defineProperty(StreamListener.prototype, \"next\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      this.current = value;\n    }\n  });\n  Object.defineProperty(StreamListener.prototype, \"complete\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.dispose();\n    }\n  });\n  Object.defineProperty(StreamListener.prototype, \"error\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      this.current = value;\n      this.dispose();\n    }\n  });\n  __decorate([observable.ref], StreamListener.prototype, \"current\", void 0);\n  __decorate([action.bound], StreamListener.prototype, \"next\", null);\n  __decorate([action.bound], StreamListener.prototype, \"complete\", null);\n  __decorate([action.bound], StreamListener.prototype, \"error\", null);\n  return StreamListener;\n}();\nfunction fromStream(observable, initialValue) {\n  if (initialValue === void 0) {\n    initialValue = undefined;\n  }\n  return new StreamListener(observable, initialValue);\n}\nvar __assign = undefined && undefined.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar RESERVED_NAMES = [\"model\", \"reset\", \"submit\", \"isDirty\", \"isPropertyDirty\", \"resetProperty\"];\nvar ViewModel = /** @class */function () {\n  function ViewModel(model) {\n    var _this = this;\n    Object.defineProperty(this, \"model\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: model\n    });\n    Object.defineProperty(this, \"localValues\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: observable.map({})\n    });\n    Object.defineProperty(this, \"localComputedValues\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: observable.map({})\n    });\n    Object.defineProperty(this, \"isPropertyDirty\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: function (key) {\n        return _this.localValues.has(key);\n      }\n    });\n    makeObservable(this);\n    invariant(isObservableObject(model), \"createViewModel expects an observable object\");\n    var ownMethodsAndProperties = getAllMethodsAndProperties(this);\n    // use this helper as Object.getOwnPropertyNames doesn't return getters\n    getAllMethodsAndProperties(model).forEach(function (key) {\n      var _a;\n      if (ownMethodsAndProperties.includes(key)) {\n        return;\n      }\n      if (key === $mobx || key === \"__mobxDidRunLazyInitializers\") {\n        return;\n      }\n      invariant(RESERVED_NAMES.indexOf(key) === -1, \"The propertyname \" + key + \" is reserved and cannot be used with viewModels\");\n      if (isComputedProp(model, key)) {\n        var computedBox = _getAdministration(model, key); // Fixme: there is no clear api to get the derivation\n        var get = computedBox.derivation.bind(_this);\n        var set = (_a = computedBox.setter_) === null || _a === void 0 ? void 0 : _a.bind(_this);\n        _this.localComputedValues.set(key, computed(get, {\n          set: set\n        }));\n      }\n      var descriptor = Object.getOwnPropertyDescriptor(model, key);\n      var additionalDescriptor = descriptor ? {\n        enumerable: descriptor.enumerable\n      } : {};\n      Object.defineProperty(_this, key, __assign(__assign({}, additionalDescriptor), {\n        configurable: true,\n        get: function () {\n          if (isComputedProp(model, key)) return _this.localComputedValues.get(key).get();\n          if (_this.isPropertyDirty(key)) return _this.localValues.get(key);else return _this.model[key];\n        },\n        set: action(function (value) {\n          if (isComputedProp(model, key)) {\n            _this.localComputedValues.get(key).set(value);\n          } else if (value !== _this.model[key]) {\n            _this.localValues.set(key, value);\n          } else {\n            _this.localValues.delete(key);\n          }\n        })\n      }));\n    });\n  }\n  Object.defineProperty(ViewModel.prototype, \"isDirty\", {\n    get: function () {\n      return this.localValues.size > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewModel.prototype, \"changedValues\", {\n    get: function () {\n      return new Map(this.localValues);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewModel.prototype, \"submit\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n      keys(this.localValues).forEach(function (key) {\n        var source = _this.localValues.get(key);\n        var destination = _this.model[key];\n        if (isObservableArray(destination)) {\n          destination.replace(source);\n        } else if (isObservableMap(destination)) {\n          destination.clear();\n          destination.merge(source);\n        } else if (!isComputed(source)) {\n          _this.model[key] = source;\n        }\n      });\n      this.localValues.clear();\n    }\n  });\n  Object.defineProperty(ViewModel.prototype, \"reset\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.localValues.clear();\n    }\n  });\n  Object.defineProperty(ViewModel.prototype, \"resetProperty\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (key) {\n      this.localValues.delete(key);\n    }\n  });\n  __decorate$1([computed], ViewModel.prototype, \"isDirty\", null);\n  __decorate$1([computed], ViewModel.prototype, \"changedValues\", null);\n  __decorate$1([action.bound], ViewModel.prototype, \"submit\", null);\n  __decorate$1([action.bound], ViewModel.prototype, \"reset\", null);\n  __decorate$1([action.bound], ViewModel.prototype, \"resetProperty\", null);\n  return ViewModel;\n}();\n/**\n * `createViewModel` takes an object with observable properties (model)\n * and wraps a viewmodel around it. The viewmodel proxies all enumerable properties of the original model with the following behavior:\n *  - as long as no new value has been assigned to the viewmodel property, the original property will be returned.\n *  - any future change in the model will be visible in the viewmodel as well unless the viewmodel property was dirty at the time of the attempted change.\n *  - once a new value has been assigned to a property of the viewmodel, that value will be returned during a read of that property in the future. However, the original model remain untouched until `submit()` is called.\n *\n * The viewmodel exposes the following additional methods, besides all the enumerable properties of the model:\n * - `submit()`: copies all the values of the viewmodel to the model and resets the state\n * - `reset()`: resets the state of the viewmodel, abandoning all local modifications\n * - `resetProperty(propName)`: resets the specified property of the viewmodel\n * - `isDirty`: observable property indicating if the viewModel contains any modifications\n * - `isPropertyDirty(propName)`: returns true if the specified property is dirty\n * - `changedValues`: returns a key / value map with the properties that have been changed in the model so far\n * - `model`: The original model object for which this viewModel was created\n *\n * You may use observable arrays, maps and objects with `createViewModel` but keep in mind to assign fresh instances of those to the viewmodel's properties, otherwise you would end up modifying the properties of the original model.\n * Note that if you read a non-dirty property, viewmodel only proxies the read to the model. You therefore need to assign a fresh instance not only the first time you make the assignment but also after calling `reset()` or `submit()`.\n *\n * @example\n * class Todo {\n *   \\@observable title = \"Test\"\n * }\n *\n * const model = new Todo()\n * const viewModel = createViewModel(model);\n *\n * autorun(() => console.log(viewModel.model.title, \",\", viewModel.title))\n * // prints \"Test, Test\"\n * model.title = \"Get coffee\"\n * // prints \"Get coffee, Get coffee\", viewModel just proxies to model\n * viewModel.title = \"Get tea\"\n * // prints \"Get coffee, Get tea\", viewModel's title is now dirty, and the local value will be printed\n * viewModel.submit()\n * // prints \"Get tea, Get tea\", changes submitted from the viewModel to the model, viewModel is proxying again\n * viewModel.title = \"Get cookie\"\n * // prints \"Get tea, Get cookie\" // viewModel has diverged again\n * viewModel.reset()\n * // prints \"Get tea, Get tea\", changes of the viewModel have been abandoned\n *\n * @param {T} model\n * @returns {(T & IViewModel<T>)}\n * ```\n */\nfunction createViewModel(model) {\n  return new ViewModel(model);\n}\n\n/**\n * MobX normally suspends any computed value that is not in use by any reaction,\n * and lazily re-evaluates the expression if needed outside a reaction while not in use.\n * `keepAlive` marks a computed value as always in use, meaning that it will always fresh, but never disposed automatically.\n *\n * @example\n * const obj = observable({\n *   number: 3,\n *   doubler: function() { return this.number * 2 }\n * })\n * const stop = keepAlive(obj, \"doubler\")\n *\n * @param {Object} target an object that has a computed property, created by `@computed` or `extendObservable`\n * @param {string} property the name of the property to keep alive\n * @returns {IDisposer} stops this keep alive so that the computed value goes back to normal behavior\n */\n/**\n * @example\n * const number = observable(3)\n * const doubler = computed(() => number.get() * 2)\n * const stop = keepAlive(doubler)\n * // doubler will now stay in sync reactively even when there are no further observers\n * stop()\n * // normal behavior, doubler results will be recomputed if not observed but needed, but lazily\n *\n * @param {IComputedValue<any>} computedValue created using the `computed` function\n * @returns {IDisposer} stops this keep alive so that the computed value goes back to normal behavior\n */\nfunction keepAlive(_1, _2) {\n  var computed = getAtom(_1, _2);\n  if (!computed) throw new Error(\"No computed provided, please provide an object created with `computed(() => expr)` or an object + property name\");\n  return observe(computed, function () {});\n}\n\n/**\n * `queueProcessor` takes an observable array, observes it and calls `processor`\n * once for each item added to the observable array, optionally debouncing the action\n *\n * @example\n * const pendingNotifications = observable([])\n * const stop = queueProcessor(pendingNotifications, msg => {\n *   // show Desktop notification\n *   new Notification(msg);\n * })\n *\n * // usage:\n * pendingNotifications.push(\"test!\")\n *\n * @param {T[]} observableArray observable array instance to track\n * @param {(item: T) => void} processor action to call per item\n * @param {number} [debounce=0] optional debounce time in ms. With debounce 0 the processor will run synchronously\n * @returns {IDisposer} stops the processor\n */\nfunction queueProcessor(observableArray, processor, debounce) {\n  if (debounce === void 0) {\n    debounce = 0;\n  }\n  if (!isObservableArray(observableArray)) throw new Error(\"Expected observable array as first argument\");\n  if (!isAction(processor)) processor = action(\"queueProcessor\", processor);\n  var runner = function () {\n    // construct a final set\n    var items = observableArray.slice(0);\n    // clear the queue for next iteration\n    runInAction(function () {\n      return observableArray.splice(0);\n    });\n    // fire processor\n    items.forEach(processor);\n  };\n  if (debounce > 0) return autorun(runner, {\n    delay: debounce\n  });else return autorun(runner);\n}\n\n/**\n * `chunkProcessor` takes an observable array, observes it and calls `processor`\n * once for a chunk of items added to the observable array, optionally deboucing the action.\n * The maximum chunk size can be limited by number.\n * This allows both, splitting larger into smaller chunks or (when debounced) combining smaller\n * chunks and/or single items into reasonable chunks of work.\n *\n * @example\n * const trackedActions = observable([])\n * const stop = chunkProcessor(trackedActions, chunkOfMax10Items => {\n *   sendTrackedActionsToServer(chunkOfMax10Items);\n * }, 100, 10)\n *\n * // usage:\n * trackedActions.push(\"scrolled\")\n * trackedActions.push(\"hoveredButton\")\n * // when both pushes happen within 100ms, there will be only one call to server\n *\n * @param {T[]} observableArray observable array instance to track\n * @param {(item: T[]) => void} processor action to call per item\n * @param {number} [debounce=0] optional debounce time in ms. With debounce 0 the processor will run synchronously\n * @param {number} [maxChunkSize=0] optionally do not call on full array but smaller chunks. With 0 it will process the full array.\n * @returns {IDisposer} stops the processor\n */\nfunction chunkProcessor(observableArray, processor, debounce, maxChunkSize) {\n  if (debounce === void 0) {\n    debounce = 0;\n  }\n  if (maxChunkSize === void 0) {\n    maxChunkSize = 0;\n  }\n  if (!isObservableArray(observableArray)) throw new Error(\"Expected observable array as first argument\");\n  if (!isAction(processor)) processor = action(\"chunkProcessor\", processor);\n  var runner = function () {\n    var _loop_1 = function () {\n      var chunkSize = maxChunkSize === 0 ? observableArray.length : Math.min(observableArray.length, maxChunkSize);\n      // construct a final set\n      var items = observableArray.slice(0, chunkSize);\n      // clear the slice for next iteration\n      runInAction(function () {\n        return observableArray.splice(0, chunkSize);\n      });\n      // fire processor\n      processor(items);\n    };\n    while (observableArray.length > 0) {\n      _loop_1();\n    }\n  };\n  if (debounce > 0) return autorun(runner, {\n    delay: debounce\n  });else return autorun(runner);\n}\nvar tickers = {};\n/**\n * Returns the current date time as epoch number.\n * The date time is read from an observable which is updated automatically after the given interval.\n * So basically it treats time as an observable.\n *\n * The function takes an interval as parameter, which indicates how often `now()` will return a new value.\n * If no interval is given, it will update each second. If \"frame\" is specified, it will update each time a\n * `requestAnimationFrame` is available.\n *\n * Multiple clocks with the same interval will automatically be synchronized.\n *\n * Countdown example: https://jsfiddle.net/mweststrate/na0qdmkw/\n *\n * @example\n *\n * const start = Date.now()\n *\n * autorun(() => {\n *   console.log(\"Seconds elapsed: \", (mobxUtils.now() - start) / 1000)\n * })\n *\n *\n * @export\n * @param {(number | \"frame\")} [interval=1000] interval in milliseconds about how often the interval should update\n * @returns\n */\nfunction now(interval) {\n  if (interval === void 0) {\n    interval = 1000;\n  }\n  if (!_isComputingDerivation()) {\n    // See #40\n    return Date.now();\n  }\n  if (!tickers[interval]) {\n    if (typeof interval === \"number\") tickers[interval] = createIntervalTicker(interval);else tickers[interval] = createAnimationFrameTicker();\n  }\n  return tickers[interval].current();\n}\nfunction createIntervalTicker(interval) {\n  var subscriptionHandle;\n  return fromResource(function (sink) {\n    sink(Date.now());\n    subscriptionHandle = setInterval(function () {\n      return sink(Date.now());\n    }, interval);\n  }, function () {\n    clearInterval(subscriptionHandle);\n  }, Date.now());\n}\nfunction createAnimationFrameTicker() {\n  var frameBasedTicker = fromResource(function (sink) {\n    sink(Date.now());\n    function scheduleTick() {\n      window.requestAnimationFrame(function () {\n        sink(Date.now());\n        if (frameBasedTicker.isAlive()) scheduleTick();\n      });\n    }\n    scheduleTick();\n  }, function () {}, Date.now());\n  return frameBasedTicker;\n}\n\n/**\n *`expr` can be used to create temporary computed values inside computed values.\n * Nesting computed values is useful to create cheap computations in order to prevent expensive computations from needing to run.\n * In the following example the expression prevents that a component is rerender _each time_ the selection changes;\n * instead it will only rerenders when the current todo is (de)selected.\n *\n * `expr(func)` is an alias for `computed(func).get()`.\n * Please note that the function given to `expr` is evaluated _twice_ in the scenario that the overall expression value changes.\n * It is evaluated the first time when any observables it depends on change.\n * It is evaluated a second time when a change in its value triggers the outer computed or reaction to evaluate, which recreates and reevaluates the expression.\n *\n * In the following example, the expression prevents the `TodoView` component from being re-rendered if the selection changes elsewhere.\n * Instead, the component will only re-render when the relevant todo is (de)selected, which happens much less frequently.\n *\n * @example\n * const Todo = observer((props) => {\n *     const todo = props.todo\n *     const isSelected = mobxUtils.expr(() => props.viewState.selection === todo)\n * const TodoView = observer(({ todo, editorState }) => {\n *     const isSelected = mobxUtils.expr(() => editorState.selection === todo)\n *     return <div className={isSelected ? \"todo todo-selected\" : \"todo\"}>{todo.title}</div>\n * })\n */\nfunction expr(expr) {\n  if (!_isComputingDerivation()) console.warn(\"'expr' should only be used inside other reactive functions.\");\n  // optimization: would be more efficient if the expr itself wouldn't be evaluated first on the next change, but just a 'changed' signal would be fired\n  return computed(expr).get();\n}\nvar __assign$1 = undefined && undefined.__assign || function () {\n  __assign$1 = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign$1.apply(this, arguments);\n};\nvar memoizationId = 0;\n/**\n * Creates a function that maps an object to a view.\n * The mapping is memoized.\n *\n * See the [transformer](#createtransformer-in-detail) section for more details.\n *\n * @param transformer\n * @param onCleanup\n */\nfunction createTransformer(transformer, arg2) {\n  invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n  // Memoizes: object id -> reactive view that applies transformer to the object\n  var views = {};\n  var onCleanup = undefined;\n  var keepAlive = false;\n  var debugNameGenerator = undefined;\n  if (typeof arg2 === \"object\") {\n    onCleanup = arg2.onCleanup;\n    keepAlive = arg2.keepAlive !== undefined ? arg2.keepAlive : false;\n    debugNameGenerator = arg2.debugNameGenerator;\n  } else if (typeof arg2 === \"function\") {\n    onCleanup = arg2;\n  }\n  function createView(sourceIdentifier, sourceObject) {\n    var latestValue;\n    var computedValueOptions = {};\n    if (typeof arg2 === \"object\") {\n      onCleanup = arg2.onCleanup;\n      debugNameGenerator = arg2.debugNameGenerator;\n      computedValueOptions = arg2;\n    } else if (typeof arg2 === \"function\") {\n      onCleanup = arg2;\n    } else {\n      onCleanup = undefined;\n      debugNameGenerator = undefined;\n    }\n    var prettifiedName = debugNameGenerator ? debugNameGenerator(sourceObject) : \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier;\n    var expr = computed(function () {\n      return latestValue = transformer(sourceObject);\n    }, __assign$1(__assign$1({}, computedValueOptions), {\n      name: prettifiedName\n    }));\n    if (!keepAlive) {\n      var disposer_1 = onBecomeUnobserved(expr, function () {\n        delete views[sourceIdentifier];\n        disposer_1();\n        if (onCleanup) onCleanup(latestValue, sourceObject);\n      });\n    }\n    return expr;\n  }\n  var memoWarned = false;\n  return function (object) {\n    var identifier = getMemoizationId(object);\n    var reactiveView = views[identifier];\n    if (reactiveView) return reactiveView.get();\n    if (!keepAlive && !_isComputingDerivation()) {\n      if (!memoWarned) {\n        console.warn(\"invoking a transformer from outside a reactive context won't memorized \" + \"and is cleaned up immediately, unless keepAlive is set\");\n        memoWarned = true;\n      }\n      var value = transformer(object);\n      if (onCleanup) onCleanup(value, object);\n      return value;\n    }\n    // Not in cache; create a reactive view\n    reactiveView = views[identifier] = createView(identifier, object);\n    return reactiveView.get();\n  };\n}\nfunction getMemoizationId(object) {\n  var objectType = typeof object;\n  if (objectType === \"string\") return \"string:\" + object;\n  if (objectType === \"number\") return \"number:\" + object;\n  if (object === null || objectType !== \"object\" && objectType !== \"function\") throw new Error(\"[mobx-utils] transform expected an object, function, string or number, got: \" + String(object));\n  var tid = object.$transformId;\n  if (tid === undefined) {\n    tid = \"memoizationId:\" + ++memoizationId;\n    addHiddenProp(object, \"$transformId\", tid);\n  }\n  return tid;\n}\nfunction buildPath(entry) {\n  if (!entry) return \"ROOT\";\n  var res = [];\n  while (entry.parent) {\n    res.push(entry.path);\n    entry = entry.parent;\n  }\n  return res.reverse().join(\"/\");\n}\nfunction isRecursivelyObservable(thing) {\n  return isObservableObject(thing) || isObservableArray(thing) || isObservableMap(thing);\n}\n/**\n * Given an object, deeply observes the given object.\n * It is like `observe` from mobx, but applied recursively, including all future children.\n *\n * Note that the given object cannot ever contain cycles and should be a tree.\n *\n * As benefit: path and root will be provided in the callback, so the signature of the listener is\n * (change, path, root) => void\n *\n * The returned disposer can be invoked to clean up the listener\n *\n * deepObserve cannot be used on computed values.\n *\n * @example\n * const disposer = deepObserve(target, (change, path) => {\n *    console.dir(change)\n * })\n */\nfunction deepObserve(target, listener) {\n  var entrySet = new WeakMap();\n  function genericListener(change) {\n    var entry = entrySet.get(change.object);\n    processChange(change, entry);\n    listener(change, buildPath(entry), target);\n  }\n  function processChange(change, parent) {\n    switch (change.type) {\n      // Object changes\n      case \"add\":\n        // also for map\n        observeRecursively(change.newValue, parent, change.name);\n        break;\n      case \"update\":\n        // also for array and map\n        unobserveRecursively(change.oldValue);\n        observeRecursively(change.newValue, parent, change.name || \"\" + change.index);\n        break;\n      case \"remove\": // object\n      case \"delete\":\n        // map\n        unobserveRecursively(change.oldValue);\n        break;\n      // Array changes\n      case \"splice\":\n        change.removed.map(unobserveRecursively);\n        change.added.forEach(function (value, idx) {\n          return observeRecursively(value, parent, \"\" + (change.index + idx));\n        });\n        // update paths\n        for (var i = change.index + change.addedCount; i < change.object.length; i++) {\n          if (isRecursivelyObservable(change.object[i])) {\n            var entry = entrySet.get(change.object[i]);\n            if (entry) entry.path = \"\" + i;\n          }\n        }\n        break;\n    }\n  }\n  function observeRecursively(thing, parent, path) {\n    if (isRecursivelyObservable(thing)) {\n      var entry = entrySet.get(thing);\n      if (entry) {\n        if (entry.parent !== parent || entry.path !== path)\n          // MWE: this constraint is artificial, and this tool could be made to work with cycles,\n          // but it increases administration complexity, has tricky edge cases and the meaning of 'path'\n          // would become less clear. So doesn't seem to be needed for now\n          throw new Error(\"The same observable object cannot appear twice in the same tree,\" + (\" trying to assign it to '\" + buildPath(parent) + \"/\" + path + \"',\") + (\" but it already exists at '\" + buildPath(entry.parent) + \"/\" + entry.path + \"'\"));\n      } else {\n        var entry_1 = {\n          parent: parent,\n          path: path,\n          dispose: observe(thing, genericListener)\n        };\n        entrySet.set(thing, entry_1);\n        entries(thing).forEach(function (_a) {\n          var key = _a[0],\n            value = _a[1];\n          return observeRecursively(value, entry_1, key);\n        });\n      }\n    }\n  }\n  function unobserveRecursively(thing) {\n    if (isRecursivelyObservable(thing)) {\n      var entry = entrySet.get(thing);\n      if (!entry) return;\n      entrySet.delete(thing);\n      entry.dispose();\n      values(thing).forEach(unobserveRecursively);\n    }\n  }\n  observeRecursively(target, undefined, \"\");\n  return function () {\n    unobserveRecursively(target);\n  };\n}\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * Reactively sorts a base observable array into multiple observable arrays based on the value of a\n * `groupBy: (item: T) => G` function.\n *\n * This observes the individual computed groupBy values and only updates the source and dest arrays\n * when there is an actual change, so this is far more efficient than, for example\n * `base.filter(i => groupBy(i) === 'we')`. Call #dispose() to stop tracking.\n *\n * No guarantees are made about the order of items in the grouped arrays.\n *\n * The resulting map of arrays is read-only. clear(), set(), delete() are not supported and\n * modifying the group arrays will lead to undefined behavior.\n *\n * NB: ObservableGroupMap relies on `Symbol`s. If you are targeting a platform which doesn't\n * support these natively, you will need to provide a polyfill.\n *\n * @param {array} base The array to sort into groups.\n * @param {function} groupBy The function used for grouping.\n * @param options Object with properties:\n *  `name`: Debug name of this ObservableGroupMap.\n *  `keyToName`: Function to create the debug names of the observable group arrays.\n *\n * @example\n * const slices = observable([\n *     { day: \"mo\", hours: 12 },\n *     { day: \"tu\", hours: 2 },\n * ])\n * const slicesByDay = new ObservableGroupMap(slices, (slice) => slice.day)\n * autorun(() => console.log(\n *     slicesByDay.get(\"mo\")?.length ?? 0,\n *     slicesByDay.get(\"we\"))) // outputs 1, undefined\n * slices[0].day = \"we\" // outputs 0, [{ day: \"we\", hours: 12 }]\n */\nvar ObservableGroupMap = /** @class */function (_super) {\n  __extends(ObservableGroupMap, _super);\n  function ObservableGroupMap(base, groupBy, _a) {\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.name,\n      name = _c === void 0 ? \"ogm\" + (Math.random() * 1000 | 0) : _c,\n      _d = _b.keyToName,\n      keyToName = _d === void 0 ? function (x) {\n        return \"\" + x;\n      } : _d;\n    var _this = _super.call(this) || this;\n    /**\n     * Base observable array which is being sorted into groups.\n     */\n    Object.defineProperty(_this, \"_base\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The ObservableGroupMap needs to track some state per-item. This is the name/symbol of the\n     * property used to attach the state.\n     */\n    Object.defineProperty(_this, \"_ogmInfoKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The function used to group the items.\n     */\n    Object.defineProperty(_this, \"_groupBy\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\n     * This function is used to generate the mobx debug names of the observable group arrays.\n     */\n    Object.defineProperty(_this, \"_keyToName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_disposeBaseObserver\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    _this._keyToName = keyToName;\n    _this._groupBy = groupBy;\n    _this._ogmInfoKey = Symbol(\"ogmInfo\" + name);\n    _this._base = base;\n    for (var i = 0; i < base.length; i++) {\n      _this._addItem(base[i]);\n    }\n    _this._disposeBaseObserver = observe(_this._base, function (change) {\n      if (\"splice\" === change.type) {\n        transaction(function () {\n          for (var _i = 0, _a = change.removed; _i < _a.length; _i++) {\n            var removed = _a[_i];\n            _this._removeItem(removed);\n          }\n          for (var _b = 0, _c = change.added; _b < _c.length; _b++) {\n            var added = _c[_b];\n            _this._addItem(added);\n          }\n        });\n      } else if (\"update\" === change.type) {\n        transaction(function () {\n          _this._removeItem(change.oldValue);\n          _this._addItem(change.newValue);\n        });\n      } else {\n        throw new Error(\"illegal state\");\n      }\n    });\n    return _this;\n  }\n  Object.defineProperty(ObservableGroupMap.prototype, \"clear\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      throw new Error(\"not supported\");\n    }\n  });\n  Object.defineProperty(ObservableGroupMap.prototype, \"delete\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_key) {\n      throw new Error(\"not supported\");\n    }\n  });\n  Object.defineProperty(ObservableGroupMap.prototype, \"set\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_key, _value) {\n      throw new Error(\"not supported\");\n    }\n  });\n  /**\n   * Disposes all observers created during construction and removes state added to base array\n   * items.\n   */\n  Object.defineProperty(ObservableGroupMap.prototype, \"dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._disposeBaseObserver();\n      for (var i = 0; i < this._base.length; i++) {\n        var item = this._base[i];\n        var grouperItemInfo = item[this._ogmInfoKey];\n        grouperItemInfo.reaction();\n        delete item[this._ogmInfoKey];\n      }\n    }\n  });\n  Object.defineProperty(ObservableGroupMap.prototype, \"_getGroupArr\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (key) {\n      var result = _super.prototype.get.call(this, key);\n      if (undefined === result) {\n        result = observable([], {\n          name: \"GroupArray[\" + this._keyToName(key) + \"]\",\n          deep: false\n        });\n        _super.prototype.set.call(this, key, result);\n      }\n      return result;\n    }\n  });\n  Object.defineProperty(ObservableGroupMap.prototype, \"_removeFromGroupArr\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (key, itemIndex) {\n      var arr = _super.prototype.get.call(this, key);\n      if (1 === arr.length) {\n        _super.prototype.delete.call(this, key);\n      } else if (itemIndex === arr.length - 1) {\n        // last position in array\n        arr.length--;\n      } else {\n        arr[itemIndex] = arr[arr.length - 1];\n        arr[itemIndex][this._ogmInfoKey].groupArrIndex = itemIndex;\n        arr.length--;\n      }\n    }\n  });\n  Object.defineProperty(ObservableGroupMap.prototype, \"_addItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (item) {\n      var _this = this;\n      var groupByValue = this._groupBy(item);\n      var groupArr = this._getGroupArr(groupByValue);\n      var value = {\n        groupByValue: groupByValue,\n        groupArrIndex: groupArr.length,\n        reaction: reaction(function () {\n          return _this._groupBy(item);\n        }, function (newGroupByValue, _r) {\n          var grouperItemInfo = item[_this._ogmInfoKey];\n          _this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);\n          var newGroupArr = _this._getGroupArr(newGroupByValue);\n          var newGroupArrIndex = newGroupArr.length;\n          newGroupArr.push(item);\n          grouperItemInfo.groupByValue = newGroupByValue;\n          grouperItemInfo.groupArrIndex = newGroupArrIndex;\n        })\n      };\n      Object.defineProperty(item, this._ogmInfoKey, {\n        configurable: true,\n        enumerable: false,\n        value: value\n      });\n      groupArr.push(item);\n    }\n  });\n  Object.defineProperty(ObservableGroupMap.prototype, \"_removeItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (item) {\n      var grouperItemInfo = item[this._ogmInfoKey];\n      this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);\n      grouperItemInfo.reaction();\n      delete item[this._ogmInfoKey];\n    }\n  });\n  return ObservableGroupMap;\n}(ObservableMap);\n\n/**\n * @private\n */\nvar DeepMapEntry = /** @class */function () {\n  function DeepMapEntry(base, args) {\n    Object.defineProperty(this, \"base\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: base\n    });\n    Object.defineProperty(this, \"args\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: args\n    });\n    Object.defineProperty(this, \"root\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"closest\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"closestIdx\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"isDisposed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    var current = this.closest = this.root = base;\n    var i = 0;\n    for (; i < this.args.length - 1; i++) {\n      current = current.get(args[i]);\n      if (current) this.closest = current;else break;\n    }\n    this.closestIdx = i;\n  }\n  Object.defineProperty(DeepMapEntry.prototype, \"exists\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.assertNotDisposed();\n      var l = this.args.length;\n      return this.closestIdx >= l - 1 && this.closest.has(this.args[l - 1]);\n    }\n  });\n  Object.defineProperty(DeepMapEntry.prototype, \"get\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.assertNotDisposed();\n      if (!this.exists()) throw new Error(\"Entry doesn't exist\");\n      return this.closest.get(this.args[this.args.length - 1]);\n    }\n  });\n  Object.defineProperty(DeepMapEntry.prototype, \"set\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      this.assertNotDisposed();\n      var l = this.args.length;\n      var current = this.closest;\n      // create remaining maps\n      for (var i = this.closestIdx; i < l - 1; i++) {\n        var m = new Map();\n        current.set(this.args[i], m);\n        current = m;\n      }\n      this.closestIdx = l - 1;\n      this.closest = current;\n      current.set(this.args[l - 1], value);\n    }\n  });\n  Object.defineProperty(DeepMapEntry.prototype, \"delete\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.assertNotDisposed();\n      if (!this.exists()) throw new Error(\"Entry doesn't exist\");\n      var l = this.args.length;\n      this.closest.delete(this.args[l - 1]);\n      // clean up remaining maps if needed (reconstruct stack first)\n      var c = this.root;\n      var maps = [c];\n      for (var i = 0; i < l - 1; i++) {\n        c = c.get(this.args[i]);\n        maps.push(c);\n      }\n      for (var i = maps.length - 1; i > 0; i--) {\n        if (maps[i].size === 0) maps[i - 1].delete(this.args[i - 1]);\n      }\n      this.isDisposed = true;\n    }\n  });\n  Object.defineProperty(DeepMapEntry.prototype, \"assertNotDisposed\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      // TODO: once this becomes annoying, we should introduce a reset method to re-run the constructor logic\n      if (this.isDisposed) throw new Error(\"Concurrent modification exception\");\n    }\n  });\n  return DeepMapEntry;\n}();\n/**\n * @private\n */\nvar DeepMap = /** @class */function () {\n  function DeepMap() {\n    Object.defineProperty(this, \"store\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, \"argsLength\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: -1\n    });\n    Object.defineProperty(this, \"last\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  Object.defineProperty(DeepMap.prototype, \"entry\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (args) {\n      if (this.argsLength === -1) this.argsLength = args.length;else if (this.argsLength !== args.length) throw new Error(\"DeepMap should be used with functions with a consistent length, expected: \" + this.argsLength + \", got: \" + args.length);\n      if (this.last) this.last.isDisposed = true;\n      return this.last = new DeepMapEntry(this.store, args);\n    }\n  });\n  return DeepMap;\n}();\nvar __assign$2 = undefined && undefined.__assign || function () {\n  __assign$2 = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign$2.apply(this, arguments);\n};\nvar __spreadArrays$1 = undefined && undefined.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n  return r;\n};\n/**\n * computedFn takes a function with an arbitrary amount of arguments,\n * and memoizes the output of the function based on the arguments passed in.\n *\n * computedFn(fn) returns a function with the very same signature. There is no limit on the amount of arguments\n * that is accepted. However, the amount of arguments must be constant and default arguments are not supported.\n *\n * By default the output of a function call will only be memoized as long as the\n * output is being observed.\n *\n * The function passes into `computedFn` should be pure, not be an action and only be relying on\n * observables.\n *\n * Setting `keepAlive` to `true` will cause the output to be forcefully cached forever.\n * Note that this might introduce memory leaks!\n *\n * @example\n * const store = observable({\n    a: 1,\n    b: 2,\n    c: 3,\n    m: computedFn(function(x) {\n      return this.a * this.b * x\n    })\n  })\n\n  const d = autorun(() => {\n    // store.m(3) will be cached as long as this autorun is running\n    console.log(store.m(3) * store.c)\n  })\n *\n * @param fn\n * @param keepAliveOrOptions\n */\nfunction computedFn(fn, keepAliveOrOptions) {\n  if (keepAliveOrOptions === void 0) {\n    keepAliveOrOptions = false;\n  }\n  if (isAction(fn)) throw new Error(\"computedFn shouldn't be used on actions\");\n  var memoWarned = false;\n  var i = 0;\n  var opts = typeof keepAliveOrOptions === \"boolean\" ? {\n    keepAlive: keepAliveOrOptions\n  } : keepAliveOrOptions;\n  var d = new DeepMap();\n  return function () {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var entry = d.entry(args);\n    // cache hit, return\n    if (entry.exists()) return entry.get().get();\n    // if function is invoked, and its a cache miss without reactive, there is no point in caching...\n    if (!opts.keepAlive && !_isComputingDerivation()) {\n      if (!memoWarned) {\n        console.warn(\"invoking a computedFn from outside an reactive context won't be memoized, unless keepAlive is set\");\n        memoWarned = true;\n      }\n      return fn.apply(this, args);\n    }\n    // create new entry\n    var latestValue;\n    var c = computed(function () {\n      return latestValue = fn.apply(_this, args);\n    }, __assign$2(__assign$2({}, opts), {\n      name: \"computedFn(\" + (opts.name || fn.name) + \"#\" + ++i + \")\"\n    }));\n    entry.set(c);\n    // clean up if no longer observed\n    if (!opts.keepAlive) onBecomeUnobserved(c, function () {\n      d.entry(args).delete();\n      if (opts.onCleanup) opts.onCleanup.apply(opts, __spreadArrays$1([latestValue], args));\n      latestValue = undefined;\n    });\n    // return current val\n    return c.get();\n  };\n}\nexport { FULFILLED, IDENTITY, NOOP, ObservableGroupMap, PENDING, REJECTED, ViewModel, addHiddenProp, chunkProcessor, computedFn, createTransformer, createViewModel, deepObserve, expr, fail, fromPromise, fromResource, fromStream, getAllMethodsAndProperties, invariant, isPromiseBasedObservable, keepAlive, lazyObservable, moveItem, now, queueProcessor, toStream };","map":{"version":3,"names":["action","extendObservable","observable","_allowStateChanges","createAtom","computed","observe","makeObservable","runInAction","keys","isObservableArray","isObservableMap","isComputed","isObservableObject","$mobx","isComputedProp","_getAdministration","getAtom","isAction","autorun","_isComputingDerivation","onBecomeUnobserved","entries","values","transaction","reaction","ObservableMap","NOOP","IDENTITY","_","fail","message","Error","invariant","cond","addHiddenProp","object","propName","value","Object","defineProperty","enumerable","writable","configurable","deepFields","x","prototype","getOwnPropertyNames","concat","getPrototypeOf","distinctDeepFields","deepFieldsIndistinct","deepFieldsDistinct","filter","item","index","indexOf","getAllMethodsAndProperties","name","PENDING","FULFILLED","REJECTED","caseImpl","handlers","state","pending","rejected","fulfilled","fromPromise","origPromise","oldPromise","arguments","length","then","isPromiseBasedObservable","Promise","promise","reason","case","oldData","undefined","deep","reject","p","resolveBase","resolve","__spreadArrays","s","i","il","r","Array","k","a","j","jl","moveItem","target","fromIndex","toIndex","checkIndex","oldItems","slice","newItems","replace","lazyObservable","fetch","initialValue","started","box","currentFnc","set","newValue","get","resetFnc","current","refresh","reset","fromResource","subscriber","unsubscriber","isActive","isDisposed","suspender","atom","reportChanged","isBeingTracked","reportObserved","console","warn","dispose","isAlive","__decorate","decorators","key","desc","c","getOwnPropertyDescriptor","d","Reflect","decorate","observableSymbol","Symbol","toStream","expression","fireImmediately","_a","computedValue","subscribe","observer","unsubscribe","next","StreamListener","_this","subscription","ref","bound","fromStream","__assign","assign","t","n","hasOwnProperty","call","apply","__decorate$1","RESERVED_NAMES","ViewModel","model","map","localValues","has","ownMethodsAndProperties","forEach","includes","computedBox","derivation","bind","setter_","localComputedValues","descriptor","additionalDescriptor","isPropertyDirty","delete","size","Map","source","destination","clear","merge","createViewModel","keepAlive","_1","_2","queueProcessor","observableArray","processor","debounce","runner","items","splice","delay","chunkProcessor","maxChunkSize","_loop_1","chunkSize","Math","min","tickers","now","interval","Date","createIntervalTicker","createAnimationFrameTicker","subscriptionHandle","sink","setInterval","clearInterval","frameBasedTicker","scheduleTick","window","requestAnimationFrame","expr","__assign$1","memoizationId","createTransformer","transformer","arg2","views","onCleanup","debugNameGenerator","createView","sourceIdentifier","sourceObject","latestValue","computedValueOptions","prettifiedName","disposer_1","memoWarned","identifier","getMemoizationId","reactiveView","objectType","String","tid","$transformId","buildPath","entry","res","parent","push","path","reverse","join","isRecursivelyObservable","thing","deepObserve","listener","entrySet","WeakMap","genericListener","change","processChange","type","observeRecursively","unobserveRecursively","oldValue","removed","added","idx","addedCount","entry_1","__extends","extendStatics","b","setPrototypeOf","__proto__","__","constructor","create","ObservableGroupMap","_super","base","groupBy","_b","_c","random","_d","keyToName","_keyToName","_groupBy","_ogmInfoKey","_base","_addItem","_disposeBaseObserver","_i","_removeItem","_key","_value","grouperItemInfo","result","itemIndex","arr","groupArrIndex","groupByValue","groupArr","_getGroupArr","newGroupByValue","_r","_removeFromGroupArr","newGroupArr","newGroupArrIndex","DeepMapEntry","args","closest","root","closestIdx","assertNotDisposed","l","exists","m","maps","DeepMap","argsLength","last","store","__assign$2","__spreadArrays$1","computedFn","fn","keepAliveOrOptions","opts"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/mobx-utils/mobx-utils.module.js"],"sourcesContent":["import { action, extendObservable, observable, _allowStateChanges, createAtom, computed, observe, makeObservable, runInAction, keys, isObservableArray, isObservableMap, isComputed, isObservableObject, $mobx, isComputedProp, _getAdministration, getAtom, isAction, autorun, _isComputingDerivation, onBecomeUnobserved, entries, values, transaction, reaction, ObservableMap } from 'mobx';\n\nvar NOOP = function () { };\nvar IDENTITY = function (_) { return _; };\nfunction fail(message) {\n    throw new Error(\"[mobx-utils] \" + message);\n}\nfunction invariant(cond, message) {\n    if (message === void 0) { message = \"Illegal state\"; }\n    if (!cond)\n        fail(message);\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value,\n    });\n}\nvar deepFields = function (x) {\n    return (x &&\n        x !== Object.prototype &&\n        Object.getOwnPropertyNames(x).concat(deepFields(Object.getPrototypeOf(x)) || []));\n};\nvar distinctDeepFields = function (x) {\n    var deepFieldsIndistinct = deepFields(x);\n    var deepFieldsDistinct = deepFieldsIndistinct.filter(function (item, index) { return deepFieldsIndistinct.indexOf(item) === index; });\n    return deepFieldsDistinct;\n};\nvar getAllMethodsAndProperties = function (x) {\n    return distinctDeepFields(x).filter(function (name) { return name !== \"constructor\" && !~name.indexOf(\"__\"); });\n};\n\nvar PENDING = \"pending\";\nvar FULFILLED = \"fulfilled\";\nvar REJECTED = \"rejected\";\nfunction caseImpl(handlers) {\n    switch (this.state) {\n        case PENDING:\n            return handlers.pending && handlers.pending(this.value);\n        case REJECTED:\n            return handlers.rejected && handlers.rejected(this.value);\n        case FULFILLED:\n            return handlers.fulfilled ? handlers.fulfilled(this.value) : this.value;\n    }\n}\n/**\n * `fromPromise` takes a Promise, extends it with 2 observable properties that track\n * the status of the promise and returns it. The returned object has the following observable properties:\n *  - `value`: either the initial value, the value the Promise resolved to, or the value the Promise was rejected with. use `.state` if you need to be able to tell the difference.\n *  - `state`: one of `\"pending\"`, `\"fulfilled\"` or `\"rejected\"`\n *\n * And the following methods:\n * - `case({fulfilled, rejected, pending})`: maps over the result using the provided handlers, or returns `undefined` if a handler isn't available for the current promise state.\n * - `then((value: TValue) => TResult1 | PromiseLike<TResult1>, [(rejectReason: any) => any])`: chains additional handlers to the provided promise.\n *\n * The returned object implements `PromiseLike<TValue>`, so you can chain additional `Promise` handlers using `then`. You may also use it with `await` in `async` functions.\n *\n * Note that the status strings are available as constants:\n * `mobxUtils.PENDING`, `mobxUtils.REJECTED`, `mobxUtil.FULFILLED`\n *\n * fromPromise takes an optional second argument, a previously created `fromPromise` based observable.\n * This is useful to replace one promise based observable with another, without going back to an intermediate\n * \"pending\" promise state while fetching data. For example:\n *\n * @example\n * \\@observer\n * class SearchResults extends React.Component {\n *   \\@observable.ref searchResults\n *\n *   componentDidUpdate(nextProps) {\n *     if (nextProps.query !== this.props.query)\n *       this.searchResults = fromPromise(\n *         window.fetch(\"/search?q=\" + nextProps.query),\n *         // by passing, we won't render a pending state if we had a successful search query before\n *         // rather, we will keep showing the previous search results, until the new promise resolves (or rejects)\n *         this.searchResults\n *       )\n *   }\n *\n *   render() {\n *     return this.searchResults.case({\n *        pending: (staleValue) => {\n *          return staleValue || \"searching\" // <- value might set to previous results while the promise is still pending\n *        },\n *        fulfilled: (value) => {\n *          return value // the fresh results\n *        },\n *        rejected: (error) => {\n *          return \"Oops: \" + error\n *        }\n *     })\n *   }\n * }\n *\n * Observable promises can be created immediately in a certain state using\n * `fromPromise.reject(reason)` or `fromPromise.resolve(value?)`.\n * The main advantage of `fromPromise.resolve(value)` over `fromPromise(Promise.resolve(value))` is that the first _synchronously_ starts in the desired state.\n *\n * It is possible to directly create a promise using a resolve, reject function:\n * `fromPromise((resolve, reject) => setTimeout(() => resolve(true), 1000))`\n *\n * @example\n * const fetchResult = fromPromise(fetch(\"http://someurl\"))\n *\n * // combine with when..\n * when(\n *   () => fetchResult.state !== \"pending\",\n *   () => {\n *     console.log(\"Got \", fetchResult.value)\n *   }\n * )\n *\n * // or a mobx-react component..\n * const myComponent = observer(({ fetchResult }) => {\n *   switch(fetchResult.state) {\n *      case \"pending\": return <div>Loading...</div>\n *      case \"rejected\": return <div>Ooops... {fetchResult.value}</div>\n *      case \"fulfilled\": return <div>Gotcha: {fetchResult.value}</div>\n *   }\n * })\n *\n * // or using the case method instead of switch:\n *\n * const myComponent = observer(({ fetchResult }) =>\n *   fetchResult.case({\n *     pending:   () => <div>Loading...</div>,\n *     rejected:  error => <div>Ooops.. {error}</div>,\n *     fulfilled: value => <div>Gotcha: {value}</div>,\n *   }))\n *\n * // chain additional handler(s) to the resolve/reject:\n *\n * fetchResult.then(\n *   (result) =>  doSomeTransformation(result),\n *   (rejectReason) => console.error('fetchResult was rejected, reason: ' + rejectReason)\n * ).then(\n *   (transformedResult) => console.log('transformed fetchResult: ' + transformedResult)\n * )\n *\n * @param {IThenable<T>} promise The promise which will be observed\n * @param {IThenable<T>} oldPromise? The previously observed promise\n * @returns {IPromiseBasedObservable<T>}\n */\nfunction fromPromise(origPromise, oldPromise) {\n    invariant(arguments.length <= 2, \"fromPromise expects up to two arguments\");\n    invariant(typeof origPromise === \"function\" ||\n        (typeof origPromise === \"object\" &&\n            origPromise &&\n            typeof origPromise.then === \"function\"), \"Please pass a promise or function to fromPromise\");\n    if (origPromise.isPromiseBasedObservable === true)\n        return origPromise;\n    if (typeof origPromise === \"function\") {\n        // If it is a (reject, resolve function, wrap it)\n        origPromise = new Promise(origPromise);\n    }\n    var promise = origPromise;\n    origPromise.then(action(\"observableFromPromise-resolve\", function (value) {\n        promise.value = value;\n        promise.state = FULFILLED;\n    }), action(\"observableFromPromise-reject\", function (reason) {\n        promise.value = reason;\n        promise.state = REJECTED;\n    }));\n    promise.isPromiseBasedObservable = true;\n    promise.case = caseImpl;\n    var oldData = oldPromise && oldPromise.state === FULFILLED\n        ? oldPromise.value\n        : undefined;\n    extendObservable(promise, {\n        value: oldData,\n        state: PENDING,\n    }, {}, { deep: false });\n    return promise;\n}\n(function (fromPromise) {\n    fromPromise.reject = action(\"fromPromise.reject\", function (reason) {\n        var p = fromPromise(Promise.reject(reason));\n        p.state = REJECTED;\n        p.value = reason;\n        return p;\n    });\n    function resolveBase(value) {\n        if (value === void 0) { value = undefined; }\n        var p = fromPromise(Promise.resolve(value));\n        p.state = FULFILLED;\n        p.value = value;\n        return p;\n    }\n    fromPromise.resolve = action(\"fromPromise.resolve\", resolveBase);\n})(fromPromise || (fromPromise = {}));\n/**\n * Returns true if the provided value is a promise-based observable.\n * @param value any\n * @returns {boolean}\n */\nfunction isPromiseBasedObservable(value) {\n    return value && value.isPromiseBasedObservable === true;\n}\n\nvar __spreadArrays = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n/**\n * Moves an item from one position to another, checking that the indexes given are within bounds.\n *\n * @example\n * const source = observable([1, 2, 3])\n * moveItem(source, 0, 1)\n * console.log(source.map(x => x)) // [2, 1, 3]\n *\n * @export\n * @param {ObservableArray<T>} target\n * @param {number} fromIndex\n * @param {number} toIndex\n * @returns {ObservableArray<T>}\n */\nfunction moveItem(target, fromIndex, toIndex) {\n    checkIndex(target, fromIndex);\n    checkIndex(target, toIndex);\n    if (fromIndex === toIndex) {\n        return;\n    }\n    var oldItems = target.slice();\n    var newItems;\n    if (fromIndex < toIndex) {\n        newItems = __spreadArrays(oldItems.slice(0, fromIndex), oldItems.slice(fromIndex + 1, toIndex + 1), [\n            oldItems[fromIndex]\n        ], oldItems.slice(toIndex + 1));\n    }\n    else {\n        // toIndex < fromIndex\n        newItems = __spreadArrays(oldItems.slice(0, toIndex), [\n            oldItems[fromIndex]\n        ], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n    }\n    target.replace(newItems);\n    return target;\n}\n/**\n * Checks whether the specified index is within bounds. Throws if not.\n *\n * @private\n * @param {ObservableArray<any>} target\n * @param {number }index\n */\nfunction checkIndex(target, index) {\n    if (index < 0) {\n        throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n    }\n    var length = target.length;\n    if (index >= length) {\n        throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n    }\n}\n\n/**\n * `lazyObservable` creates an observable around a `fetch` method that will not be invoked\n * until the observable is needed the first time.\n * The fetch method receives a `sink` callback which can be used to replace the\n * current value of the lazyObservable. It is allowed to call `sink` multiple times\n * to keep the lazyObservable up to date with some external resource.\n *\n * Note that it is the `current()` call itself which is being tracked by MobX,\n * so make sure that you don't dereference to early.\n *\n * @example\n * const userProfile = lazyObservable(\n *   sink => fetch(\"/myprofile\").then(profile => sink(profile))\n * )\n *\n * // use the userProfile in a React component:\n * const Profile = observer(({ userProfile }) =>\n *   userProfile.current() === undefined\n *   ? <div>Loading user profile...</div>\n *   : <div>{userProfile.current().displayName}</div>\n * )\n *\n * // triggers refresh the userProfile\n * userProfile.refresh()\n *\n * @param {(sink: (newValue: T) => void) => void} fetch method that will be called the first time the value of this observable is accessed. The provided sink can be used to produce a new value, synchronously or asynchronously\n * @param {T} [initialValue=undefined] optional initialValue that will be returned from `current` as long as the `sink` has not been called at least once\n * @returns {{\n *     current(): T,\n *     refresh(): T,\n *     reset(): T\n *     pending: boolean\n * }}\n */\nfunction lazyObservable(fetch, initialValue) {\n    if (initialValue === void 0) { initialValue = undefined; }\n    var started = false;\n    var value = observable.box(initialValue, { deep: false });\n    var pending = observable.box(false);\n    var currentFnc = function () {\n        if (!started) {\n            started = true;\n            _allowStateChanges(true, function () {\n                pending.set(true);\n            });\n            fetch(function (newValue) {\n                _allowStateChanges(true, function () {\n                    value.set(newValue);\n                    pending.set(false);\n                });\n            });\n        }\n        return value.get();\n    };\n    var resetFnc = action(\"lazyObservable-reset\", function () {\n        started = false;\n        value.set(initialValue);\n        return value.get();\n    });\n    return {\n        current: currentFnc,\n        refresh: function () {\n            if (started) {\n                started = false;\n                return currentFnc();\n            }\n            else {\n                return value.get();\n            }\n        },\n        reset: function () {\n            return resetFnc();\n        },\n        get pending() {\n            return pending.get();\n        },\n    };\n}\n\n/**\n * `fromResource` creates an observable whose current state can be inspected using `.current()`,\n * and which can be kept in sync with some external datasource that can be subscribed to.\n *\n * The created observable will only subscribe to the datasource if it is in use somewhere,\n * (un)subscribing when needed. To enable `fromResource` to do that two callbacks need to be provided,\n * one to subscribe, and one to unsubscribe. The subscribe callback itself will receive a `sink` callback, which can be used\n * to update the current state of the observable, allowing observes to react.\n *\n * Whatever is passed to `sink` will be returned by `current()`. The values passed to the sink will not be converted to\n * observables automatically, but feel free to do so.\n * It is the `current()` call itself which is being tracked,\n * so make sure that you don't dereference to early.\n *\n * For inspiration, an example integration with the apollo-client on [github](https://github.com/apollostack/apollo-client/issues/503#issuecomment-241101379),\n * or the [implementation](https://github.com/mobxjs/mobx-utils/blob/1d17cf7f7f5200937f68cc0b5e7ec7f3f71dccba/src/now.ts#L43-L57) of `mobxUtils.now`\n *\n * The following example code creates an observable that connects to a `dbUserRecord`,\n * which comes from an imaginary database and notifies when it has changed.\n *\n * @example\n * function createObservableUser(dbUserRecord) {\n *   let currentSubscription;\n *   return fromResource(\n *     (sink) => {\n *       // sink the current state\n *       sink(dbUserRecord.fields)\n *       // subscribe to the record, invoke the sink callback whenever new data arrives\n *       currentSubscription = dbUserRecord.onUpdated(() => {\n *         sink(dbUserRecord.fields)\n *       })\n *     },\n *     () => {\n *       // the user observable is not in use at the moment, unsubscribe (for now)\n *       dbUserRecord.unsubscribe(currentSubscription)\n *     }\n *   )\n * }\n *\n * // usage:\n * const myUserObservable = createObservableUser(myDatabaseConnector.query(\"name = 'Michel'\"))\n *\n * // use the observable in autorun\n * autorun(() => {\n *   // printed everytime the database updates its records\n *   console.log(myUserObservable.current().displayName)\n * })\n *\n * // ... or a component\n * const userComponent = observer(({ user }) =>\n *   <div>{user.current().displayName}</div>\n * )\n *\n * @export\n * @template T\n * @param {(sink: (newValue: T) => void) => void} subscriber\n * @param {IDisposer} [unsubscriber=NOOP]\n * @param {T} [initialValue=undefined] the data that will be returned by `get()` until the `sink` has emitted its first data\n * @returns {{\n *     current(): T;\n *     dispose(): void;\n *     isAlive(): boolean;\n * }}\n */\nfunction fromResource(subscriber, unsubscriber, initialValue) {\n    if (unsubscriber === void 0) { unsubscriber = NOOP; }\n    if (initialValue === void 0) { initialValue = undefined; }\n    var isActive = false;\n    var isDisposed = false;\n    var value = initialValue;\n    var suspender = function () {\n        if (isActive) {\n            isActive = false;\n            unsubscriber();\n        }\n    };\n    var atom = createAtom(\"ResourceBasedObservable\", function () {\n        invariant(!isActive && !isDisposed);\n        isActive = true;\n        subscriber(function (newValue) {\n            _allowStateChanges(true, function () {\n                value = newValue;\n                atom.reportChanged();\n            });\n        });\n    }, suspender);\n    return {\n        current: function () {\n            invariant(!isDisposed, \"subscribingObservable has already been disposed\");\n            var isBeingTracked = atom.reportObserved();\n            if (!isBeingTracked && !isActive)\n                console.warn(\"Called `get` of a subscribingObservable outside a reaction. Current value will be returned but no new subscription has started\");\n            return value;\n        },\n        dispose: function () {\n            isDisposed = true;\n            suspender();\n        },\n        isAlive: function () { return isActive; },\n    };\n}\n\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nfunction observableSymbol() {\n    return (typeof Symbol === \"function\" && Symbol.observable) || \"@@observable\";\n}\n/**\n * Converts an expression to an observable stream (a.k.a. TC 39 Observable / RxJS observable).\n * The provided expression is tracked by mobx as long as there are subscribers, automatically\n * emitting when new values become available. The expressions respect (trans)actions.\n *\n * @example\n *\n * const user = observable({\n *   firstName: \"C.S\",\n *   lastName: \"Lewis\"\n * })\n *\n * Rx.Observable\n *   .from(mobxUtils.toStream(() => user.firstname + user.lastName))\n *   .scan(nameChanges => nameChanges + 1, 0)\n *   .subscribe(nameChanges => console.log(\"Changed name \", nameChanges, \"times\"))\n *\n * @export\n * @template T\n * @param {() => T} expression\n * @param {boolean} fireImmediately (by default false)\n * @returns {IObservableStream<T>}\n */\nfunction toStream(expression, fireImmediately) {\n    var _a;\n    if (fireImmediately === void 0) { fireImmediately = false; }\n    var computedValue = computed(expression);\n    return _a = {\n            subscribe: function (observer) {\n                if (\"function\" === typeof observer) {\n                    return {\n                        unsubscribe: observe(computedValue, function (_a) {\n                            var newValue = _a.newValue;\n                            return observer(newValue);\n                        }, fireImmediately),\n                    };\n                }\n                if (observer && \"object\" === typeof observer && observer.next) {\n                    return {\n                        unsubscribe: observe(computedValue, function (_a) {\n                            var newValue = _a.newValue;\n                            return observer.next(newValue);\n                        }, fireImmediately),\n                    };\n                }\n                return {\n                    unsubscribe: function () { },\n                };\n            }\n        },\n        _a[observableSymbol()] = function () {\n            return this;\n        },\n        _a;\n}\nvar StreamListener = /** @class */ (function () {\n    function StreamListener(observable, initialValue) {\n        var _this = this;\n        Object.defineProperty(this, \"current\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"subscription\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        makeObservable(this);\n        runInAction(function () {\n            _this.current = initialValue;\n            _this.subscription = observable.subscribe(_this);\n        });\n    }\n    Object.defineProperty(StreamListener.prototype, \"dispose\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (this.subscription) {\n                this.subscription.unsubscribe();\n            }\n        }\n    });\n    Object.defineProperty(StreamListener.prototype, \"next\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value) {\n            this.current = value;\n        }\n    });\n    Object.defineProperty(StreamListener.prototype, \"complete\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this.dispose();\n        }\n    });\n    Object.defineProperty(StreamListener.prototype, \"error\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value) {\n            this.current = value;\n            this.dispose();\n        }\n    });\n    __decorate([\n        observable.ref\n    ], StreamListener.prototype, \"current\", void 0);\n    __decorate([\n        action.bound\n    ], StreamListener.prototype, \"next\", null);\n    __decorate([\n        action.bound\n    ], StreamListener.prototype, \"complete\", null);\n    __decorate([\n        action.bound\n    ], StreamListener.prototype, \"error\", null);\n    return StreamListener;\n}());\nfunction fromStream(observable, initialValue) {\n    if (initialValue === void 0) { initialValue = undefined; }\n    return new StreamListener(observable, initialValue);\n}\n\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar RESERVED_NAMES = [\"model\", \"reset\", \"submit\", \"isDirty\", \"isPropertyDirty\", \"resetProperty\"];\nvar ViewModel = /** @class */ (function () {\n    function ViewModel(model) {\n        var _this = this;\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: model\n        });\n        Object.defineProperty(this, \"localValues\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: observable.map({})\n        });\n        Object.defineProperty(this, \"localComputedValues\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: observable.map({})\n        });\n        Object.defineProperty(this, \"isPropertyDirty\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: function (key) {\n                return _this.localValues.has(key);\n            }\n        });\n        makeObservable(this);\n        invariant(isObservableObject(model), \"createViewModel expects an observable object\");\n        var ownMethodsAndProperties = getAllMethodsAndProperties(this);\n        // use this helper as Object.getOwnPropertyNames doesn't return getters\n        getAllMethodsAndProperties(model).forEach(function (key) {\n            var _a;\n            if (ownMethodsAndProperties.includes(key)) {\n                return;\n            }\n            if (key === $mobx || key === \"__mobxDidRunLazyInitializers\") {\n                return;\n            }\n            invariant(RESERVED_NAMES.indexOf(key) === -1, \"The propertyname \" + key + \" is reserved and cannot be used with viewModels\");\n            if (isComputedProp(model, key)) {\n                var computedBox = _getAdministration(model, key); // Fixme: there is no clear api to get the derivation\n                var get = computedBox.derivation.bind(_this);\n                var set = (_a = computedBox.setter_) === null || _a === void 0 ? void 0 : _a.bind(_this);\n                _this.localComputedValues.set(key, computed(get, { set: set }));\n            }\n            var descriptor = Object.getOwnPropertyDescriptor(model, key);\n            var additionalDescriptor = descriptor ? { enumerable: descriptor.enumerable } : {};\n            Object.defineProperty(_this, key, __assign(__assign({}, additionalDescriptor), { configurable: true, get: function () {\n                    if (isComputedProp(model, key))\n                        return _this.localComputedValues.get(key).get();\n                    if (_this.isPropertyDirty(key))\n                        return _this.localValues.get(key);\n                    else\n                        return _this.model[key];\n                }, set: action(function (value) {\n                    if (isComputedProp(model, key)) {\n                        _this.localComputedValues.get(key).set(value);\n                    }\n                    else if (value !== _this.model[key]) {\n                        _this.localValues.set(key, value);\n                    }\n                    else {\n                        _this.localValues.delete(key);\n                    }\n                }) }));\n        });\n    }\n    Object.defineProperty(ViewModel.prototype, \"isDirty\", {\n        get: function () {\n            return this.localValues.size > 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewModel.prototype, \"changedValues\", {\n        get: function () {\n            return new Map(this.localValues);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewModel.prototype, \"submit\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            var _this = this;\n            keys(this.localValues).forEach(function (key) {\n                var source = _this.localValues.get(key);\n                var destination = _this.model[key];\n                if (isObservableArray(destination)) {\n                    destination.replace(source);\n                }\n                else if (isObservableMap(destination)) {\n                    destination.clear();\n                    destination.merge(source);\n                }\n                else if (!isComputed(source)) {\n                    _this.model[key] = source;\n                }\n            });\n            this.localValues.clear();\n        }\n    });\n    Object.defineProperty(ViewModel.prototype, \"reset\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this.localValues.clear();\n        }\n    });\n    Object.defineProperty(ViewModel.prototype, \"resetProperty\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (key) {\n            this.localValues.delete(key);\n        }\n    });\n    __decorate$1([\n        computed\n    ], ViewModel.prototype, \"isDirty\", null);\n    __decorate$1([\n        computed\n    ], ViewModel.prototype, \"changedValues\", null);\n    __decorate$1([\n        action.bound\n    ], ViewModel.prototype, \"submit\", null);\n    __decorate$1([\n        action.bound\n    ], ViewModel.prototype, \"reset\", null);\n    __decorate$1([\n        action.bound\n    ], ViewModel.prototype, \"resetProperty\", null);\n    return ViewModel;\n}());\n/**\n * `createViewModel` takes an object with observable properties (model)\n * and wraps a viewmodel around it. The viewmodel proxies all enumerable properties of the original model with the following behavior:\n *  - as long as no new value has been assigned to the viewmodel property, the original property will be returned.\n *  - any future change in the model will be visible in the viewmodel as well unless the viewmodel property was dirty at the time of the attempted change.\n *  - once a new value has been assigned to a property of the viewmodel, that value will be returned during a read of that property in the future. However, the original model remain untouched until `submit()` is called.\n *\n * The viewmodel exposes the following additional methods, besides all the enumerable properties of the model:\n * - `submit()`: copies all the values of the viewmodel to the model and resets the state\n * - `reset()`: resets the state of the viewmodel, abandoning all local modifications\n * - `resetProperty(propName)`: resets the specified property of the viewmodel\n * - `isDirty`: observable property indicating if the viewModel contains any modifications\n * - `isPropertyDirty(propName)`: returns true if the specified property is dirty\n * - `changedValues`: returns a key / value map with the properties that have been changed in the model so far\n * - `model`: The original model object for which this viewModel was created\n *\n * You may use observable arrays, maps and objects with `createViewModel` but keep in mind to assign fresh instances of those to the viewmodel's properties, otherwise you would end up modifying the properties of the original model.\n * Note that if you read a non-dirty property, viewmodel only proxies the read to the model. You therefore need to assign a fresh instance not only the first time you make the assignment but also after calling `reset()` or `submit()`.\n *\n * @example\n * class Todo {\n *   \\@observable title = \"Test\"\n * }\n *\n * const model = new Todo()\n * const viewModel = createViewModel(model);\n *\n * autorun(() => console.log(viewModel.model.title, \",\", viewModel.title))\n * // prints \"Test, Test\"\n * model.title = \"Get coffee\"\n * // prints \"Get coffee, Get coffee\", viewModel just proxies to model\n * viewModel.title = \"Get tea\"\n * // prints \"Get coffee, Get tea\", viewModel's title is now dirty, and the local value will be printed\n * viewModel.submit()\n * // prints \"Get tea, Get tea\", changes submitted from the viewModel to the model, viewModel is proxying again\n * viewModel.title = \"Get cookie\"\n * // prints \"Get tea, Get cookie\" // viewModel has diverged again\n * viewModel.reset()\n * // prints \"Get tea, Get tea\", changes of the viewModel have been abandoned\n *\n * @param {T} model\n * @returns {(T & IViewModel<T>)}\n * ```\n */\nfunction createViewModel(model) {\n    return new ViewModel(model);\n}\n\n/**\n * MobX normally suspends any computed value that is not in use by any reaction,\n * and lazily re-evaluates the expression if needed outside a reaction while not in use.\n * `keepAlive` marks a computed value as always in use, meaning that it will always fresh, but never disposed automatically.\n *\n * @example\n * const obj = observable({\n *   number: 3,\n *   doubler: function() { return this.number * 2 }\n * })\n * const stop = keepAlive(obj, \"doubler\")\n *\n * @param {Object} target an object that has a computed property, created by `@computed` or `extendObservable`\n * @param {string} property the name of the property to keep alive\n * @returns {IDisposer} stops this keep alive so that the computed value goes back to normal behavior\n */\n/**\n * @example\n * const number = observable(3)\n * const doubler = computed(() => number.get() * 2)\n * const stop = keepAlive(doubler)\n * // doubler will now stay in sync reactively even when there are no further observers\n * stop()\n * // normal behavior, doubler results will be recomputed if not observed but needed, but lazily\n *\n * @param {IComputedValue<any>} computedValue created using the `computed` function\n * @returns {IDisposer} stops this keep alive so that the computed value goes back to normal behavior\n */\nfunction keepAlive(_1, _2) {\n    var computed = getAtom(_1, _2);\n    if (!computed)\n        throw new Error(\"No computed provided, please provide an object created with `computed(() => expr)` or an object + property name\");\n    return observe(computed, function () { });\n}\n\n/**\n * `queueProcessor` takes an observable array, observes it and calls `processor`\n * once for each item added to the observable array, optionally debouncing the action\n *\n * @example\n * const pendingNotifications = observable([])\n * const stop = queueProcessor(pendingNotifications, msg => {\n *   // show Desktop notification\n *   new Notification(msg);\n * })\n *\n * // usage:\n * pendingNotifications.push(\"test!\")\n *\n * @param {T[]} observableArray observable array instance to track\n * @param {(item: T) => void} processor action to call per item\n * @param {number} [debounce=0] optional debounce time in ms. With debounce 0 the processor will run synchronously\n * @returns {IDisposer} stops the processor\n */\nfunction queueProcessor(observableArray, processor, debounce) {\n    if (debounce === void 0) { debounce = 0; }\n    if (!isObservableArray(observableArray))\n        throw new Error(\"Expected observable array as first argument\");\n    if (!isAction(processor))\n        processor = action(\"queueProcessor\", processor);\n    var runner = function () {\n        // construct a final set\n        var items = observableArray.slice(0);\n        // clear the queue for next iteration\n        runInAction(function () { return observableArray.splice(0); });\n        // fire processor\n        items.forEach(processor);\n    };\n    if (debounce > 0)\n        return autorun(runner, { delay: debounce });\n    else\n        return autorun(runner);\n}\n\n/**\n * `chunkProcessor` takes an observable array, observes it and calls `processor`\n * once for a chunk of items added to the observable array, optionally deboucing the action.\n * The maximum chunk size can be limited by number.\n * This allows both, splitting larger into smaller chunks or (when debounced) combining smaller\n * chunks and/or single items into reasonable chunks of work.\n *\n * @example\n * const trackedActions = observable([])\n * const stop = chunkProcessor(trackedActions, chunkOfMax10Items => {\n *   sendTrackedActionsToServer(chunkOfMax10Items);\n * }, 100, 10)\n *\n * // usage:\n * trackedActions.push(\"scrolled\")\n * trackedActions.push(\"hoveredButton\")\n * // when both pushes happen within 100ms, there will be only one call to server\n *\n * @param {T[]} observableArray observable array instance to track\n * @param {(item: T[]) => void} processor action to call per item\n * @param {number} [debounce=0] optional debounce time in ms. With debounce 0 the processor will run synchronously\n * @param {number} [maxChunkSize=0] optionally do not call on full array but smaller chunks. With 0 it will process the full array.\n * @returns {IDisposer} stops the processor\n */\nfunction chunkProcessor(observableArray, processor, debounce, maxChunkSize) {\n    if (debounce === void 0) { debounce = 0; }\n    if (maxChunkSize === void 0) { maxChunkSize = 0; }\n    if (!isObservableArray(observableArray))\n        throw new Error(\"Expected observable array as first argument\");\n    if (!isAction(processor))\n        processor = action(\"chunkProcessor\", processor);\n    var runner = function () {\n        var _loop_1 = function () {\n            var chunkSize = maxChunkSize === 0\n                ? observableArray.length\n                : Math.min(observableArray.length, maxChunkSize);\n            // construct a final set\n            var items = observableArray.slice(0, chunkSize);\n            // clear the slice for next iteration\n            runInAction(function () { return observableArray.splice(0, chunkSize); });\n            // fire processor\n            processor(items);\n        };\n        while (observableArray.length > 0) {\n            _loop_1();\n        }\n    };\n    if (debounce > 0)\n        return autorun(runner, { delay: debounce });\n    else\n        return autorun(runner);\n}\n\nvar tickers = {};\n/**\n * Returns the current date time as epoch number.\n * The date time is read from an observable which is updated automatically after the given interval.\n * So basically it treats time as an observable.\n *\n * The function takes an interval as parameter, which indicates how often `now()` will return a new value.\n * If no interval is given, it will update each second. If \"frame\" is specified, it will update each time a\n * `requestAnimationFrame` is available.\n *\n * Multiple clocks with the same interval will automatically be synchronized.\n *\n * Countdown example: https://jsfiddle.net/mweststrate/na0qdmkw/\n *\n * @example\n *\n * const start = Date.now()\n *\n * autorun(() => {\n *   console.log(\"Seconds elapsed: \", (mobxUtils.now() - start) / 1000)\n * })\n *\n *\n * @export\n * @param {(number | \"frame\")} [interval=1000] interval in milliseconds about how often the interval should update\n * @returns\n */\nfunction now(interval) {\n    if (interval === void 0) { interval = 1000; }\n    if (!_isComputingDerivation()) {\n        // See #40\n        return Date.now();\n    }\n    if (!tickers[interval]) {\n        if (typeof interval === \"number\")\n            tickers[interval] = createIntervalTicker(interval);\n        else\n            tickers[interval] = createAnimationFrameTicker();\n    }\n    return tickers[interval].current();\n}\nfunction createIntervalTicker(interval) {\n    var subscriptionHandle;\n    return fromResource(function (sink) {\n        sink(Date.now());\n        subscriptionHandle = setInterval(function () { return sink(Date.now()); }, interval);\n    }, function () {\n        clearInterval(subscriptionHandle);\n    }, Date.now());\n}\nfunction createAnimationFrameTicker() {\n    var frameBasedTicker = fromResource(function (sink) {\n        sink(Date.now());\n        function scheduleTick() {\n            window.requestAnimationFrame(function () {\n                sink(Date.now());\n                if (frameBasedTicker.isAlive())\n                    scheduleTick();\n            });\n        }\n        scheduleTick();\n    }, function () { }, Date.now());\n    return frameBasedTicker;\n}\n\n/**\n *`expr` can be used to create temporary computed values inside computed values.\n * Nesting computed values is useful to create cheap computations in order to prevent expensive computations from needing to run.\n * In the following example the expression prevents that a component is rerender _each time_ the selection changes;\n * instead it will only rerenders when the current todo is (de)selected.\n *\n * `expr(func)` is an alias for `computed(func).get()`.\n * Please note that the function given to `expr` is evaluated _twice_ in the scenario that the overall expression value changes.\n * It is evaluated the first time when any observables it depends on change.\n * It is evaluated a second time when a change in its value triggers the outer computed or reaction to evaluate, which recreates and reevaluates the expression.\n *\n * In the following example, the expression prevents the `TodoView` component from being re-rendered if the selection changes elsewhere.\n * Instead, the component will only re-render when the relevant todo is (de)selected, which happens much less frequently.\n *\n * @example\n * const Todo = observer((props) => {\n *     const todo = props.todo\n *     const isSelected = mobxUtils.expr(() => props.viewState.selection === todo)\n * const TodoView = observer(({ todo, editorState }) => {\n *     const isSelected = mobxUtils.expr(() => editorState.selection === todo)\n *     return <div className={isSelected ? \"todo todo-selected\" : \"todo\"}>{todo.title}</div>\n * })\n */\nfunction expr(expr) {\n    if (!_isComputingDerivation())\n        console.warn(\"'expr' should only be used inside other reactive functions.\");\n    // optimization: would be more efficient if the expr itself wouldn't be evaluated first on the next change, but just a 'changed' signal would be fired\n    return computed(expr).get();\n}\n\nvar __assign$1 = (undefined && undefined.__assign) || function () {\n    __assign$1 = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$1.apply(this, arguments);\n};\nvar memoizationId = 0;\n/**\n * Creates a function that maps an object to a view.\n * The mapping is memoized.\n *\n * See the [transformer](#createtransformer-in-detail) section for more details.\n *\n * @param transformer\n * @param onCleanup\n */\nfunction createTransformer(transformer, arg2) {\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n    // Memoizes: object id -> reactive view that applies transformer to the object\n    var views = {};\n    var onCleanup = undefined;\n    var keepAlive = false;\n    var debugNameGenerator = undefined;\n    if (typeof arg2 === \"object\") {\n        onCleanup = arg2.onCleanup;\n        keepAlive = arg2.keepAlive !== undefined ? arg2.keepAlive : false;\n        debugNameGenerator = arg2.debugNameGenerator;\n    }\n    else if (typeof arg2 === \"function\") {\n        onCleanup = arg2;\n    }\n    function createView(sourceIdentifier, sourceObject) {\n        var latestValue;\n        var computedValueOptions = {};\n        if (typeof arg2 === \"object\") {\n            onCleanup = arg2.onCleanup;\n            debugNameGenerator = arg2.debugNameGenerator;\n            computedValueOptions = arg2;\n        }\n        else if (typeof arg2 === \"function\") {\n            onCleanup = arg2;\n        }\n        else {\n            onCleanup = undefined;\n            debugNameGenerator = undefined;\n        }\n        var prettifiedName = debugNameGenerator\n            ? debugNameGenerator(sourceObject)\n            : \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier;\n        var expr = computed(function () {\n            return (latestValue = transformer(sourceObject));\n        }, __assign$1(__assign$1({}, computedValueOptions), { name: prettifiedName }));\n        if (!keepAlive) {\n            var disposer_1 = onBecomeUnobserved(expr, function () {\n                delete views[sourceIdentifier];\n                disposer_1();\n                if (onCleanup)\n                    onCleanup(latestValue, sourceObject);\n            });\n        }\n        return expr;\n    }\n    var memoWarned = false;\n    return function (object) {\n        var identifier = getMemoizationId(object);\n        var reactiveView = views[identifier];\n        if (reactiveView)\n            return reactiveView.get();\n        if (!keepAlive && !_isComputingDerivation()) {\n            if (!memoWarned) {\n                console.warn(\"invoking a transformer from outside a reactive context won't memorized \" +\n                    \"and is cleaned up immediately, unless keepAlive is set\");\n                memoWarned = true;\n            }\n            var value = transformer(object);\n            if (onCleanup)\n                onCleanup(value, object);\n            return value;\n        }\n        // Not in cache; create a reactive view\n        reactiveView = views[identifier] = createView(identifier, object);\n        return reactiveView.get();\n    };\n}\nfunction getMemoizationId(object) {\n    var objectType = typeof object;\n    if (objectType === \"string\")\n        return \"string:\" + object;\n    if (objectType === \"number\")\n        return \"number:\" + object;\n    if (object === null || (objectType !== \"object\" && objectType !== \"function\"))\n        throw new Error(\"[mobx-utils] transform expected an object, function, string or number, got: \" + String(object));\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = \"memoizationId:\" + ++memoizationId;\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\n\nfunction buildPath(entry) {\n    if (!entry)\n        return \"ROOT\";\n    var res = [];\n    while (entry.parent) {\n        res.push(entry.path);\n        entry = entry.parent;\n    }\n    return res.reverse().join(\"/\");\n}\nfunction isRecursivelyObservable(thing) {\n    return isObservableObject(thing) || isObservableArray(thing) || isObservableMap(thing);\n}\n/**\n * Given an object, deeply observes the given object.\n * It is like `observe` from mobx, but applied recursively, including all future children.\n *\n * Note that the given object cannot ever contain cycles and should be a tree.\n *\n * As benefit: path and root will be provided in the callback, so the signature of the listener is\n * (change, path, root) => void\n *\n * The returned disposer can be invoked to clean up the listener\n *\n * deepObserve cannot be used on computed values.\n *\n * @example\n * const disposer = deepObserve(target, (change, path) => {\n *    console.dir(change)\n * })\n */\nfunction deepObserve(target, listener) {\n    var entrySet = new WeakMap();\n    function genericListener(change) {\n        var entry = entrySet.get(change.object);\n        processChange(change, entry);\n        listener(change, buildPath(entry), target);\n    }\n    function processChange(change, parent) {\n        switch (change.type) {\n            // Object changes\n            case \"add\": // also for map\n                observeRecursively(change.newValue, parent, change.name);\n                break;\n            case \"update\": // also for array and map\n                unobserveRecursively(change.oldValue);\n                observeRecursively(change.newValue, parent, change.name || \"\" + change.index);\n                break;\n            case \"remove\": // object\n            case \"delete\": // map\n                unobserveRecursively(change.oldValue);\n                break;\n            // Array changes\n            case \"splice\":\n                change.removed.map(unobserveRecursively);\n                change.added.forEach(function (value, idx) {\n                    return observeRecursively(value, parent, \"\" + (change.index + idx));\n                });\n                // update paths\n                for (var i = change.index + change.addedCount; i < change.object.length; i++) {\n                    if (isRecursivelyObservable(change.object[i])) {\n                        var entry = entrySet.get(change.object[i]);\n                        if (entry)\n                            entry.path = \"\" + i;\n                    }\n                }\n                break;\n        }\n    }\n    function observeRecursively(thing, parent, path) {\n        if (isRecursivelyObservable(thing)) {\n            var entry = entrySet.get(thing);\n            if (entry) {\n                if (entry.parent !== parent || entry.path !== path)\n                    // MWE: this constraint is artificial, and this tool could be made to work with cycles,\n                    // but it increases administration complexity, has tricky edge cases and the meaning of 'path'\n                    // would become less clear. So doesn't seem to be needed for now\n                    throw new Error(\"The same observable object cannot appear twice in the same tree,\" +\n                        (\" trying to assign it to '\" + buildPath(parent) + \"/\" + path + \"',\") +\n                        (\" but it already exists at '\" + buildPath(entry.parent) + \"/\" + entry.path + \"'\"));\n            }\n            else {\n                var entry_1 = {\n                    parent: parent,\n                    path: path,\n                    dispose: observe(thing, genericListener),\n                };\n                entrySet.set(thing, entry_1);\n                entries(thing).forEach(function (_a) {\n                    var key = _a[0], value = _a[1];\n                    return observeRecursively(value, entry_1, key);\n                });\n            }\n        }\n    }\n    function unobserveRecursively(thing) {\n        if (isRecursivelyObservable(thing)) {\n            var entry = entrySet.get(thing);\n            if (!entry)\n                return;\n            entrySet.delete(thing);\n            entry.dispose();\n            values(thing).forEach(unobserveRecursively);\n        }\n    }\n    observeRecursively(target, undefined, \"\");\n    return function () {\n        unobserveRecursively(target);\n    };\n}\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * Reactively sorts a base observable array into multiple observable arrays based on the value of a\n * `groupBy: (item: T) => G` function.\n *\n * This observes the individual computed groupBy values and only updates the source and dest arrays\n * when there is an actual change, so this is far more efficient than, for example\n * `base.filter(i => groupBy(i) === 'we')`. Call #dispose() to stop tracking.\n *\n * No guarantees are made about the order of items in the grouped arrays.\n *\n * The resulting map of arrays is read-only. clear(), set(), delete() are not supported and\n * modifying the group arrays will lead to undefined behavior.\n *\n * NB: ObservableGroupMap relies on `Symbol`s. If you are targeting a platform which doesn't\n * support these natively, you will need to provide a polyfill.\n *\n * @param {array} base The array to sort into groups.\n * @param {function} groupBy The function used for grouping.\n * @param options Object with properties:\n *  `name`: Debug name of this ObservableGroupMap.\n *  `keyToName`: Function to create the debug names of the observable group arrays.\n *\n * @example\n * const slices = observable([\n *     { day: \"mo\", hours: 12 },\n *     { day: \"tu\", hours: 2 },\n * ])\n * const slicesByDay = new ObservableGroupMap(slices, (slice) => slice.day)\n * autorun(() => console.log(\n *     slicesByDay.get(\"mo\")?.length ?? 0,\n *     slicesByDay.get(\"we\"))) // outputs 1, undefined\n * slices[0].day = \"we\" // outputs 0, [{ day: \"we\", hours: 12 }]\n */\nvar ObservableGroupMap = /** @class */ (function (_super) {\n    __extends(ObservableGroupMap, _super);\n    function ObservableGroupMap(base, groupBy, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.name, name = _c === void 0 ? \"ogm\" + ((Math.random() * 1000) | 0) : _c, _d = _b.keyToName, keyToName = _d === void 0 ? function (x) { return \"\" + x; } : _d;\n        var _this = _super.call(this) || this;\n        /**\n         * Base observable array which is being sorted into groups.\n         */\n        Object.defineProperty(_this, \"_base\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The ObservableGroupMap needs to track some state per-item. This is the name/symbol of the\n         * property used to attach the state.\n         */\n        Object.defineProperty(_this, \"_ogmInfoKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The function used to group the items.\n         */\n        Object.defineProperty(_this, \"_groupBy\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * This function is used to generate the mobx debug names of the observable group arrays.\n         */\n        Object.defineProperty(_this, \"_keyToName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"_disposeBaseObserver\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        _this._keyToName = keyToName;\n        _this._groupBy = groupBy;\n        _this._ogmInfoKey = Symbol(\"ogmInfo\" + name);\n        _this._base = base;\n        for (var i = 0; i < base.length; i++) {\n            _this._addItem(base[i]);\n        }\n        _this._disposeBaseObserver = observe(_this._base, function (change) {\n            if (\"splice\" === change.type) {\n                transaction(function () {\n                    for (var _i = 0, _a = change.removed; _i < _a.length; _i++) {\n                        var removed = _a[_i];\n                        _this._removeItem(removed);\n                    }\n                    for (var _b = 0, _c = change.added; _b < _c.length; _b++) {\n                        var added = _c[_b];\n                        _this._addItem(added);\n                    }\n                });\n            }\n            else if (\"update\" === change.type) {\n                transaction(function () {\n                    _this._removeItem(change.oldValue);\n                    _this._addItem(change.newValue);\n                });\n            }\n            else {\n                throw new Error(\"illegal state\");\n            }\n        });\n        return _this;\n    }\n    Object.defineProperty(ObservableGroupMap.prototype, \"clear\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            throw new Error(\"not supported\");\n        }\n    });\n    Object.defineProperty(ObservableGroupMap.prototype, \"delete\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (_key) {\n            throw new Error(\"not supported\");\n        }\n    });\n    Object.defineProperty(ObservableGroupMap.prototype, \"set\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (_key, _value) {\n            throw new Error(\"not supported\");\n        }\n    });\n    /**\n     * Disposes all observers created during construction and removes state added to base array\n     * items.\n     */\n    Object.defineProperty(ObservableGroupMap.prototype, \"dispose\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this._disposeBaseObserver();\n            for (var i = 0; i < this._base.length; i++) {\n                var item = this._base[i];\n                var grouperItemInfo = item[this._ogmInfoKey];\n                grouperItemInfo.reaction();\n                delete item[this._ogmInfoKey];\n            }\n        }\n    });\n    Object.defineProperty(ObservableGroupMap.prototype, \"_getGroupArr\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (key) {\n            var result = _super.prototype.get.call(this, key);\n            if (undefined === result) {\n                result = observable([], { name: \"GroupArray[\" + this._keyToName(key) + \"]\", deep: false });\n                _super.prototype.set.call(this, key, result);\n            }\n            return result;\n        }\n    });\n    Object.defineProperty(ObservableGroupMap.prototype, \"_removeFromGroupArr\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (key, itemIndex) {\n            var arr = _super.prototype.get.call(this, key);\n            if (1 === arr.length) {\n                _super.prototype.delete.call(this, key);\n            }\n            else if (itemIndex === arr.length - 1) {\n                // last position in array\n                arr.length--;\n            }\n            else {\n                arr[itemIndex] = arr[arr.length - 1];\n                arr[itemIndex][this._ogmInfoKey].groupArrIndex = itemIndex;\n                arr.length--;\n            }\n        }\n    });\n    Object.defineProperty(ObservableGroupMap.prototype, \"_addItem\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (item) {\n            var _this = this;\n            var groupByValue = this._groupBy(item);\n            var groupArr = this._getGroupArr(groupByValue);\n            var value = {\n                groupByValue: groupByValue,\n                groupArrIndex: groupArr.length,\n                reaction: reaction(function () { return _this._groupBy(item); }, function (newGroupByValue, _r) {\n                    var grouperItemInfo = item[_this._ogmInfoKey];\n                    _this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);\n                    var newGroupArr = _this._getGroupArr(newGroupByValue);\n                    var newGroupArrIndex = newGroupArr.length;\n                    newGroupArr.push(item);\n                    grouperItemInfo.groupByValue = newGroupByValue;\n                    grouperItemInfo.groupArrIndex = newGroupArrIndex;\n                }),\n            };\n            Object.defineProperty(item, this._ogmInfoKey, {\n                configurable: true,\n                enumerable: false,\n                value: value,\n            });\n            groupArr.push(item);\n        }\n    });\n    Object.defineProperty(ObservableGroupMap.prototype, \"_removeItem\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (item) {\n            var grouperItemInfo = item[this._ogmInfoKey];\n            this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);\n            grouperItemInfo.reaction();\n            delete item[this._ogmInfoKey];\n        }\n    });\n    return ObservableGroupMap;\n}(ObservableMap));\n\n/**\n * @private\n */\nvar DeepMapEntry = /** @class */ (function () {\n    function DeepMapEntry(base, args) {\n        Object.defineProperty(this, \"base\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: base\n        });\n        Object.defineProperty(this, \"args\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: args\n        });\n        Object.defineProperty(this, \"root\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"closest\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"closestIdx\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"isDisposed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        var current = (this.closest = this.root = base);\n        var i = 0;\n        for (; i < this.args.length - 1; i++) {\n            current = current.get(args[i]);\n            if (current)\n                this.closest = current;\n            else\n                break;\n        }\n        this.closestIdx = i;\n    }\n    Object.defineProperty(DeepMapEntry.prototype, \"exists\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this.assertNotDisposed();\n            var l = this.args.length;\n            return this.closestIdx >= l - 1 && this.closest.has(this.args[l - 1]);\n        }\n    });\n    Object.defineProperty(DeepMapEntry.prototype, \"get\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this.assertNotDisposed();\n            if (!this.exists())\n                throw new Error(\"Entry doesn't exist\");\n            return this.closest.get(this.args[this.args.length - 1]);\n        }\n    });\n    Object.defineProperty(DeepMapEntry.prototype, \"set\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value) {\n            this.assertNotDisposed();\n            var l = this.args.length;\n            var current = this.closest;\n            // create remaining maps\n            for (var i = this.closestIdx; i < l - 1; i++) {\n                var m = new Map();\n                current.set(this.args[i], m);\n                current = m;\n            }\n            this.closestIdx = l - 1;\n            this.closest = current;\n            current.set(this.args[l - 1], value);\n        }\n    });\n    Object.defineProperty(DeepMapEntry.prototype, \"delete\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this.assertNotDisposed();\n            if (!this.exists())\n                throw new Error(\"Entry doesn't exist\");\n            var l = this.args.length;\n            this.closest.delete(this.args[l - 1]);\n            // clean up remaining maps if needed (reconstruct stack first)\n            var c = this.root;\n            var maps = [c];\n            for (var i = 0; i < l - 1; i++) {\n                c = c.get(this.args[i]);\n                maps.push(c);\n            }\n            for (var i = maps.length - 1; i > 0; i--) {\n                if (maps[i].size === 0)\n                    maps[i - 1].delete(this.args[i - 1]);\n            }\n            this.isDisposed = true;\n        }\n    });\n    Object.defineProperty(DeepMapEntry.prototype, \"assertNotDisposed\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            // TODO: once this becomes annoying, we should introduce a reset method to re-run the constructor logic\n            if (this.isDisposed)\n                throw new Error(\"Concurrent modification exception\");\n        }\n    });\n    return DeepMapEntry;\n}());\n/**\n * @private\n */\nvar DeepMap = /** @class */ (function () {\n    function DeepMap() {\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"argsLength\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: -1\n        });\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    Object.defineProperty(DeepMap.prototype, \"entry\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (args) {\n            if (this.argsLength === -1)\n                this.argsLength = args.length;\n            else if (this.argsLength !== args.length)\n                throw new Error(\"DeepMap should be used with functions with a consistent length, expected: \" + this.argsLength + \", got: \" + args.length);\n            if (this.last)\n                this.last.isDisposed = true;\n            return (this.last = new DeepMapEntry(this.store, args));\n        }\n    });\n    return DeepMap;\n}());\n\nvar __assign$2 = (undefined && undefined.__assign) || function () {\n    __assign$2 = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$2.apply(this, arguments);\n};\nvar __spreadArrays$1 = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n/**\n * computedFn takes a function with an arbitrary amount of arguments,\n * and memoizes the output of the function based on the arguments passed in.\n *\n * computedFn(fn) returns a function with the very same signature. There is no limit on the amount of arguments\n * that is accepted. However, the amount of arguments must be constant and default arguments are not supported.\n *\n * By default the output of a function call will only be memoized as long as the\n * output is being observed.\n *\n * The function passes into `computedFn` should be pure, not be an action and only be relying on\n * observables.\n *\n * Setting `keepAlive` to `true` will cause the output to be forcefully cached forever.\n * Note that this might introduce memory leaks!\n *\n * @example\n * const store = observable({\n    a: 1,\n    b: 2,\n    c: 3,\n    m: computedFn(function(x) {\n      return this.a * this.b * x\n    })\n  })\n\n  const d = autorun(() => {\n    // store.m(3) will be cached as long as this autorun is running\n    console.log(store.m(3) * store.c)\n  })\n *\n * @param fn\n * @param keepAliveOrOptions\n */\nfunction computedFn(fn, keepAliveOrOptions) {\n    if (keepAliveOrOptions === void 0) { keepAliveOrOptions = false; }\n    if (isAction(fn))\n        throw new Error(\"computedFn shouldn't be used on actions\");\n    var memoWarned = false;\n    var i = 0;\n    var opts = typeof keepAliveOrOptions === \"boolean\"\n        ? { keepAlive: keepAliveOrOptions }\n        : keepAliveOrOptions;\n    var d = new DeepMap();\n    return function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var entry = d.entry(args);\n        // cache hit, return\n        if (entry.exists())\n            return entry.get().get();\n        // if function is invoked, and its a cache miss without reactive, there is no point in caching...\n        if (!opts.keepAlive && !_isComputingDerivation()) {\n            if (!memoWarned) {\n                console.warn(\"invoking a computedFn from outside an reactive context won't be memoized, unless keepAlive is set\");\n                memoWarned = true;\n            }\n            return fn.apply(this, args);\n        }\n        // create new entry\n        var latestValue;\n        var c = computed(function () {\n            return (latestValue = fn.apply(_this, args));\n        }, __assign$2(__assign$2({}, opts), { name: \"computedFn(\" + (opts.name || fn.name) + \"#\" + ++i + \")\" }));\n        entry.set(c);\n        // clean up if no longer observed\n        if (!opts.keepAlive)\n            onBecomeUnobserved(c, function () {\n                d.entry(args).delete();\n                if (opts.onCleanup)\n                    opts.onCleanup.apply(opts, __spreadArrays$1([latestValue], args));\n                latestValue = undefined;\n            });\n        // return current val\n        return c.get();\n    };\n}\n\nexport { FULFILLED, IDENTITY, NOOP, ObservableGroupMap, PENDING, REJECTED, ViewModel, addHiddenProp, chunkProcessor, computedFn, createTransformer, createViewModel, deepObserve, expr, fail, fromPromise, fromResource, fromStream, getAllMethodsAndProperties, invariant, isPromiseBasedObservable, keepAlive, lazyObservable, moveItem, now, queueProcessor, toStream };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}