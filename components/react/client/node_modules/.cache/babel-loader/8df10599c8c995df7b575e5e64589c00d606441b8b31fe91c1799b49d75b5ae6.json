{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseAccount = void 0;\nconst unit_1 = require(\"@keplr-wallet/unit\");\nclass BaseAccount {\n  constructor(type, address, accountNumber, sequence) {\n    this.type = type;\n    this.address = address;\n    this.accountNumber = accountNumber;\n    this.sequence = sequence;\n  }\n  static fetchFromRest(instance, address) {\n    let defaultBech32Address = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = yield instance.get(`/cosmos/auth/v1beta1/accounts/${address}`, {\n        validateStatus: function (status) {\n          // Permit 404 not found to handle the case of account not exists\n          return status >= 200 && status < 300 || status === 404;\n        }\n      });\n      return BaseAccount.fromProtoJSON(result.data, defaultBech32Address ? address : \"\");\n    });\n  }\n  static fromProtoJSON(obj) {\n    let defaultBech32Address = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    if (!obj.account) {\n      // Case of not existing account.\n      // {\n      //   \"code\": 5,\n      //   \"message\": \"rpc error: code = NotFound desc = account {address} not found: key not found\",\n      //   \"details\": [\n      //   ]\n      // }\n      if (!defaultBech32Address) {\n        throw new Error(`Account's address is unknown: ${JSON.stringify(obj)}`);\n      }\n      return new BaseAccount(\"\", defaultBech32Address, new unit_1.Int(0), new unit_1.Int(0));\n    }\n    let value = obj.account;\n    const type = value[\"@type\"] || \"\";\n    // If the chain modifies the account type, handle the case where the account type embeds the base account.\n    // (Actually, the only existent case is ethermint, and this is the line for handling ethermint)\n    const baseAccount = value.BaseAccount || value.baseAccount || value.base_account;\n    if (baseAccount) {\n      value = baseAccount;\n    }\n    // If the chain modifies the account type, handle the case where the account type embeds the account.\n    // (Actually, the only existent case is desmos, and this is the line for handling desmos)\n    const embedAccount = value.account;\n    if (embedAccount) {\n      value = embedAccount;\n    }\n    // If the account is the vesting account that embeds the base vesting account,\n    // the actual base account exists under the base vesting account.\n    // But, this can be different according to the version of cosmos-sdk.\n    // So, anyway, try to parse it by some ways...\n    const baseVestingAccount = value.BaseVestingAccount || value.baseVestingAccount || value.base_vesting_account;\n    if (baseVestingAccount) {\n      value = baseVestingAccount;\n      const baseAccount = value.BaseAccount || value.baseAccount || value.base_account;\n      if (baseAccount) {\n        value = baseAccount;\n      }\n    }\n    let address = value.address;\n    if (!address) {\n      if (!defaultBech32Address) {\n        throw new Error(`Account's address is unknown: ${JSON.stringify(obj)}`);\n      }\n      address = defaultBech32Address;\n    }\n    const accountNumber = value.account_number;\n    const sequence = value.sequence;\n    return new BaseAccount(type, address, new unit_1.Int(accountNumber || \"0\"), new unit_1.Int(sequence || \"0\"));\n  }\n  getType() {\n    return this.type;\n  }\n  getAddress() {\n    return this.address;\n  }\n  getAccountNumber() {\n    return this.accountNumber;\n  }\n  getSequence() {\n    return this.sequence;\n  }\n}\nexports.BaseAccount = BaseAccount;","map":{"version":3,"mappings":"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","names":["BaseAccount","constructor","type","address","accountNumber","sequence","fetchFromRest","instance","defaultBech32Address","result","get","validateStatus","status","fromProtoJSON","data","obj","account","Error","JSON","stringify","unit_1","value","baseAccount","base_account","embedAccount","baseVestingAccount","BaseVestingAccount","base_vesting_account","account_number","getType","getAddress","getAccountNumber","getSequence","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/background/node_modules/@keplr-wallet/cosmos/src/account/index.ts"],"sourcesContent":["import { Int } from \"@keplr-wallet/unit\";\nimport { AxiosInstance } from \"axios\";\n\nexport interface Account {\n  getType(): string;\n  getAddress(): string;\n  getAccountNumber(): Int;\n  getSequence(): Int;\n}\n\nexport class BaseAccount implements Account {\n  public static async fetchFromRest(\n    instance: AxiosInstance,\n    address: string,\n    // If the account doesn't exist, the result from `auth/accounts` would not have the address.\n    // In this case, if `defaultBech32Address` param is provided, this will use it instead of the result from rest.\n    defaultBech32Address: boolean = false\n  ): Promise<BaseAccount> {\n    const result = await instance.get(\n      `/cosmos/auth/v1beta1/accounts/${address}`,\n      {\n        validateStatus: function (status) {\n          // Permit 404 not found to handle the case of account not exists\n          return (status >= 200 && status < 300) || status === 404;\n        },\n      }\n    );\n\n    return BaseAccount.fromProtoJSON(\n      result.data,\n      defaultBech32Address ? address : \"\"\n    );\n  }\n\n  public static fromProtoJSON(\n    obj: {\n      account?: any;\n      /*\n      Base account format.\n      {\n        \"@type\": string;\n        address: string;\n        pub_key: {\n          \"@type\": string;\n          key: string;\n        };\n        account_number: string;\n        sequence: string;\n      };\n     */\n    },\n    // If the account doesn't exist, the result from `auth/accounts` would not have the address.\n    // In this case, if `defaultBech32Address` param is provided, this will use it instead of the result from rest.\n    defaultBech32Address: string = \"\"\n  ): BaseAccount {\n    if (!obj.account) {\n      // Case of not existing account.\n      // {\n      //   \"code\": 5,\n      //   \"message\": \"rpc error: code = NotFound desc = account {address} not found: key not found\",\n      //   \"details\": [\n      //   ]\n      // }\n      if (!defaultBech32Address) {\n        throw new Error(`Account's address is unknown: ${JSON.stringify(obj)}`);\n      }\n\n      return new BaseAccount(\"\", defaultBech32Address, new Int(0), new Int(0));\n    }\n\n    let value = obj.account;\n    const type = value[\"@type\"] || \"\";\n\n    // If the chain modifies the account type, handle the case where the account type embeds the base account.\n    // (Actually, the only existent case is ethermint, and this is the line for handling ethermint)\n    const baseAccount =\n      value.BaseAccount || value.baseAccount || value.base_account;\n    if (baseAccount) {\n      value = baseAccount;\n    }\n\n    // If the chain modifies the account type, handle the case where the account type embeds the account.\n    // (Actually, the only existent case is desmos, and this is the line for handling desmos)\n    const embedAccount = value.account;\n    if (embedAccount) {\n      value = embedAccount;\n    }\n\n    // If the account is the vesting account that embeds the base vesting account,\n    // the actual base account exists under the base vesting account.\n    // But, this can be different according to the version of cosmos-sdk.\n    // So, anyway, try to parse it by some ways...\n    const baseVestingAccount =\n      value.BaseVestingAccount ||\n      value.baseVestingAccount ||\n      value.base_vesting_account;\n    if (baseVestingAccount) {\n      value = baseVestingAccount;\n\n      const baseAccount =\n        value.BaseAccount || value.baseAccount || value.base_account;\n      if (baseAccount) {\n        value = baseAccount;\n      }\n    }\n\n    let address = value.address;\n    if (!address) {\n      if (!defaultBech32Address) {\n        throw new Error(`Account's address is unknown: ${JSON.stringify(obj)}`);\n      }\n      address = defaultBech32Address;\n    }\n\n    const accountNumber = value.account_number;\n    const sequence = value.sequence;\n\n    return new BaseAccount(\n      type,\n      address,\n      new Int(accountNumber || \"0\"),\n      new Int(sequence || \"0\")\n    );\n  }\n\n  constructor(\n    protected readonly type: string,\n    protected readonly address: string,\n    protected readonly accountNumber: Int,\n    protected readonly sequence: Int\n  ) {}\n\n  getType(): string {\n    return this.type;\n  }\n\n  getAddress(): string {\n    return this.address;\n  }\n\n  getAccountNumber(): Int {\n    return this.accountNumber;\n  }\n\n  getSequence(): Int {\n    return this.sequence;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}