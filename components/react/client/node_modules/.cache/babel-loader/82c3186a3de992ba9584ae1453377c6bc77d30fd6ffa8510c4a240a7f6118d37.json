{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableQueryRewards = exports.ObservableQueryRewardsInner = void 0;\nconst chain_query_1 = require(\"../../chain-query\");\nconst mobx_1 = require(\"mobx\");\nconst unit_1 = require(\"@keplr-wallet/unit\");\nconst common_1 = require(\"../../../common\");\nconst mobx_utils_1 = require(\"mobx-utils\");\nclass ObservableQueryRewardsInner extends chain_query_1.ObservableChainQuery {\n  constructor(kvStore, chainId, chainGetter, bech32Address) {\n    super(kvStore, chainId, chainGetter, `/cosmos/distribution/v1beta1/delegators/${bech32Address}/rewards`);\n    this.getRewardsOf = mobx_utils_1.computedFn(validatorAddress => {\n      var _a, _b, _c;\n      const chainInfo = this.chainGetter.getChain(this.chainId);\n      const currenciesMap = chainInfo.currencies.reduce((obj, currency) => {\n        // TODO: Handle the contract tokens.\n        if (!(\"type\" in currency)) {\n          obj[currency.coinMinimalDenom] = currency;\n        }\n        return obj;\n      }, {});\n      const reward = (_b = (_a = this.response) === null || _a === void 0 ? void 0 : _a.data.rewards) === null || _b === void 0 ? void 0 : _b.find(r => {\n        return r.validator_address === validatorAddress;\n      });\n      return common_1.StoreUtils.getBalancesFromCurrencies(currenciesMap, (_c = reward === null || reward === void 0 ? void 0 : reward.reward) !== null && _c !== void 0 ? _c : []);\n    });\n    this.getStakableRewardOf = mobx_utils_1.computedFn(validatorAddress => {\n      var _a, _b, _c;\n      const chainInfo = this.chainGetter.getChain(this.chainId);\n      const reward = (_b = (_a = this.response) === null || _a === void 0 ? void 0 : _a.data.rewards) === null || _b === void 0 ? void 0 : _b.find(r => {\n        return r.validator_address === validatorAddress;\n      });\n      return common_1.StoreUtils.getBalanceFromCurrency(chainInfo.stakeCurrency, (_c = reward === null || reward === void 0 ? void 0 : reward.reward) !== null && _c !== void 0 ? _c : []);\n    });\n    this.getUnstakableRewardsOf = mobx_utils_1.computedFn(validatorAddress => {\n      var _a, _b, _c;\n      const chainInfo = this.chainGetter.getChain(this.chainId);\n      const currenciesMap = chainInfo.currencies.reduce((obj, currency) => {\n        // TODO: Handle the contract tokens.\n        if (!(\"type\" in currency) && currency.coinMinimalDenom !== chainInfo.stakeCurrency.coinMinimalDenom) {\n          obj[currency.coinMinimalDenom] = currency;\n        }\n        return obj;\n      }, {});\n      const reward = (_b = (_a = this.response) === null || _a === void 0 ? void 0 : _a.data.rewards) === null || _b === void 0 ? void 0 : _b.find(r => {\n        return r.validator_address === validatorAddress;\n      });\n      return common_1.StoreUtils.getBalancesFromCurrencies(currenciesMap, (_c = reward === null || reward === void 0 ? void 0 : reward.reward) !== null && _c !== void 0 ? _c : []);\n    });\n    /**\n     * getDescendingPendingRewardValidatorAddresses returns the validator addresses in descending order by stakable asset.\n     */\n    // ComputeFn doesn't support the default argument.\n    this.getDescendingPendingRewardValidatorAddresses = mobx_utils_1.computedFn(maxValiadtors => {\n      var _a, _b;\n      if (!this.response) {\n        return [];\n      }\n      const chainInfo = this.chainGetter.getChain(this.chainId);\n      const rewards = (_b = (_a = this.response.data.rewards) === null || _a === void 0 ? void 0 : _a.slice()) !== null && _b !== void 0 ? _b : [];\n      rewards.sort((reward1, reward2) => {\n        var _a, _b;\n        const amount1 = common_1.StoreUtils.getBalanceFromCurrency(chainInfo.stakeCurrency, (_a = reward1.reward) !== null && _a !== void 0 ? _a : []);\n        const amount2 = common_1.StoreUtils.getBalanceFromCurrency(chainInfo.stakeCurrency, (_b = reward2.reward) !== null && _b !== void 0 ? _b : []);\n        if (amount1.toDec().gt(amount2.toDec())) {\n          return -1;\n        } else {\n          return 1;\n        }\n      });\n      return rewards.filter(reward => {\n        if (reward.reward) {\n          for (const r of reward.reward) {\n            const dec = new unit_1.Dec(r.amount);\n            if (dec.truncate().gt(new unit_1.Int(0))) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }).slice(0, maxValiadtors).map(r => r.validator_address);\n    });\n    mobx_1.makeObservable(this);\n    this.bech32Address = bech32Address;\n  }\n  canFetch() {\n    // If bech32 address is empty, it will always fail, so don't need to fetch it.\n    return this.bech32Address.length > 0;\n  }\n  get rewards() {\n    var _a, _b;\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    const currenciesMap = chainInfo.currencies.reduce((obj, currency) => {\n      // TODO: Handle the contract tokens.\n      if (!(\"type\" in currency)) {\n        obj[currency.coinMinimalDenom] = currency;\n      }\n      return obj;\n    }, {});\n    return common_1.StoreUtils.getBalancesFromCurrencies(currenciesMap, (_b = (_a = this.response) === null || _a === void 0 ? void 0 : _a.data.total) !== null && _b !== void 0 ? _b : []);\n  }\n  get stakableReward() {\n    var _a, _b;\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    return common_1.StoreUtils.getBalanceFromCurrency(chainInfo.stakeCurrency, (_b = (_a = this.response) === null || _a === void 0 ? void 0 : _a.data.total) !== null && _b !== void 0 ? _b : []);\n  }\n  get unstakableRewards() {\n    var _a, _b;\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    const currenciesMap = chainInfo.currencies.reduce((obj, currency) => {\n      // TODO: Handle the contract tokens.\n      if (!(\"type\" in currency) && currency.coinMinimalDenom !== chainInfo.stakeCurrency.coinMinimalDenom) {\n        obj[currency.coinMinimalDenom] = currency;\n      }\n      return obj;\n    }, {});\n    return common_1.StoreUtils.getBalancesFromCurrencies(currenciesMap, (_b = (_a = this.response) === null || _a === void 0 ? void 0 : _a.data.total) !== null && _b !== void 0 ? _b : []);\n  }\n  get pendingRewardValidatorAddresses() {\n    var _a;\n    if (!this.response) {\n      return [];\n    }\n    const result = [];\n    for (const reward of (_a = this.response.data.rewards) !== null && _a !== void 0 ? _a : []) {\n      if (reward.reward) {\n        for (const r of reward.reward) {\n          const dec = new unit_1.Dec(r.amount);\n          if (dec.truncate().gt(new unit_1.Int(0))) {\n            result.push(reward.validator_address);\n            break;\n          }\n        }\n      }\n    }\n    return result;\n  }\n}\n__decorate([mobx_1.computed], ObservableQueryRewardsInner.prototype, \"rewards\", null);\n__decorate([mobx_1.computed], ObservableQueryRewardsInner.prototype, \"stakableReward\", null);\n__decorate([mobx_1.computed], ObservableQueryRewardsInner.prototype, \"unstakableRewards\", null);\n__decorate([mobx_1.computed], ObservableQueryRewardsInner.prototype, \"pendingRewardValidatorAddresses\", null);\nexports.ObservableQueryRewardsInner = ObservableQueryRewardsInner;\nclass ObservableQueryRewards extends chain_query_1.ObservableChainQueryMap {\n  constructor(kvStore, chainId, chainGetter) {\n    super(kvStore, chainId, chainGetter, bech32Address => {\n      return new ObservableQueryRewardsInner(this.kvStore, this.chainId, this.chainGetter, bech32Address);\n    });\n    this.kvStore = kvStore;\n    this.chainId = chainId;\n    this.chainGetter = chainGetter;\n  }\n  getQueryBech32Address(bech32Address) {\n    return this.get(bech32Address);\n  }\n}\nexports.ObservableQueryRewards = ObservableQueryRewards;","map":{"version":3,"mappings":"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","names":["ObservableQueryRewardsInner","chain_query_1","constructor","kvStore","chainId","chainGetter","bech32Address","mobx_utils_1","validatorAddress","chainInfo","getChain","currenciesMap","currencies","reduce","obj","currency","coinMinimalDenom","reward","response","data","rewards","find","r","validator_address","common_1","getBalancesFromCurrencies","getBalanceFromCurrency","stakeCurrency","maxValiadtors","slice","sort","reward1","reward2","amount1","amount2","toDec","gt","filter","dec","unit_1","amount","truncate","map","mobx_1","canFetch","length","total","stakableReward","unstakableRewards","pendingRewardValidatorAddresses","result","push","__decorate","exports","ObservableQueryRewards","getQueryBech32Address","get"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/query/cosmos/staking/rewards.ts"],"sourcesContent":["import { Rewards } from \"./types\";\nimport { KVStore } from \"@keplr-wallet/common\";\nimport {\n  ObservableChainQuery,\n  ObservableChainQueryMap,\n} from \"../../chain-query\";\nimport { ChainGetter } from \"../../../common\";\nimport { computed, makeObservable } from \"mobx\";\nimport { CoinPretty, Dec, Int } from \"@keplr-wallet/unit\";\nimport { Currency } from \"@keplr-wallet/types\";\nimport { StoreUtils } from \"../../../common\";\nimport { computedFn } from \"mobx-utils\";\n\nexport class ObservableQueryRewardsInner extends ObservableChainQuery<Rewards> {\n  protected bech32Address: string;\n\n  constructor(\n    kvStore: KVStore,\n    chainId: string,\n    chainGetter: ChainGetter,\n    bech32Address: string\n  ) {\n    super(\n      kvStore,\n      chainId,\n      chainGetter,\n      `/cosmos/distribution/v1beta1/delegators/${bech32Address}/rewards`\n    );\n    makeObservable(this);\n\n    this.bech32Address = bech32Address;\n  }\n\n  protected canFetch(): boolean {\n    // If bech32 address is empty, it will always fail, so don't need to fetch it.\n    return this.bech32Address.length > 0;\n  }\n\n  @computed\n  get rewards(): CoinPretty[] {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n\n    const currenciesMap = chainInfo.currencies.reduce<{\n      [denom: string]: Currency;\n    }>((obj, currency) => {\n      // TODO: Handle the contract tokens.\n      if (!(\"type\" in currency)) {\n        obj[currency.coinMinimalDenom] = currency;\n      }\n      return obj;\n    }, {});\n\n    return StoreUtils.getBalancesFromCurrencies(\n      currenciesMap,\n      this.response?.data.total ?? []\n    );\n  }\n\n  readonly getRewardsOf = computedFn(\n    (validatorAddress: string): CoinPretty[] => {\n      const chainInfo = this.chainGetter.getChain(this.chainId);\n\n      const currenciesMap = chainInfo.currencies.reduce<{\n        [denom: string]: Currency;\n      }>((obj, currency) => {\n        // TODO: Handle the contract tokens.\n        if (!(\"type\" in currency)) {\n          obj[currency.coinMinimalDenom] = currency;\n        }\n        return obj;\n      }, {});\n\n      const reward = this.response?.data.rewards?.find((r) => {\n        return r.validator_address === validatorAddress;\n      });\n\n      return StoreUtils.getBalancesFromCurrencies(\n        currenciesMap,\n        reward?.reward ?? []\n      );\n    }\n  );\n\n  @computed\n  get stakableReward(): CoinPretty {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n\n    return StoreUtils.getBalanceFromCurrency(\n      chainInfo.stakeCurrency,\n      this.response?.data.total ?? []\n    );\n  }\n\n  readonly getStakableRewardOf = computedFn(\n    (validatorAddress: string): CoinPretty => {\n      const chainInfo = this.chainGetter.getChain(this.chainId);\n\n      const reward = this.response?.data.rewards?.find((r) => {\n        return r.validator_address === validatorAddress;\n      });\n\n      return StoreUtils.getBalanceFromCurrency(\n        chainInfo.stakeCurrency,\n        reward?.reward ?? []\n      );\n    }\n  );\n\n  @computed\n  get unstakableRewards(): CoinPretty[] {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n\n    const currenciesMap = chainInfo.currencies.reduce<{\n      [denom: string]: Currency;\n    }>((obj, currency) => {\n      // TODO: Handle the contract tokens.\n      if (\n        !(\"type\" in currency) &&\n        currency.coinMinimalDenom !== chainInfo.stakeCurrency.coinMinimalDenom\n      ) {\n        obj[currency.coinMinimalDenom] = currency;\n      }\n      return obj;\n    }, {});\n\n    return StoreUtils.getBalancesFromCurrencies(\n      currenciesMap,\n      this.response?.data.total ?? []\n    );\n  }\n\n  readonly getUnstakableRewardsOf = computedFn(\n    (validatorAddress: string): CoinPretty[] => {\n      const chainInfo = this.chainGetter.getChain(this.chainId);\n\n      const currenciesMap = chainInfo.currencies.reduce<{\n        [denom: string]: Currency;\n      }>((obj, currency) => {\n        // TODO: Handle the contract tokens.\n        if (\n          !(\"type\" in currency) &&\n          currency.coinMinimalDenom !== chainInfo.stakeCurrency.coinMinimalDenom\n        ) {\n          obj[currency.coinMinimalDenom] = currency;\n        }\n        return obj;\n      }, {});\n\n      const reward = this.response?.data.rewards?.find((r) => {\n        return r.validator_address === validatorAddress;\n      });\n\n      return StoreUtils.getBalancesFromCurrencies(\n        currenciesMap,\n        reward?.reward ?? []\n      );\n    }\n  );\n\n  @computed\n  get pendingRewardValidatorAddresses(): string[] {\n    if (!this.response) {\n      return [];\n    }\n\n    const result: string[] = [];\n\n    for (const reward of this.response.data.rewards ?? []) {\n      if (reward.reward) {\n        for (const r of reward.reward) {\n          const dec = new Dec(r.amount);\n          if (dec.truncate().gt(new Int(0))) {\n            result.push(reward.validator_address);\n            break;\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * getDescendingPendingRewardValidatorAddresses returns the validator addresses in descending order by stakable asset.\n   */\n  // ComputeFn doesn't support the default argument.\n  readonly getDescendingPendingRewardValidatorAddresses = computedFn(\n    (maxValiadtors: number): string[] => {\n      if (!this.response) {\n        return [];\n      }\n\n      const chainInfo = this.chainGetter.getChain(this.chainId);\n\n      const rewards = this.response.data.rewards?.slice() ?? [];\n      rewards.sort((reward1, reward2) => {\n        const amount1 = StoreUtils.getBalanceFromCurrency(\n          chainInfo.stakeCurrency,\n          reward1.reward ?? []\n        );\n\n        const amount2 = StoreUtils.getBalanceFromCurrency(\n          chainInfo.stakeCurrency,\n          reward2.reward ?? []\n        );\n\n        if (amount1.toDec().gt(amount2.toDec())) {\n          return -1;\n        } else {\n          return 1;\n        }\n      });\n\n      return rewards\n        .filter((reward) => {\n          if (reward.reward) {\n            for (const r of reward.reward) {\n              const dec = new Dec(r.amount);\n              if (dec.truncate().gt(new Int(0))) {\n                return true;\n              }\n            }\n          }\n\n          return false;\n        })\n        .slice(0, maxValiadtors)\n        .map((r) => r.validator_address);\n    }\n  );\n}\n\nexport class ObservableQueryRewards extends ObservableChainQueryMap<Rewards> {\n  constructor(\n    protected readonly kvStore: KVStore,\n    protected readonly chainId: string,\n    protected readonly chainGetter: ChainGetter\n  ) {\n    super(kvStore, chainId, chainGetter, (bech32Address: string) => {\n      return new ObservableQueryRewardsInner(\n        this.kvStore,\n        this.chainId,\n        this.chainGetter,\n        bech32Address\n      );\n    });\n  }\n\n  getQueryBech32Address(bech32Address: string): ObservableQueryRewardsInner {\n    return this.get(bech32Address) as ObservableQueryRewardsInner;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}