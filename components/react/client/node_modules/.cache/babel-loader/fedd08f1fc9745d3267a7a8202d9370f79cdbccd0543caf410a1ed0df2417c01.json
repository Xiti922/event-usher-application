{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SecretAccountImpl = exports.defaultSecretMsgOpts = exports.SecretAccount = void 0;\nconst buffer_1 = require(\"buffer/\");\nconst common_1 = require(\"@keplr-wallet/common\");\nconst msg_1 = require(\"@keplr-wallet/proto-types/secret/compute/v1beta1/msg\");\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nconst unit_1 = require(\"@keplr-wallet/unit\");\nconst deepmerge_1 = __importDefault(require(\"deepmerge\"));\nconst utils_1 = require(\"./utils\");\nexports.SecretAccount = {\n  use(options) {\n    return (base, chainGetter, chainId) => {\n      const msgOptsFromCreator = options.msgOptsCreator ? options.msgOptsCreator(chainId) : undefined;\n      return {\n        secret: new SecretAccountImpl(base, chainGetter, chainId, options.queriesStore, deepmerge_1.default(exports.defaultSecretMsgOpts, msgOptsFromCreator ? msgOptsFromCreator : {}))\n      };\n    };\n  }\n};\n/**\n * @deprecated Predict gas through simulation rather than using a fixed gas.\n */\nexports.defaultSecretMsgOpts = {\n  send: {\n    secret20: {\n      gas: 250000\n    }\n  },\n  createSecret20ViewingKey: {\n    gas: 150000\n  },\n  executeSecretWasm: {\n    type: \"wasm/MsgExecuteContract\"\n  }\n};\nclass SecretAccountImpl {\n  constructor(base, chainGetter, chainId, queriesStore, _msgOpts) {\n    this.base = base;\n    this.chainGetter = chainGetter;\n    this.chainId = chainId;\n    this.queriesStore = queriesStore;\n    this._msgOpts = _msgOpts;\n    this.base.registerMakeSendTokenFn(this.processMakeSendTokenTx.bind(this));\n    this.base.registerSendTokenFn(this.processSendToken.bind(this));\n  }\n  /**\n   * @deprecated Predict gas through simulation rather than using a fixed gas.\n   */\n  get msgOpts() {\n    return this._msgOpts;\n  }\n  processMakeSendTokenTx(amount, currency, recipient) {\n    const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);\n    if (denomHelper.type === \"secret20\") {\n      const actualAmount = (() => {\n        let dec = new unit_1.Dec(amount);\n        dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n        return dec.truncate().toString();\n      })();\n      if (!(\"type\" in currency) || currency.type !== \"secret20\") {\n        throw new Error(\"Currency is not secret20\");\n      }\n      cosmos_1.Bech32Address.validate(recipient, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr);\n      return this.makeExecuteSecretContractTx(\"send\", currency.contractAddress, {\n        transfer: {\n          recipient: recipient,\n          amount: actualAmount\n        }\n      }, [], tx => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to send token, refresh the balance.\n          const queryBalance = this.queries.queryBalances.getQueryBech32Address(this.base.bech32Address).balances.find(bal => {\n            return bal.currency.coinMinimalDenom === currency.coinMinimalDenom;\n          });\n          if (queryBalance) {\n            queryBalance.fetch();\n          }\n        }\n      });\n    }\n  }\n  /**\n   * @deprecated\n   */\n  processSendToken(amount, currency, recipient, memo, stdFee, signOptions, onTxEvents) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);\n      switch (denomHelper.type) {\n        case \"secret20\":\n          const actualAmount = (() => {\n            let dec = new unit_1.Dec(amount);\n            dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n            return dec.truncate().toString();\n          })();\n          if (!(\"type\" in currency) || currency.type !== \"secret20\") {\n            throw new Error(\"Currency is not secret20\");\n          }\n          yield this.sendExecuteSecretContractMsg(\"send\", currency.contractAddress, {\n            transfer: {\n              recipient: recipient,\n              amount: actualAmount\n            }\n          }, [], memo, {\n            amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],\n            gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.send.secret20.gas.toString()\n          }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, tx => {\n            if (tx.code == null || tx.code === 0) {\n              // After succeeding to send token, refresh the balance.\n              const queryBalance = this.queries.queryBalances.getQueryBech32Address(this.base.bech32Address).balances.find(bal => {\n                return bal.currency.coinMinimalDenom === currency.coinMinimalDenom;\n              });\n              if (queryBalance) {\n                queryBalance.fetch();\n              }\n            }\n          }));\n          return true;\n      }\n      return false;\n    });\n  }\n  createSecret20ViewingKey(contractAddress) {\n    let memo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let stdFee = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let signOptions = arguments.length > 3 ? arguments[3] : undefined;\n    let onFulfill = arguments.length > 4 ? arguments[4] : undefined;\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const random = new Uint8Array(32);\n      crypto.getRandomValues(random);\n      const key = buffer_1.Buffer.from(random).toString(\"hex\");\n      yield this.makeExecuteSecretContractTx(\"createSecret20ViewingKey\", contractAddress, {\n        set_viewing_key: {\n          key\n        }\n      }, []).send({\n        amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],\n        gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.createSecret20ViewingKey.gas.toString()\n      }, memo, signOptions, tx => {\n        let viewingKey = \"\";\n        if (tx.code == null || tx.code === 0) {\n          viewingKey = key;\n        }\n        if (onFulfill) {\n          onFulfill(tx, viewingKey);\n        }\n      });\n      return;\n    });\n  }\n  makeExecuteSecretContractTx() {\n    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"executeSecretWasm\";\n    let contractAddress = arguments.length > 1 ? arguments[1] : undefined;\n    let\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    obj = arguments.length > 2 ? arguments[2] : undefined;\n    let sentFunds = arguments.length > 3 ? arguments[3] : undefined;\n    let preOnTxEvents = arguments.length > 4 ? arguments[4] : undefined;\n    cosmos_1.Bech32Address.validate(contractAddress, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr);\n    let encryptedMsg;\n    return this.base.cosmos.makeTx(type, () => __awaiter(this, void 0, void 0, function* () {\n      encryptedMsg = yield this.encryptSecretContractMsg(contractAddress, obj);\n      const msg = {\n        type: this.msgOpts.executeSecretWasm.type,\n        value: {\n          sender: this.base.bech32Address,\n          contract: contractAddress,\n          // callback_code_hash: \"\",\n          msg: buffer_1.Buffer.from(encryptedMsg).toString(\"base64\"),\n          sent_funds: sentFunds\n        }\n      };\n      return {\n        aminoMsgs: [msg],\n        protoMsgs: [{\n          typeUrl: \"/secret.compute.v1beta1.MsgExecuteContract\",\n          value: msg_1.MsgExecuteContract.encode(msg_1.MsgExecuteContract.fromPartial({\n            sender: cosmos_1.Bech32Address.fromBech32(msg.value.sender).address,\n            contract: cosmos_1.Bech32Address.fromBech32(msg.value.contract).address,\n            msg: buffer_1.Buffer.from(msg.value.msg, \"base64\"),\n            sentFunds: msg.value.sent_funds\n          })).finish()\n        }]\n      };\n    }), preOnTxEvents);\n  }\n  /**\n   * @deprecated\n   */\n  sendExecuteSecretContractMsg() {\n    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"executeSecretWasm\";\n    let contractAddress = arguments.length > 1 ? arguments[1] : undefined;\n    let\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    obj = arguments.length > 2 ? arguments[2] : undefined;\n    let sentFunds = arguments.length > 3 ? arguments[3] : undefined;\n    let memo = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    let stdFee = arguments.length > 5 ? arguments[5] : undefined;\n    let signOptions = arguments.length > 6 ? arguments[6] : undefined;\n    let onTxEvents = arguments.length > 7 ? arguments[7] : undefined;\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      let encryptedMsg;\n      yield this.base.cosmos.sendMsgs(type, () => __awaiter(this, void 0, void 0, function* () {\n        encryptedMsg = yield this.encryptSecretContractMsg(contractAddress, obj);\n        const msg = {\n          type: this.msgOpts.executeSecretWasm.type,\n          value: {\n            sender: this.base.bech32Address,\n            contract: contractAddress,\n            // callback_code_hash: \"\",\n            msg: buffer_1.Buffer.from(encryptedMsg).toString(\"base64\"),\n            sent_funds: sentFunds\n          }\n        };\n        return {\n          aminoMsgs: [msg],\n          protoMsgs: [{\n            typeUrl: \"/secret.compute.v1beta1.MsgExecuteContract\",\n            value: msg_1.MsgExecuteContract.encode(msg_1.MsgExecuteContract.fromPartial({\n              sender: cosmos_1.Bech32Address.fromBech32(msg.value.sender).address,\n              contract: cosmos_1.Bech32Address.fromBech32(msg.value.contract).address,\n              msg: buffer_1.Buffer.from(msg.value.msg, \"base64\"),\n              sentFunds: msg.value.sent_funds\n            })).finish()\n          }]\n        };\n      }), memo, {\n        amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],\n        gas: stdFee.gas\n      }, signOptions, onTxEvents);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return encryptedMsg;\n    });\n  }\n  encryptSecretContractMsg(contractAddress,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  obj) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const queryContractCodeHashResponse = yield this.queries.secret.querySecretContractCodeHash.getQueryContract(contractAddress).waitResponse();\n      if (!queryContractCodeHashResponse) {\n        throw new Error(`Can't get the code hash of the contract (${contractAddress})`);\n      }\n      const contractCodeHash = queryContractCodeHashResponse.data.result;\n      const keplr = yield this.base.getKeplr();\n      if (!keplr) {\n        throw new Error(\"Can't get the Keplr API\");\n      }\n      const enigmaUtils = keplr.getEnigmaUtils(this.chainId);\n      return yield enigmaUtils.encrypt(contractCodeHash, obj);\n    });\n  }\n  get queries() {\n    return this.queriesStore.get(this.chainId);\n  }\n}\nexports.SecretAccountImpl = SecretAccountImpl;","map":{"version":3,"mappings":"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","names":["exports","use","options","base","chainGetter","chainId","msgOptsFromCreator","msgOptsCreator","undefined","secret","SecretAccountImpl","queriesStore","deepmerge_1","send","secret20","gas","createSecret20ViewingKey","executeSecretWasm","type","constructor","_msgOpts","registerMakeSendTokenFn","processMakeSendTokenTx","bind","registerSendTokenFn","processSendToken","msgOpts","amount","currency","recipient","denomHelper","common_1","coinMinimalDenom","actualAmount","dec","unit_1","mul","getPrecisionDec","coinDecimals","truncate","toString","Error","cosmos_1","validate","getChain","bech32Config","bech32PrefixAccAddr","makeExecuteSecretContractTx","contractAddress","transfer","tx","code","queryBalance","queries","queryBalances","getQueryBech32Address","bech32Address","balances","find","bal","fetch","memo","stdFee","signOptions","onTxEvents","sendExecuteSecretContractMsg","utils_1","onFulfill","random","Uint8Array","crypto","getRandomValues","key","buffer_1","from","set_viewing_key","viewingKey","obj","sentFunds","preOnTxEvents","encryptedMsg","cosmos","makeTx","__awaiter","encryptSecretContractMsg","msg","value","sender","contract","sent_funds","aminoMsgs","protoMsgs","typeUrl","msg_1","encode","fromPartial","fromBech32","address","finish","sendMsgs","queryContractCodeHashResponse","querySecretContractCodeHash","getQueryContract","waitResponse","contractCodeHash","data","result","keplr","getKeplr","enigmaUtils","getEnigmaUtils","encrypt","get"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/account/secret.ts"],"sourcesContent":["import { AccountSetBase, AccountSetBaseSuper, MsgOpt } from \"./base\";\nimport { SecretQueries, QueriesSetBase, IQueriesStore } from \"../query\";\nimport { Buffer } from \"buffer/\";\nimport { ChainGetter, CoinPrimitive } from \"../common\";\nimport { StdFee } from \"@cosmjs/launchpad\";\nimport { DenomHelper } from \"@keplr-wallet/common\";\nimport { MsgExecuteContract } from \"@keplr-wallet/proto-types/secret/compute/v1beta1/msg\";\nimport { Bech32Address } from \"@keplr-wallet/cosmos\";\nimport { Dec, DecUtils } from \"@keplr-wallet/unit\";\nimport { AppCurrency, KeplrSignOptions } from \"@keplr-wallet/types\";\nimport { DeepPartial, DeepReadonly, Optional } from \"utility-types\";\nimport { CosmosAccount } from \"./cosmos\";\nimport deepmerge from \"deepmerge\";\nimport { txEventsWithPreOnFulfill } from \"./utils\";\n\nexport interface SecretAccount {\n  secret: SecretAccountImpl;\n}\n\nexport const SecretAccount = {\n  use(options: {\n    msgOptsCreator?: (\n      chainId: string\n    ) => DeepPartial<SecretMsgOpts> | undefined;\n    queriesStore: IQueriesStore<SecretQueries>;\n  }): (\n    base: AccountSetBaseSuper & CosmosAccount,\n    chainGetter: ChainGetter,\n    chainId: string\n  ) => SecretAccount {\n    return (base, chainGetter, chainId) => {\n      const msgOptsFromCreator = options.msgOptsCreator\n        ? options.msgOptsCreator(chainId)\n        : undefined;\n\n      return {\n        secret: new SecretAccountImpl(\n          base,\n          chainGetter,\n          chainId,\n          options.queriesStore,\n          deepmerge<SecretMsgOpts, DeepPartial<SecretMsgOpts>>(\n            defaultSecretMsgOpts,\n            msgOptsFromCreator ? msgOptsFromCreator : {}\n          )\n        ),\n      };\n    };\n  },\n};\n\n/**\n * @deprecated Predict gas through simulation rather than using a fixed gas.\n */\nexport interface SecretMsgOpts {\n  readonly send: {\n    readonly secret20: Pick<MsgOpt, \"gas\">;\n  };\n\n  readonly createSecret20ViewingKey: Pick<MsgOpt, \"gas\">;\n  readonly executeSecretWasm: Pick<MsgOpt, \"type\">;\n}\n\n/**\n * @deprecated Predict gas through simulation rather than using a fixed gas.\n */\nexport const defaultSecretMsgOpts: SecretMsgOpts = {\n  send: {\n    secret20: {\n      gas: 250000,\n    },\n  },\n\n  createSecret20ViewingKey: {\n    gas: 150000,\n  },\n\n  executeSecretWasm: {\n    type: \"wasm/MsgExecuteContract\",\n  },\n};\n\nexport class SecretAccountImpl {\n  constructor(\n    protected readonly base: AccountSetBase & CosmosAccount,\n    protected readonly chainGetter: ChainGetter,\n    protected readonly chainId: string,\n    protected readonly queriesStore: IQueriesStore<SecretQueries>,\n    protected readonly _msgOpts: SecretMsgOpts\n  ) {\n    this.base.registerMakeSendTokenFn(this.processMakeSendTokenTx.bind(this));\n    this.base.registerSendTokenFn(this.processSendToken.bind(this));\n  }\n\n  /**\n   * @deprecated Predict gas through simulation rather than using a fixed gas.\n   */\n  get msgOpts(): SecretMsgOpts {\n    return this._msgOpts;\n  }\n\n  protected processMakeSendTokenTx(\n    amount: string,\n    currency: AppCurrency,\n    recipient: string\n  ) {\n    const denomHelper = new DenomHelper(currency.coinMinimalDenom);\n\n    if (denomHelper.type === \"secret20\") {\n      const actualAmount = (() => {\n        let dec = new Dec(amount);\n        dec = dec.mul(DecUtils.getPrecisionDec(currency.coinDecimals));\n        return dec.truncate().toString();\n      })();\n\n      if (!(\"type\" in currency) || currency.type !== \"secret20\") {\n        throw new Error(\"Currency is not secret20\");\n      }\n\n      Bech32Address.validate(\n        recipient,\n        this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr\n      );\n\n      return this.makeExecuteSecretContractTx(\n        \"send\",\n        currency.contractAddress,\n        {\n          transfer: {\n            recipient: recipient,\n            amount: actualAmount,\n          },\n        },\n        [],\n        (tx) => {\n          if (tx.code == null || tx.code === 0) {\n            // After succeeding to send token, refresh the balance.\n            const queryBalance = this.queries.queryBalances\n              .getQueryBech32Address(this.base.bech32Address)\n              .balances.find((bal) => {\n                return (\n                  bal.currency.coinMinimalDenom === currency.coinMinimalDenom\n                );\n              });\n\n            if (queryBalance) {\n              queryBalance.fetch();\n            }\n          }\n        }\n      );\n    }\n  }\n\n  /**\n   * @deprecated\n   */\n  protected async processSendToken(\n    amount: string,\n    currency: AppCurrency,\n    recipient: string,\n    memo: string,\n    stdFee: Partial<StdFee>,\n    signOptions?: KeplrSignOptions,\n    onTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ): Promise<boolean> {\n    const denomHelper = new DenomHelper(currency.coinMinimalDenom);\n\n    switch (denomHelper.type) {\n      case \"secret20\":\n        const actualAmount = (() => {\n          let dec = new Dec(amount);\n          dec = dec.mul(DecUtils.getPrecisionDec(currency.coinDecimals));\n          return dec.truncate().toString();\n        })();\n\n        if (!(\"type\" in currency) || currency.type !== \"secret20\") {\n          throw new Error(\"Currency is not secret20\");\n        }\n        await this.sendExecuteSecretContractMsg(\n          \"send\",\n          currency.contractAddress,\n          {\n            transfer: {\n              recipient: recipient,\n              amount: actualAmount,\n            },\n          },\n          [],\n          memo,\n          {\n            amount: stdFee.amount ?? [],\n            gas: stdFee.gas ?? this.msgOpts.send.secret20.gas.toString(),\n          },\n          signOptions,\n          txEventsWithPreOnFulfill(onTxEvents, (tx) => {\n            if (tx.code == null || tx.code === 0) {\n              // After succeeding to send token, refresh the balance.\n              const queryBalance = this.queries.queryBalances\n                .getQueryBech32Address(this.base.bech32Address)\n                .balances.find((bal) => {\n                  return (\n                    bal.currency.coinMinimalDenom === currency.coinMinimalDenom\n                  );\n                });\n\n              if (queryBalance) {\n                queryBalance.fetch();\n              }\n            }\n          })\n        );\n        return true;\n    }\n\n    return false;\n  }\n\n  async createSecret20ViewingKey(\n    contractAddress: string,\n    memo: string = \"\",\n    stdFee: Partial<StdFee> = {},\n    signOptions?: KeplrSignOptions,\n    onFulfill?: (tx: any, viewingKey: string) => void\n  ) {\n    const random = new Uint8Array(32);\n    crypto.getRandomValues(random);\n    const key = Buffer.from(random).toString(\"hex\");\n\n    await this.makeExecuteSecretContractTx(\n      \"createSecret20ViewingKey\",\n      contractAddress,\n      {\n        set_viewing_key: { key },\n      },\n      []\n    ).send(\n      {\n        amount: stdFee.amount ?? [],\n        gas: stdFee.gas ?? this.msgOpts.createSecret20ViewingKey.gas.toString(),\n      },\n      memo,\n      signOptions,\n      (tx) => {\n        let viewingKey = \"\";\n        if (tx.code == null || tx.code === 0) {\n          viewingKey = key;\n        }\n\n        if (onFulfill) {\n          onFulfill(tx, viewingKey);\n        }\n      }\n    );\n    return;\n  }\n\n  makeExecuteSecretContractTx(\n    // This arg can be used to override the type of sending tx if needed.\n    type: keyof SecretMsgOpts | \"unknown\" = \"executeSecretWasm\",\n    contractAddress: string,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    obj: object,\n    sentFunds: CoinPrimitive[],\n    preOnTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ) {\n    Bech32Address.validate(\n      contractAddress,\n      this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr\n    );\n\n    let encryptedMsg: Uint8Array;\n\n    return this.base.cosmos.makeTx(\n      type,\n      async () => {\n        encryptedMsg = await this.encryptSecretContractMsg(\n          contractAddress,\n          obj\n        );\n\n        const msg = {\n          type: this.msgOpts.executeSecretWasm.type,\n          value: {\n            sender: this.base.bech32Address,\n            contract: contractAddress,\n            // callback_code_hash: \"\",\n            msg: Buffer.from(encryptedMsg).toString(\"base64\"),\n            sent_funds: sentFunds,\n            // callback_sig: null,\n          },\n        };\n\n        return {\n          aminoMsgs: [msg],\n          protoMsgs: [\n            {\n              typeUrl: \"/secret.compute.v1beta1.MsgExecuteContract\",\n              value: MsgExecuteContract.encode(\n                MsgExecuteContract.fromPartial({\n                  sender: Bech32Address.fromBech32(msg.value.sender).address,\n                  contract: Bech32Address.fromBech32(msg.value.contract)\n                    .address,\n                  msg: Buffer.from(msg.value.msg, \"base64\"),\n                  sentFunds: msg.value.sent_funds,\n                })\n              ).finish(),\n            },\n          ],\n        };\n      },\n      preOnTxEvents\n    );\n  }\n\n  /**\n   * @deprecated\n   */\n  async sendExecuteSecretContractMsg(\n    // This arg can be used to override the type of sending tx if needed.\n    type: keyof SecretMsgOpts | \"unknown\" = \"executeSecretWasm\",\n    contractAddress: string,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    obj: object,\n    sentFunds: CoinPrimitive[],\n    memo: string = \"\",\n    stdFee: Optional<StdFee, \"amount\">,\n    signOptions?: KeplrSignOptions,\n    onTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ): Promise<Uint8Array> {\n    let encryptedMsg: Uint8Array;\n\n    await this.base.cosmos.sendMsgs(\n      type,\n      async () => {\n        encryptedMsg = await this.encryptSecretContractMsg(\n          contractAddress,\n          obj\n        );\n\n        const msg = {\n          type: this.msgOpts.executeSecretWasm.type,\n          value: {\n            sender: this.base.bech32Address,\n            contract: contractAddress,\n            // callback_code_hash: \"\",\n            msg: Buffer.from(encryptedMsg).toString(\"base64\"),\n            sent_funds: sentFunds,\n            // callback_sig: null,\n          },\n        };\n\n        return {\n          aminoMsgs: [msg],\n          protoMsgs: [\n            {\n              typeUrl: \"/secret.compute.v1beta1.MsgExecuteContract\",\n              value: MsgExecuteContract.encode(\n                MsgExecuteContract.fromPartial({\n                  sender: Bech32Address.fromBech32(msg.value.sender).address,\n                  contract: Bech32Address.fromBech32(msg.value.contract)\n                    .address,\n                  msg: Buffer.from(msg.value.msg, \"base64\"),\n                  sentFunds: msg.value.sent_funds,\n                })\n              ).finish(),\n            },\n          ],\n        };\n      },\n      memo,\n      {\n        amount: stdFee.amount ?? [],\n        gas: stdFee.gas,\n      },\n      signOptions,\n      onTxEvents\n    );\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return encryptedMsg!;\n  }\n\n  protected async encryptSecretContractMsg(\n    contractAddress: string,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    obj: object\n  ): Promise<Uint8Array> {\n    const queryContractCodeHashResponse = await this.queries.secret.querySecretContractCodeHash\n      .getQueryContract(contractAddress)\n      .waitResponse();\n\n    if (!queryContractCodeHashResponse) {\n      throw new Error(\n        `Can't get the code hash of the contract (${contractAddress})`\n      );\n    }\n\n    const contractCodeHash = queryContractCodeHashResponse.data.result;\n\n    const keplr = await this.base.getKeplr();\n    if (!keplr) {\n      throw new Error(\"Can't get the Keplr API\");\n    }\n\n    const enigmaUtils = keplr.getEnigmaUtils(this.chainId);\n    return await enigmaUtils.encrypt(contractCodeHash, obj);\n  }\n\n  protected get queries(): DeepReadonly<QueriesSetBase & SecretQueries> {\n    return this.queriesStore.get(this.chainId);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}