{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PermissionService = void 0;\nconst router_1 = require(\"@keplr-wallet/router\");\nconst types_1 = require(\"./types\");\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nclass PermissionService {\n  constructor(kvStore, privilegedOrigins) {\n    this.kvStore = kvStore;\n    this.permissionMap = {};\n    this.privilegedOrigins = new Map();\n    this.onChainRemoved = chainId => {\n      this.removeAllPermissions(chainId);\n    };\n    for (const origin of privilegedOrigins) {\n      this.privilegedOrigins.set(origin, true);\n    }\n    this.restore();\n  }\n  init(interactionService, chainsService, keyRingService) {\n    this.interactionService = interactionService;\n    this.chainsService = chainsService;\n    this.keyRingService = keyRingService;\n    this.chainsService.addChainRemovedHandler(this.onChainRemoved);\n  }\n  checkOrGrantBasicAccessPermission(env, chainIds, origin) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Try to unlock the key ring before checking or granting the basic permission.\n      yield this.keyRingService.enable(env);\n      if (typeof chainIds === \"string\") {\n        chainIds = [chainIds];\n      }\n      const ungrantedChainIds = [];\n      for (const chainId of chainIds) {\n        if (!this.hasPermisson(chainId, types_1.getBasicAccessPermissionType(), origin)) {\n          ungrantedChainIds.push(chainId);\n        }\n      }\n      if (ungrantedChainIds.length > 0) {\n        yield this.grantBasicAccessPermission(env, ungrantedChainIds, [origin]);\n      }\n      yield this.checkBasicAccessPermission(env, chainIds, origin);\n    });\n  }\n  grantPermission(env, url, chainIds, type, origins) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (env.isInternalMsg) {\n        return;\n      }\n      const permissionData = {\n        chainIds,\n        type,\n        origins\n      };\n      yield this.interactionService.waitApprove(env, url, types_1.INTERACTION_TYPE_PERMISSION, permissionData);\n      yield this.addPermission(chainIds, type, origins);\n    });\n  }\n  grantBasicAccessPermission(env, chainIds, origins) {\n    return __awaiter(this, void 0, void 0, function* () {\n      for (const chainId of chainIds) {\n        // Make sure that the chain info is registered.\n        yield this.chainsService.getChainInfo(chainId);\n      }\n      yield this.grantPermission(env, \"/access\", chainIds, types_1.getBasicAccessPermissionType(), origins);\n    });\n  }\n  checkPermission(env, chainId, type, origin) {\n    if (env.isInternalMsg) {\n      return;\n    }\n    if (!this.hasPermisson(chainId, type, origin)) {\n      throw new router_1.KeplrError(\"permission\", 130, `${origin} is not permitted`);\n    }\n  }\n  checkBasicAccessPermission(env, chainIds, origin) {\n    return __awaiter(this, void 0, void 0, function* () {\n      for (const chainId of chainIds) {\n        // Make sure that the chain info is registered.\n        yield this.chainsService.getChainInfo(chainId);\n        this.checkPermission(env, chainId, types_1.getBasicAccessPermissionType(), origin);\n      }\n    });\n  }\n  hasPermisson(chainId, type, origin) {\n    // Privileged origin can pass the any permission.\n    if (this.privilegedOrigins.get(origin)) {\n      return true;\n    }\n    const permissionsInChain = this.permissionMap[cosmos_1.ChainIdHelper.parse(chainId).identifier];\n    if (!permissionsInChain) {\n      return false;\n    }\n    const innerMap = permissionsInChain[type];\n    return !(!innerMap || !innerMap[origin]);\n  }\n  getPermissionOrigins(chainId, type) {\n    const origins = [];\n    const permissionsInChain = this.permissionMap[cosmos_1.ChainIdHelper.parse(chainId).identifier];\n    if (!permissionsInChain) {\n      return [];\n    }\n    const innerMap = permissionsInChain[type];\n    if (!innerMap) {\n      return [];\n    }\n    for (const origin of Object.keys(innerMap)) {\n      if (innerMap[origin]) {\n        origins.push(origin);\n      }\n    }\n    return origins;\n  }\n  getOriginPermittedChains(origin, type) {\n    var _a;\n    const chains = [];\n    for (const chain of Object.keys(this.permissionMap)) {\n      const permissionInChain = this.permissionMap[chain];\n      const originMap = (_a = permissionInChain ? permissionInChain[type] : undefined) !== null && _a !== void 0 ? _a : {};\n      for (const _origin of Object.keys(originMap)) {\n        if (_origin === origin && originMap[_origin]) {\n          chains.push(chain);\n        }\n      }\n    }\n    return chains;\n  }\n  addPermission(chainIds, type, origins) {\n    return __awaiter(this, void 0, void 0, function* () {\n      for (const chainId of chainIds) {\n        let permissionsInChain = this.permissionMap[cosmos_1.ChainIdHelper.parse(chainId).identifier];\n        if (!permissionsInChain) {\n          permissionsInChain = {};\n          this.permissionMap[cosmos_1.ChainIdHelper.parse(chainId).identifier] = permissionsInChain;\n        }\n        let innerMap = permissionsInChain[type];\n        if (!innerMap) {\n          innerMap = {};\n          permissionsInChain[type] = innerMap;\n        }\n        for (const origin of origins) {\n          innerMap[origin] = true;\n        }\n      }\n      yield this.save();\n    });\n  }\n  removePermission(chainId, type, origins) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const permissionsInChain = this.permissionMap[cosmos_1.ChainIdHelper.parse(chainId).identifier];\n      if (!permissionsInChain) {\n        return;\n      }\n      const innerMap = permissionsInChain[type];\n      if (!innerMap) {\n        return;\n      }\n      for (const origin of origins) {\n        delete innerMap[origin];\n      }\n      yield this.save();\n    });\n  }\n  removeAllPermissions(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.permissionMap[cosmos_1.ChainIdHelper.parse(chainId).identifier] = undefined;\n      yield this.save();\n    });\n  }\n  restore() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const map = yield this.kvStore.get(\"permissionMap\");\n      if (map) {\n        this.permissionMap = map;\n      }\n    });\n  }\n  save() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.kvStore.set(\"permissionMap\", this.permissionMap);\n    });\n  }\n}\nexports.PermissionService = PermissionService;","map":{"version":3,"mappings":"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","names":["PermissionService","constructor","kvStore","privilegedOrigins","Map","chainId","removeAllPermissions","origin","set","restore","init","interactionService","chainsService","keyRingService","addChainRemovedHandler","onChainRemoved","checkOrGrantBasicAccessPermission","env","chainIds","enable","ungrantedChainIds","hasPermisson","types_1","push","length","grantBasicAccessPermission","checkBasicAccessPermission","grantPermission","url","type","origins","isInternalMsg","permissionData","waitApprove","addPermission","getChainInfo","checkPermission","router_1","get","permissionsInChain","permissionMap","cosmos_1","parse","identifier","innerMap","getPermissionOrigins","Object","keys","getOriginPermittedChains","chains","chain","permissionInChain","originMap","undefined","_origin","save","removePermission","map","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/background/src/permission/service.ts"],"sourcesContent":["import { InteractionService } from \"../interaction\";\nimport { Env, KeplrError } from \"@keplr-wallet/router\";\nimport {\n  getBasicAccessPermissionType,\n  INTERACTION_TYPE_PERMISSION,\n  PermissionData,\n} from \"./types\";\nimport { KVStore } from \"@keplr-wallet/common\";\nimport { ChainsService } from \"../chains\";\nimport { KeyRingService } from \"../keyring\";\nimport { ChainIdHelper } from \"@keplr-wallet/cosmos\";\n\nexport class PermissionService {\n  protected permissionMap: {\n    [chainIdentifier: string]:\n      | {\n          [type: string]:\n            | {\n                [origin: string]: true | undefined;\n              }\n            | undefined;\n        }\n      | undefined;\n  } = {};\n\n  protected privilegedOrigins: Map<string, boolean> = new Map();\n\n  protected interactionService!: InteractionService;\n  protected chainsService!: ChainsService;\n  protected keyRingService!: KeyRingService;\n\n  constructor(\n    protected readonly kvStore: KVStore,\n    privilegedOrigins: string[]\n  ) {\n    for (const origin of privilegedOrigins) {\n      this.privilegedOrigins.set(origin, true);\n    }\n\n    this.restore();\n  }\n\n  init(\n    interactionService: InteractionService,\n    chainsService: ChainsService,\n    keyRingService: KeyRingService\n  ) {\n    this.interactionService = interactionService;\n    this.chainsService = chainsService;\n    this.keyRingService = keyRingService;\n\n    this.chainsService.addChainRemovedHandler(this.onChainRemoved);\n  }\n\n  protected readonly onChainRemoved = (chainId: string) => {\n    this.removeAllPermissions(chainId);\n  };\n\n  async checkOrGrantBasicAccessPermission(\n    env: Env,\n    chainIds: string | string[],\n    origin: string\n  ) {\n    // Try to unlock the key ring before checking or granting the basic permission.\n    await this.keyRingService.enable(env);\n\n    if (typeof chainIds === \"string\") {\n      chainIds = [chainIds];\n    }\n\n    const ungrantedChainIds: string[] = [];\n    for (const chainId of chainIds) {\n      if (!this.hasPermisson(chainId, getBasicAccessPermissionType(), origin)) {\n        ungrantedChainIds.push(chainId);\n      }\n    }\n\n    if (ungrantedChainIds.length > 0) {\n      await this.grantBasicAccessPermission(env, ungrantedChainIds, [origin]);\n    }\n\n    await this.checkBasicAccessPermission(env, chainIds, origin);\n  }\n\n  async grantPermission(\n    env: Env,\n    url: string,\n    chainIds: string[],\n    type: string,\n    origins: string[]\n  ) {\n    if (env.isInternalMsg) {\n      return;\n    }\n\n    const permissionData: PermissionData = {\n      chainIds,\n      type,\n      origins,\n    };\n\n    await this.interactionService.waitApprove(\n      env,\n      url,\n      INTERACTION_TYPE_PERMISSION,\n      permissionData\n    );\n\n    await this.addPermission(chainIds, type, origins);\n  }\n\n  async grantBasicAccessPermission(\n    env: Env,\n    chainIds: string[],\n    origins: string[]\n  ) {\n    for (const chainId of chainIds) {\n      // Make sure that the chain info is registered.\n      await this.chainsService.getChainInfo(chainId);\n    }\n\n    await this.grantPermission(\n      env,\n      \"/access\",\n      chainIds,\n      getBasicAccessPermissionType(),\n      origins\n    );\n  }\n\n  checkPermission(env: Env, chainId: string, type: string, origin: string) {\n    if (env.isInternalMsg) {\n      return;\n    }\n\n    if (!this.hasPermisson(chainId, type, origin)) {\n      throw new KeplrError(\"permission\", 130, `${origin} is not permitted`);\n    }\n  }\n\n  async checkBasicAccessPermission(\n    env: Env,\n    chainIds: string[],\n    origin: string\n  ) {\n    for (const chainId of chainIds) {\n      // Make sure that the chain info is registered.\n      await this.chainsService.getChainInfo(chainId);\n\n      this.checkPermission(\n        env,\n        chainId,\n        getBasicAccessPermissionType(),\n        origin\n      );\n    }\n  }\n\n  hasPermisson(chainId: string, type: string, origin: string): boolean {\n    // Privileged origin can pass the any permission.\n    if (this.privilegedOrigins.get(origin)) {\n      return true;\n    }\n\n    const permissionsInChain = this.permissionMap[\n      ChainIdHelper.parse(chainId).identifier\n    ];\n    if (!permissionsInChain) {\n      return false;\n    }\n\n    const innerMap = permissionsInChain[type];\n    return !(!innerMap || !innerMap[origin]);\n  }\n\n  getPermissionOrigins(chainId: string, type: string): string[] {\n    const origins = [];\n\n    const permissionsInChain = this.permissionMap[\n      ChainIdHelper.parse(chainId).identifier\n    ];\n    if (!permissionsInChain) {\n      return [];\n    }\n\n    const innerMap = permissionsInChain[type];\n    if (!innerMap) {\n      return [];\n    }\n\n    for (const origin of Object.keys(innerMap)) {\n      if (innerMap[origin]) {\n        origins.push(origin);\n      }\n    }\n\n    return origins;\n  }\n\n  getOriginPermittedChains(origin: string, type: string): string[] {\n    const chains: string[] = [];\n\n    for (const chain of Object.keys(this.permissionMap)) {\n      const permissionInChain = this.permissionMap[chain];\n\n      const originMap =\n        (permissionInChain ? permissionInChain[type] : undefined) ?? {};\n\n      for (const _origin of Object.keys(originMap)) {\n        if (_origin === origin && originMap[_origin]) {\n          chains.push(chain);\n        }\n      }\n    }\n\n    return chains;\n  }\n\n  async addPermission(chainIds: string[], type: string, origins: string[]) {\n    for (const chainId of chainIds) {\n      let permissionsInChain = this.permissionMap[\n        ChainIdHelper.parse(chainId).identifier\n      ];\n      if (!permissionsInChain) {\n        permissionsInChain = {};\n        this.permissionMap[\n          ChainIdHelper.parse(chainId).identifier\n        ] = permissionsInChain;\n      }\n\n      let innerMap = permissionsInChain[type];\n      if (!innerMap) {\n        innerMap = {};\n        permissionsInChain[type] = innerMap;\n      }\n\n      for (const origin of origins) {\n        innerMap[origin] = true;\n      }\n    }\n\n    await this.save();\n  }\n\n  async removePermission(chainId: string, type: string, origins: string[]) {\n    const permissionsInChain = this.permissionMap[\n      ChainIdHelper.parse(chainId).identifier\n    ];\n    if (!permissionsInChain) {\n      return;\n    }\n\n    const innerMap = permissionsInChain[type];\n    if (!innerMap) {\n      return;\n    }\n\n    for (const origin of origins) {\n      delete innerMap[origin];\n    }\n\n    await this.save();\n  }\n\n  async removeAllPermissions(chainId: string) {\n    this.permissionMap[ChainIdHelper.parse(chainId).identifier] = undefined;\n\n    await this.save();\n  }\n\n  protected async restore() {\n    const map = await this.kvStore.get<any>(\"permissionMap\");\n    if (map) {\n      this.permissionMap = map;\n    }\n  }\n\n  protected async save() {\n    await this.kvStore.set(\"permissionMap\", this.permissionMap);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}