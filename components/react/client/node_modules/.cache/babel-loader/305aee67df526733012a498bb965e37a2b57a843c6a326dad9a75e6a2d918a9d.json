{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PubKeySecp256k1 = exports.PrivKeySecp256k1 = void 0;\nconst elliptic_1 = require(\"elliptic\");\nconst crypto_js_1 = __importDefault(require(\"crypto-js\"));\nconst buffer_1 = require(\"buffer/\");\nclass PrivKeySecp256k1 {\n  constructor(privKey) {\n    this.privKey = privKey;\n  }\n  static generateRandomKey() {\n    const secp256k1 = new elliptic_1.ec(\"secp256k1\");\n    return new PrivKeySecp256k1(buffer_1.Buffer.from(secp256k1.genKeyPair().getPrivate().toArray()));\n  }\n  toBytes() {\n    return new Uint8Array(this.privKey);\n  }\n  getPubKey() {\n    const secp256k1 = new elliptic_1.ec(\"secp256k1\");\n    const key = secp256k1.keyFromPrivate(this.privKey);\n    return new PubKeySecp256k1(new Uint8Array(key.getPublic().encodeCompressed(\"array\")));\n  }\n  sign(msg) {\n    const secp256k1 = new elliptic_1.ec(\"secp256k1\");\n    const key = secp256k1.keyFromPrivate(this.privKey);\n    const hash = crypto_js_1.default.SHA256(crypto_js_1.default.lib.WordArray.create(msg)).toString();\n    const signature = key.sign(buffer_1.Buffer.from(hash, \"hex\"), {\n      canonical: true\n    });\n    return new Uint8Array(signature.r.toArray(\"be\", 32).concat(signature.s.toArray(\"be\", 32)));\n  }\n}\nexports.PrivKeySecp256k1 = PrivKeySecp256k1;\nclass PubKeySecp256k1 {\n  constructor(pubKey) {\n    this.pubKey = pubKey;\n  }\n  toBytes() {\n    return new Uint8Array(this.pubKey);\n  }\n  getAddress() {\n    let hash = crypto_js_1.default.SHA256(crypto_js_1.default.lib.WordArray.create(this.pubKey)).toString();\n    hash = crypto_js_1.default.RIPEMD160(crypto_js_1.default.enc.Hex.parse(hash)).toString();\n    return new Uint8Array(buffer_1.Buffer.from(hash, \"hex\"));\n  }\n  toKeyPair() {\n    const secp256k1 = new elliptic_1.ec(\"secp256k1\");\n    return secp256k1.keyFromPublic(buffer_1.Buffer.from(this.pubKey).toString(\"hex\"), \"hex\");\n  }\n  verify(msg, signature) {\n    const hash = crypto_js_1.default.SHA256(crypto_js_1.default.lib.WordArray.create(msg)).toString();\n    const secp256k1 = new elliptic_1.ec(\"secp256k1\");\n    let r = signature.slice(0, 32);\n    let s = signature.slice(32);\n    const rIsNegative = r[0] >= 0x80;\n    const sIsNegative = s[0] >= 0x80;\n    if (rIsNegative) {\n      r = new Uint8Array([0, ...r]);\n    }\n    if (sIsNegative) {\n      s = new Uint8Array([0, ...s]);\n    }\n    // Der encoding\n    const derData = new Uint8Array([0x02, r.length, ...r, 0x02, s.length, ...s]);\n    return secp256k1.verify(buffer_1.Buffer.from(hash, \"hex\"), new Uint8Array([0x30, derData.length, ...derData]), this.toKeyPair());\n  }\n}\nexports.PubKeySecp256k1 = PubKeySecp256k1;","map":{"version":3,"mappings":"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","names":["PrivKeySecp256k1","constructor","privKey","generateRandomKey","secp256k1","elliptic_1","buffer_1","from","genKeyPair","getPrivate","toArray","toBytes","Uint8Array","getPubKey","key","keyFromPrivate","PubKeySecp256k1","getPublic","encodeCompressed","sign","msg","hash","crypto_js_1","SHA256","lib","WordArray","create","toString","signature","canonical","r","concat","s","exports","pubKey","getAddress","RIPEMD160","enc","Hex","parse","toKeyPair","keyFromPublic","verify","slice","rIsNegative","sIsNegative","derData","length"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/node_modules/@keplr-wallet/crypto/src/key.ts"],"sourcesContent":["import { ec } from \"elliptic\";\nimport CryptoJS from \"crypto-js\";\n\nimport { Buffer } from \"buffer/\";\n\nexport class PrivKeySecp256k1 {\n  static generateRandomKey(): PrivKeySecp256k1 {\n    const secp256k1 = new ec(\"secp256k1\");\n\n    return new PrivKeySecp256k1(\n      Buffer.from(secp256k1.genKeyPair().getPrivate().toArray())\n    );\n  }\n\n  constructor(protected readonly privKey: Uint8Array) {}\n\n  toBytes(): Uint8Array {\n    return new Uint8Array(this.privKey);\n  }\n\n  getPubKey(): PubKeySecp256k1 {\n    const secp256k1 = new ec(\"secp256k1\");\n\n    const key = secp256k1.keyFromPrivate(this.privKey);\n\n    return new PubKeySecp256k1(\n      new Uint8Array(key.getPublic().encodeCompressed(\"array\"))\n    );\n  }\n\n  sign(msg: Uint8Array): Uint8Array {\n    const secp256k1 = new ec(\"secp256k1\");\n    const key = secp256k1.keyFromPrivate(this.privKey);\n\n    const hash = CryptoJS.SHA256(\n      CryptoJS.lib.WordArray.create(msg as any)\n    ).toString();\n\n    const signature = key.sign(Buffer.from(hash, \"hex\"), {\n      canonical: true,\n    });\n\n    return new Uint8Array(\n      signature.r.toArray(\"be\", 32).concat(signature.s.toArray(\"be\", 32))\n    );\n  }\n}\n\nexport class PubKeySecp256k1 {\n  constructor(protected readonly pubKey: Uint8Array) {}\n\n  toBytes(): Uint8Array {\n    return new Uint8Array(this.pubKey);\n  }\n\n  getAddress(): Uint8Array {\n    let hash = CryptoJS.SHA256(\n      CryptoJS.lib.WordArray.create(this.pubKey as any)\n    ).toString();\n    hash = CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(hash)).toString();\n\n    return new Uint8Array(Buffer.from(hash, \"hex\"));\n  }\n\n  toKeyPair(): ec.KeyPair {\n    const secp256k1 = new ec(\"secp256k1\");\n\n    return secp256k1.keyFromPublic(\n      Buffer.from(this.pubKey).toString(\"hex\"),\n      \"hex\"\n    );\n  }\n\n  verify(msg: Uint8Array, signature: Uint8Array): boolean {\n    const hash = CryptoJS.SHA256(\n      CryptoJS.lib.WordArray.create(msg as any)\n    ).toString();\n\n    const secp256k1 = new ec(\"secp256k1\");\n\n    let r = signature.slice(0, 32);\n    let s = signature.slice(32);\n    const rIsNegative = r[0] >= 0x80;\n    const sIsNegative = s[0] >= 0x80;\n    if (rIsNegative) {\n      r = new Uint8Array([0, ...r]);\n    }\n    if (sIsNegative) {\n      s = new Uint8Array([0, ...s]);\n    }\n\n    // Der encoding\n    const derData = new Uint8Array([\n      0x02,\n      r.length,\n      ...r,\n      0x02,\n      s.length,\n      ...s,\n    ]);\n    return secp256k1.verify(\n      Buffer.from(hash, \"hex\"),\n      new Uint8Array([0x30, derData.length, ...derData]),\n      this.toKeyPair()\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}