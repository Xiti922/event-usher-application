{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CosmJSOfflineSigner = exports.CosmJSOfflineSignerOnlyAmino = void 0;\nclass CosmJSOfflineSignerOnlyAmino {\n  constructor(chainId, keplr) {\n    this.chainId = chainId;\n    this.keplr = keplr;\n  }\n  getAccounts() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const key = yield this.keplr.getKey(this.chainId);\n      return [{\n        address: key.bech32Address,\n        // Currently, only secp256k1 is supported.\n        algo: \"secp256k1\",\n        pubkey: key.pubKey\n      }];\n    });\n  }\n  signAmino(signerAddress, signDoc) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.chainId !== signDoc.chain_id) {\n        throw new Error(\"Unmatched chain id with the offline signer\");\n      }\n      const key = yield this.keplr.getKey(signDoc.chain_id);\n      if (key.bech32Address !== signerAddress) {\n        throw new Error(\"Unknown signer address\");\n      }\n      return yield this.keplr.signAmino(this.chainId, signerAddress, signDoc);\n    });\n  }\n  // Fallback function for the legacy cosmjs implementation before the staragte.\n  sign(signerAddress, signDoc) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.signAmino(signerAddress, signDoc);\n    });\n  }\n}\nexports.CosmJSOfflineSignerOnlyAmino = CosmJSOfflineSignerOnlyAmino;\nclass CosmJSOfflineSigner extends CosmJSOfflineSignerOnlyAmino {\n  constructor(chainId, keplr) {\n    super(chainId, keplr);\n    this.chainId = chainId;\n    this.keplr = keplr;\n  }\n  signDirect(signerAddress, signDoc) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.chainId !== signDoc.chainId) {\n        throw new Error(\"Unmatched chain id with the offline signer\");\n      }\n      const key = yield this.keplr.getKey(signDoc.chainId);\n      if (key.bech32Address !== signerAddress) {\n        throw new Error(\"Unknown signer address\");\n      }\n      return yield this.keplr.signDirect(this.chainId, signerAddress, signDoc);\n    });\n  }\n}\nexports.CosmJSOfflineSigner = CosmJSOfflineSigner;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA,MAAaA,4BAA4B;EACvCC,YACqBC,OAAe,EACfC,KAAY;IADZ,YAAO,GAAPD,OAAO;IACP,UAAK,GAALC,KAAK;EACvB;EAEGC,WAAW;;MACf,MAAMC,GAAG,GAAG,MAAM,IAAI,CAACF,KAAK,CAACG,MAAM,CAAC,IAAI,CAACJ,OAAO,CAAC;MAEjD,OAAO,CACL;QACEK,OAAO,EAAEF,GAAG,CAACG,aAAa;QAC1B;QACAC,IAAI,EAAE,WAAW;QACjBC,MAAM,EAAEL,GAAG,CAACM;OACb,CACF;IACH,CAAC;;EAEKC,SAAS,CACbC,aAAqB,EACrBC,OAAmB;;MAEnB,IAAI,IAAI,CAACZ,OAAO,KAAKY,OAAO,CAACC,QAAQ,EAAE;QACrC,MAAM,IAAIC,KAAK,CAAC,4CAA4C,CAAC;;MAG/D,MAAMX,GAAG,GAAG,MAAM,IAAI,CAACF,KAAK,CAACG,MAAM,CAACQ,OAAO,CAACC,QAAQ,CAAC;MAErD,IAAIV,GAAG,CAACG,aAAa,KAAKK,aAAa,EAAE;QACvC,MAAM,IAAIG,KAAK,CAAC,wBAAwB,CAAC;;MAG3C,OAAO,MAAM,IAAI,CAACb,KAAK,CAACS,SAAS,CAAC,IAAI,CAACV,OAAO,EAAEW,aAAa,EAAEC,OAAO,CAAC;IACzE,CAAC;;EAED;EACMG,IAAI,CACRJ,aAAqB,EACrBC,OAAmB;;MAEnB,OAAO,MAAM,IAAI,CAACF,SAAS,CAACC,aAAa,EAAEC,OAAO,CAAC;IACrD,CAAC;;;AA1CHI;AA6CA,MAAaC,mBACX,SAAQnB,4BAA4B;EAEpCC,YACqBC,OAAe,EACfC,KAAY;IAE/B,KAAK,CAACD,OAAO,EAAEC,KAAK,CAAC;IAHF,YAAO,GAAPD,OAAO;IACP,UAAK,GAALC,KAAK;EAG1B;EAEMiB,UAAU,CACdP,aAAqB,EACrBC,OAAgB;;MAEhB,IAAI,IAAI,CAACZ,OAAO,KAAKY,OAAO,CAACZ,OAAO,EAAE;QACpC,MAAM,IAAIc,KAAK,CAAC,4CAA4C,CAAC;;MAG/D,MAAMX,GAAG,GAAG,MAAM,IAAI,CAACF,KAAK,CAACG,MAAM,CAACQ,OAAO,CAACZ,OAAO,CAAC;MAEpD,IAAIG,GAAG,CAACG,aAAa,KAAKK,aAAa,EAAE;QACvC,MAAM,IAAIG,KAAK,CAAC,wBAAwB,CAAC;;MAG3C,OAAO,MAAM,IAAI,CAACb,KAAK,CAACiB,UAAU,CAAC,IAAI,CAAClB,OAAO,EAAEW,aAAa,EAAEC,OAAO,CAAC;IAC1E,CAAC;;;AAzBHI","names":["CosmJSOfflineSignerOnlyAmino","constructor","chainId","keplr","getAccounts","key","getKey","address","bech32Address","algo","pubkey","pubKey","signAmino","signerAddress","signDoc","chain_id","Error","sign","exports","CosmJSOfflineSigner","signDirect"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/provider/src/cosmjs.ts"],"sourcesContent":["import {\n  OfflineSigner,\n  AccountData,\n  AminoSignResponse,\n  StdSignDoc,\n} from \"@cosmjs/launchpad\";\nimport { Keplr } from \"@keplr-wallet/types\";\nimport { OfflineDirectSigner } from \"@cosmjs/proto-signing\";\nimport { DirectSignResponse } from \"@cosmjs/proto-signing/build/signer\";\nimport { SignDoc } from \"@cosmjs/proto-signing/build/codec/cosmos/tx/v1beta1/tx\";\n\nexport class CosmJSOfflineSignerOnlyAmino implements OfflineSigner {\n  constructor(\n    protected readonly chainId: string,\n    protected readonly keplr: Keplr\n  ) {}\n\n  async getAccounts(): Promise<AccountData[]> {\n    const key = await this.keplr.getKey(this.chainId);\n\n    return [\n      {\n        address: key.bech32Address,\n        // Currently, only secp256k1 is supported.\n        algo: \"secp256k1\",\n        pubkey: key.pubKey,\n      },\n    ];\n  }\n\n  async signAmino(\n    signerAddress: string,\n    signDoc: StdSignDoc\n  ): Promise<AminoSignResponse> {\n    if (this.chainId !== signDoc.chain_id) {\n      throw new Error(\"Unmatched chain id with the offline signer\");\n    }\n\n    const key = await this.keplr.getKey(signDoc.chain_id);\n\n    if (key.bech32Address !== signerAddress) {\n      throw new Error(\"Unknown signer address\");\n    }\n\n    return await this.keplr.signAmino(this.chainId, signerAddress, signDoc);\n  }\n\n  // Fallback function for the legacy cosmjs implementation before the staragte.\n  async sign(\n    signerAddress: string,\n    signDoc: StdSignDoc\n  ): Promise<AminoSignResponse> {\n    return await this.signAmino(signerAddress, signDoc);\n  }\n}\n\nexport class CosmJSOfflineSigner\n  extends CosmJSOfflineSignerOnlyAmino\n  implements OfflineSigner, OfflineDirectSigner {\n  constructor(\n    protected readonly chainId: string,\n    protected readonly keplr: Keplr\n  ) {\n    super(chainId, keplr);\n  }\n\n  async signDirect(\n    signerAddress: string,\n    signDoc: SignDoc\n  ): Promise<DirectSignResponse> {\n    if (this.chainId !== signDoc.chainId) {\n      throw new Error(\"Unmatched chain id with the offline signer\");\n    }\n\n    const key = await this.keplr.getKey(signDoc.chainId);\n\n    if (key.bech32Address !== signerAddress) {\n      throw new Error(\"Unknown signer address\");\n    }\n\n    return await this.keplr.signDirect(this.chainId, signerAddress, signDoc);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}