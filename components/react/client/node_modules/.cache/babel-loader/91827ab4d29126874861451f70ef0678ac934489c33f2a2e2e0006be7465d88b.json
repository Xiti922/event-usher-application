{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifyADR36Amino = exports.verifyADR36AminoSignDoc = exports.makeADR36AminoSignDoc = exports.checkAndValidateADR36AminoSignDoc = void 0;\nconst launchpad_1 = require(\"@cosmjs/launchpad\");\nconst bech32_1 = require(\"../bech32\");\nconst buffer_1 = require(\"buffer/\");\nconst crypto_1 = require(\"@keplr-wallet/crypto\");\n/**\n * Check the sign doc is for ADR-36.\n * If the sign doc is expected to be ADR-36, validate the sign doc and throw an error if the sign doc is valid ADR-36.\n * @param signDoc\n * @param bech32PrefixAccAddr If this argument is provided, validate the signer in the `MsgSignData` with this prefix.\n *                            If not, validate the signer in the `MsgSignData` without considering the bech32 prefix.\n */\nfunction checkAndValidateADR36AminoSignDoc(signDoc, bech32PrefixAccAddr) {\n  const hasOnlyMsgSignData = (() => {\n    if (signDoc && signDoc.msgs && Array.isArray(signDoc.msgs) && signDoc.msgs.length === 1) {\n      const msg = signDoc.msgs[0];\n      return msg.type === \"sign/MsgSignData\";\n    } else {\n      return false;\n    }\n  })();\n  if (!hasOnlyMsgSignData) {\n    return false;\n  }\n  if (signDoc.chain_id !== \"\") {\n    throw new Error(\"Chain id should be empty string for ADR-36 signing\");\n  }\n  if (signDoc.memo !== \"\") {\n    throw new Error(\"Memo should be empty string for ADR-36 signing\");\n  }\n  if (signDoc.account_number !== \"0\") {\n    throw new Error('Account number should be \"0\" for ADR-36 signing');\n  }\n  if (signDoc.sequence !== \"0\") {\n    throw new Error('Sequence should be \"0\" for ADR-36 signing');\n  }\n  if (signDoc.fee.gas !== \"0\") {\n    throw new Error('Gas should be \"0\" for ADR-36 signing');\n  }\n  if (signDoc.fee.amount.length !== 0) {\n    throw new Error(\"Fee amount should be empty array for ADR-36 signing\");\n  }\n  const msg = signDoc.msgs[0];\n  if (msg.type !== \"sign/MsgSignData\") {\n    throw new Error(`Invalid type of ADR-36 sign msg: ${msg.type}`);\n  }\n  if (!msg.value) {\n    throw new Error(\"Empty value in the msg\");\n  }\n  const signer = msg.value.signer;\n  if (!signer) {\n    throw new Error(\"Empty signer in the ADR-36 msg\");\n  }\n  bech32_1.Bech32Address.validate(signer, bech32PrefixAccAddr);\n  const data = msg.value.data;\n  if (!data) {\n    throw new Error(\"Empty data in the ADR-36 msg\");\n  }\n  const rawData = buffer_1.Buffer.from(data, \"base64\");\n  // Validate the data is encoded as base64.\n  if (rawData.toString(\"base64\") !== data) {\n    throw new Error(\"Data is not encoded by base64\");\n  }\n  if (rawData.length === 0) {\n    throw new Error(\"Empty data in the ADR-36 msg\");\n  }\n  return true;\n}\nexports.checkAndValidateADR36AminoSignDoc = checkAndValidateADR36AminoSignDoc;\nfunction makeADR36AminoSignDoc(signer, data) {\n  if (typeof data === \"string\") {\n    data = buffer_1.Buffer.from(data).toString(\"base64\");\n  } else {\n    data = buffer_1.Buffer.from(data).toString(\"base64\");\n  }\n  return {\n    chain_id: \"\",\n    account_number: \"0\",\n    sequence: \"0\",\n    fee: {\n      gas: \"0\",\n      amount: []\n    },\n    msgs: [{\n      type: \"sign/MsgSignData\",\n      value: {\n        signer,\n        data\n      }\n    }],\n    memo: \"\"\n  };\n}\nexports.makeADR36AminoSignDoc = makeADR36AminoSignDoc;\nfunction verifyADR36AminoSignDoc(bech32PrefixAccAddr, signDoc, pubKey, signature) {\n  if (!checkAndValidateADR36AminoSignDoc(signDoc, bech32PrefixAccAddr)) {\n    throw new Error(\"Invalid sign doc for ADR-36\");\n  }\n  const cryptoPubKey = new crypto_1.PubKeySecp256k1(pubKey);\n  const expectedSigner = new bech32_1.Bech32Address(cryptoPubKey.getAddress()).toBech32(bech32PrefixAccAddr);\n  const signer = signDoc.msgs[0].value.signer;\n  if (expectedSigner !== signer) {\n    throw new Error(\"Unmatched signer\");\n  }\n  const msg = launchpad_1.serializeSignDoc(signDoc);\n  return cryptoPubKey.verify(msg, signature);\n}\nexports.verifyADR36AminoSignDoc = verifyADR36AminoSignDoc;\nfunction verifyADR36Amino(bech32PrefixAccAddr, signer, data, pubKey, signature) {\n  const signDoc = makeADR36AminoSignDoc(signer, data);\n  return verifyADR36AminoSignDoc(bech32PrefixAccAddr, signDoc, pubKey, signature);\n}\nexports.verifyADR36Amino = verifyADR36Amino;","map":{"version":3,"mappings":"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","names":["checkAndValidateADR36AminoSignDoc","signDoc","bech32PrefixAccAddr","hasOnlyMsgSignData","msgs","Array","isArray","length","msg","type","chain_id","Error","memo","account_number","sequence","fee","gas","amount","value","signer","bech32_1","validate","data","rawData","buffer_1","from","toString","exports","makeADR36AminoSignDoc","verifyADR36AminoSignDoc","pubKey","signature","cryptoPubKey","crypto_1","expectedSigner","getAddress","toBech32","launchpad_1","verify","verifyADR36Amino"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/cosmos/src/adr-36/amino.ts"],"sourcesContent":["import { serializeSignDoc, StdSignDoc } from \"@cosmjs/launchpad\";\nimport { Bech32Address } from \"../bech32\";\nimport { Buffer } from \"buffer/\";\nimport { PubKeySecp256k1 } from \"@keplr-wallet/crypto\";\n\n/**\n * Check the sign doc is for ADR-36.\n * If the sign doc is expected to be ADR-36, validate the sign doc and throw an error if the sign doc is valid ADR-36.\n * @param signDoc\n * @param bech32PrefixAccAddr If this argument is provided, validate the signer in the `MsgSignData` with this prefix.\n *                            If not, validate the signer in the `MsgSignData` without considering the bech32 prefix.\n */\nexport function checkAndValidateADR36AminoSignDoc(\n  signDoc: StdSignDoc,\n  bech32PrefixAccAddr?: string\n): boolean {\n  const hasOnlyMsgSignData = (() => {\n    if (\n      signDoc &&\n      signDoc.msgs &&\n      Array.isArray(signDoc.msgs) &&\n      signDoc.msgs.length === 1\n    ) {\n      const msg = signDoc.msgs[0];\n      return msg.type === \"sign/MsgSignData\";\n    } else {\n      return false;\n    }\n  })();\n\n  if (!hasOnlyMsgSignData) {\n    return false;\n  }\n\n  if (signDoc.chain_id !== \"\") {\n    throw new Error(\"Chain id should be empty string for ADR-36 signing\");\n  }\n\n  if (signDoc.memo !== \"\") {\n    throw new Error(\"Memo should be empty string for ADR-36 signing\");\n  }\n\n  if (signDoc.account_number !== \"0\") {\n    throw new Error('Account number should be \"0\" for ADR-36 signing');\n  }\n\n  if (signDoc.sequence !== \"0\") {\n    throw new Error('Sequence should be \"0\" for ADR-36 signing');\n  }\n\n  if (signDoc.fee.gas !== \"0\") {\n    throw new Error('Gas should be \"0\" for ADR-36 signing');\n  }\n\n  if (signDoc.fee.amount.length !== 0) {\n    throw new Error(\"Fee amount should be empty array for ADR-36 signing\");\n  }\n\n  const msg = signDoc.msgs[0];\n  if (msg.type !== \"sign/MsgSignData\") {\n    throw new Error(`Invalid type of ADR-36 sign msg: ${msg.type}`);\n  }\n  if (!msg.value) {\n    throw new Error(\"Empty value in the msg\");\n  }\n  const signer = msg.value.signer;\n  if (!signer) {\n    throw new Error(\"Empty signer in the ADR-36 msg\");\n  }\n  Bech32Address.validate(signer, bech32PrefixAccAddr);\n  const data = msg.value.data;\n  if (!data) {\n    throw new Error(\"Empty data in the ADR-36 msg\");\n  }\n  const rawData = Buffer.from(data, \"base64\");\n  // Validate the data is encoded as base64.\n  if (rawData.toString(\"base64\") !== data) {\n    throw new Error(\"Data is not encoded by base64\");\n  }\n  if (rawData.length === 0) {\n    throw new Error(\"Empty data in the ADR-36 msg\");\n  }\n\n  return true;\n}\n\nexport function makeADR36AminoSignDoc(\n  signer: string,\n  data: string | Uint8Array\n): StdSignDoc {\n  if (typeof data === \"string\") {\n    data = Buffer.from(data).toString(\"base64\");\n  } else {\n    data = Buffer.from(data).toString(\"base64\");\n  }\n\n  return {\n    chain_id: \"\",\n    account_number: \"0\",\n    sequence: \"0\",\n    fee: {\n      gas: \"0\",\n      amount: [],\n    },\n    msgs: [\n      {\n        type: \"sign/MsgSignData\",\n        value: {\n          signer,\n          data,\n        },\n      },\n    ],\n    memo: \"\",\n  };\n}\n\nexport function verifyADR36AminoSignDoc(\n  bech32PrefixAccAddr: string,\n  signDoc: StdSignDoc,\n  pubKey: Uint8Array,\n  signature: Uint8Array\n): boolean {\n  if (!checkAndValidateADR36AminoSignDoc(signDoc, bech32PrefixAccAddr)) {\n    throw new Error(\"Invalid sign doc for ADR-36\");\n  }\n\n  const cryptoPubKey = new PubKeySecp256k1(pubKey);\n  const expectedSigner = new Bech32Address(cryptoPubKey.getAddress()).toBech32(\n    bech32PrefixAccAddr\n  );\n  const signer = signDoc.msgs[0].value.signer;\n  if (expectedSigner !== signer) {\n    throw new Error(\"Unmatched signer\");\n  }\n\n  const msg = serializeSignDoc(signDoc);\n\n  return cryptoPubKey.verify(msg, signature);\n}\n\nexport function verifyADR36Amino(\n  bech32PrefixAccAddr: string,\n  signer: string,\n  data: string | Uint8Array,\n  pubKey: Uint8Array,\n  signature: Uint8Array\n): boolean {\n  const signDoc = makeADR36AminoSignDoc(signer, data);\n\n  return verifyADR36AminoSignDoc(\n    bech32PrefixAccAddr,\n    signDoc,\n    pubKey,\n    signature\n  );\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}