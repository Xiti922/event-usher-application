{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableJsonRPCQueryMap = exports.ObservableJsonRPCQuery = void 0;\nconst index_1 = require(\"./index\");\nconst mobx_1 = require(\"mobx\");\nconst crypto_1 = require(\"@keplr-wallet/crypto\");\nconst buffer_1 = require(\"buffer/\");\nconst map_1 = require(\"../map\");\n/**\n * Experimental implementation for json rpc.\n */\nclass ObservableJsonRPCQuery extends index_1.ObservableQuery {\n  constructor(kvStore, instance, url, method, params) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    super(kvStore, instance, url, options);\n    this.method = method;\n    this._params = params;\n    mobx_1.makeObservable(this);\n  }\n  get params() {\n    return this._params;\n  }\n  setParams(params) {\n    this._params = params;\n    this.fetch();\n  }\n  fetchResponse(abortController) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = yield this.instance.post(this.url, {\n        jsonrpc: \"2.0\",\n        id: \"1\",\n        method: this.method,\n        params: this.params\n      }, {\n        signal: abortController.signal\n      });\n      if (result.data.error && result.data.error.message) {\n        throw new Error(result.data.error.message);\n      }\n      if (!result.data.result) {\n        throw new Error(\"Unknown error\");\n      }\n      return {\n        headers: result.headers,\n        response: {\n          data: result.data.result,\n          status: result.status,\n          staled: false,\n          timestamp: Date.now()\n        }\n      };\n    });\n  }\n  getCacheKey() {\n    const paramsHash = buffer_1.Buffer.from(crypto_1.Hash.sha256(buffer_1.Buffer.from(JSON.stringify(this.params))).slice(0, 8)).toString(\"hex\");\n    return `${super.getCacheKey()}-${this.method}-${paramsHash}`;\n  }\n}\n__decorate([mobx_1.observable.ref], ObservableJsonRPCQuery.prototype, \"_params\", void 0);\n__decorate([mobx_1.action], ObservableJsonRPCQuery.prototype, \"setParams\", null);\nexports.ObservableJsonRPCQuery = ObservableJsonRPCQuery;\nclass ObservableJsonRPCQueryMap extends map_1.HasMapStore {\n  constructor(creater) {\n    super(creater);\n  }\n}\nexports.ObservableJsonRPCQueryMap = ObservableJsonRPCQueryMap;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAGA;AACA;AACA;AACA;AAEA;;;AAGA,MAAaA,sBAGX,SAAQC,uBAAqB;EAI7BC,YACEC,OAAgB,EAChBC,QAAuB,EACvBC,GAAW,EACQC,MAAc,EACjCC,MAAsB,EACa;IAAA,IAAnCC,8EAAiC,EAAE;IAEnC,KAAK,CAACL,OAAO,EAAEC,QAAQ,EAAEC,GAAG,EAAEG,OAAO,CAAC;IAJnB,WAAM,GAANF,MAAM;IAMzB,IAAI,CAACG,OAAO,GAAGF,MAAM;IAErBG,qBAAc,CAAC,IAAI,CAAC;EACtB;EAEA,IAAIH,MAAM;IACR,OAAO,IAAI,CAACE,OAAO;EACrB;EAGUE,SAAS,CAACJ,MAAsB;IACxC,IAAI,CAACE,OAAO,GAAGF,MAAM;IACrB,IAAI,CAACK,KAAK,EAAE;EACd;EAEgBC,aAAa,CAC3BC,eAAgC;;MAEhC,MAAMC,MAAM,GAAG,MAAM,IAAI,CAACX,QAAQ,CAACY,IAAI,CASrC,IAAI,CAACX,GAAG,EACR;QACEY,OAAO,EAAE,KAAK;QACdC,EAAE,EAAE,GAAG;QACPZ,MAAM,EAAE,IAAI,CAACA,MAAM;QACnBC,MAAM,EAAE,IAAI,CAACA;OACd,EACD;QACEY,MAAM,EAAEL,eAAe,CAACK;OACzB,CACF;MAED,IAAIJ,MAAM,CAACK,IAAI,CAACC,KAAK,IAAIN,MAAM,CAACK,IAAI,CAACC,KAAK,CAACC,OAAO,EAAE;QAClD,MAAM,IAAIC,KAAK,CAACR,MAAM,CAACK,IAAI,CAACC,KAAK,CAACC,OAAO,CAAC;;MAG5C,IAAI,CAACP,MAAM,CAACK,IAAI,CAACL,MAAM,EAAE;QACvB,MAAM,IAAIQ,KAAK,CAAC,eAAe,CAAC;;MAGlC,OAAO;QACLC,OAAO,EAAET,MAAM,CAACS,OAAO;QACvBC,QAAQ,EAAE;UACRL,IAAI,EAAEL,MAAM,CAACK,IAAI,CAACL,MAAM;UACxBW,MAAM,EAAEX,MAAM,CAACW,MAAM;UACrBC,MAAM,EAAE,KAAK;UACbC,SAAS,EAAEC,IAAI,CAACC,GAAG;;OAEtB;IACH,CAAC;;EAESC,WAAW;IACnB,MAAMC,UAAU,GAAGC,eAAM,CAACC,IAAI,CAC5BC,aAAI,CAACC,MAAM,CAACH,eAAM,CAACC,IAAI,CAACG,IAAI,CAACC,SAAS,CAAC,IAAI,CAAC/B,MAAM,CAAC,CAAC,CAAC,CAACgC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAClE,CAACC,QAAQ,CAAC,KAAK,CAAC;IAEjB,OAAO,GAAG,KAAK,CAACT,WAAW,EAAE,IAAI,IAAI,CAACzB,MAAM,IAAI0B,UAAU,EAAE;EAC9D;;AA5EAS,YADC/B,iBAAU,CAACgC,GAAG,uDACmB;AAsBlCD,YADC/B,aAAM,uDAIN;AA9BHiC;AAoFA,MAAaC,yBAGX,SAAQC,iBAAyC;EACjD3C,YAAY4C,OAAsD;IAChE,KAAK,CAACA,OAAO,CAAC;EAChB;;AANFH","names":["ObservableJsonRPCQuery","index_1","constructor","kvStore","instance","url","method","params","options","_params","mobx_1","setParams","fetch","fetchResponse","abortController","result","post","jsonrpc","id","signal","data","error","message","Error","headers","response","status","staled","timestamp","Date","now","getCacheKey","paramsHash","buffer_1","from","crypto_1","sha256","JSON","stringify","slice","toString","__decorate","ref","exports","ObservableJsonRPCQueryMap","map_1","creater"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/common/query/json-rpc.ts"],"sourcesContent":["import { ObservableQuery, QueryOptions, QueryResponse } from \"./index\";\nimport { KVStore } from \"@keplr-wallet/common\";\nimport { AxiosInstance } from \"axios\";\nimport { action, makeObservable, observable } from \"mobx\";\nimport { Hash } from \"@keplr-wallet/crypto\";\nimport { Buffer } from \"buffer/\";\nimport { HasMapStore } from \"../map\";\n\n/**\n * Experimental implementation for json rpc.\n */\nexport class ObservableJsonRPCQuery<\n  T = unknown,\n  E = unknown\n> extends ObservableQuery<T, E> {\n  @observable.ref\n  protected _params: readonly any[];\n\n  constructor(\n    kvStore: KVStore,\n    instance: AxiosInstance,\n    url: string,\n    protected readonly method: string,\n    params: readonly any[],\n    options: Partial<QueryOptions> = {}\n  ) {\n    super(kvStore, instance, url, options);\n\n    this._params = params;\n\n    makeObservable(this);\n  }\n\n  get params(): readonly any[] {\n    return this._params;\n  }\n\n  @action\n  protected setParams(params: readonly any[]) {\n    this._params = params;\n    this.fetch();\n  }\n\n  protected async fetchResponse(\n    abortController: AbortController\n  ): Promise<{ response: QueryResponse<T>; headers: any }> {\n    const result = await this.instance.post<{\n      jsonrpc: \"2.0\";\n      result?: T;\n      id: string;\n      error?: {\n        code?: number;\n        message?: string;\n      };\n    }>(\n      this.url,\n      {\n        jsonrpc: \"2.0\",\n        id: \"1\",\n        method: this.method,\n        params: this.params,\n      },\n      {\n        signal: abortController.signal,\n      }\n    );\n\n    if (result.data.error && result.data.error.message) {\n      throw new Error(result.data.error.message);\n    }\n\n    if (!result.data.result) {\n      throw new Error(\"Unknown error\");\n    }\n\n    return {\n      headers: result.headers,\n      response: {\n        data: result.data.result,\n        status: result.status,\n        staled: false,\n        timestamp: Date.now(),\n      },\n    };\n  }\n\n  protected getCacheKey(): string {\n    const paramsHash = Buffer.from(\n      Hash.sha256(Buffer.from(JSON.stringify(this.params))).slice(0, 8)\n    ).toString(\"hex\");\n\n    return `${super.getCacheKey()}-${this.method}-${paramsHash}`;\n  }\n}\n\nexport class ObservableJsonRPCQueryMap<\n  T = unknown,\n  E = unknown\n> extends HasMapStore<ObservableJsonRPCQuery<T, E>> {\n  constructor(creater: (key: string) => ObservableJsonRPCQuery<T, E>) {\n    super(creater);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}