{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SignDocWrapper = void 0;\nconst decoder_1 = require(\"../decoder\");\nconst proto_1 = require(\"../proto\");\nconst adr_36_1 = require(\"../../adr-36\");\nclass SignDocWrapper {\n  constructor(signDoc) {\n    this.signDoc = signDoc;\n    if (\"msgs\" in signDoc) {\n      this.mode = \"amino\";\n    } else {\n      this.mode = \"direct\";\n    }\n    if (this.mode === \"amino\") {\n      // Check that the sign doc is for ADR-36.\n      // The validation should be performed on the background process.\n      // So, here, we check once more, but the validation related to bech32 is considered to be done in the background process.\n      this.isADR36SignDoc = adr_36_1.checkAndValidateADR36AminoSignDoc(this.aminoSignDoc);\n    } else {\n      // Currently, only support amino sign doc for ADR-36\n      this.isADR36SignDoc = false;\n    }\n  }\n  static fromAminoSignDoc(signDoc) {\n    return new SignDocWrapper(signDoc);\n  }\n  static fromDirectSignDoc(signDoc) {\n    return new SignDocWrapper(signDoc);\n  }\n  static fromDirectSignDocBytes(signDocBytes) {\n    return new SignDocWrapper(proto_1.cosmos.tx.v1beta1.SignDoc.decode(signDocBytes));\n  }\n  clone() {\n    return new SignDocWrapper(this.signDoc);\n  }\n  get protoSignDoc() {\n    if (this.mode === \"amino\") {\n      throw new Error(\"Sign doc is encoded as Amino Json\");\n    }\n    if (\"msgs\" in this.signDoc) {\n      throw new Error(\"Unexpected error\");\n    }\n    if (!this._protoSignDoc) {\n      this._protoSignDoc = new decoder_1.ProtoSignDocDecoder(this.signDoc);\n    }\n    return this._protoSignDoc;\n  }\n  get aminoSignDoc() {\n    if (this.mode === \"direct\") {\n      throw new Error(\"Sign doc is encoded as Protobuf\");\n    }\n    if (!(\"msgs\" in this.signDoc)) {\n      throw new Error(\"Unexpected error\");\n    }\n    return this.signDoc;\n  }\n  get chainId() {\n    if (this.mode === \"direct\") {\n      return this.protoSignDoc.chainId;\n    }\n    return this.aminoSignDoc.chain_id;\n  }\n  get memo() {\n    if (this.mode === \"direct\") {\n      return this.protoSignDoc.txBody.memo;\n    }\n    return this.aminoSignDoc.memo;\n  }\n  get fees() {\n    var _a, _b;\n    if (this.mode === \"direct\") {\n      const fees = [];\n      for (const coinObj of (_b = (_a = this.protoSignDoc.authInfo.fee) === null || _a === void 0 ? void 0 : _a.amount) !== null && _b !== void 0 ? _b : []) {\n        if (coinObj.denom == null || coinObj.amount == null) {\n          throw new Error(\"Invalid fee\");\n        }\n        fees.push({\n          denom: coinObj.denom,\n          amount: coinObj.amount\n        });\n      }\n      return fees;\n    }\n    return this.aminoSignDoc.fee.amount;\n  }\n  get gas() {\n    var _a, _b, _c;\n    if (this.mode === \"direct\") {\n      return (_c = (_b = (_a = this.protoSignDoc.authInfo.fee) === null || _a === void 0 ? void 0 : _a.gasLimit) === null || _b === void 0 ? void 0 : _b.toNumber()) !== null && _c !== void 0 ? _c : 0;\n    }\n    return parseInt(this.aminoSignDoc.fee.gas);\n  }\n}\nexports.SignDocWrapper = SignDocWrapper;","map":{"version":3,"mappings":";;;;;;AAAA;AAGA;AACA;AAEA,MAAaA,cAAc;EAOzBC,YACqBC,OAA+C;IAA/C,YAAO,GAAPA,OAAO;IAE1B,IAAI,MAAM,IAAIA,OAAO,EAAE;MACrB,IAAI,CAACC,IAAI,GAAG,OAAO;KACpB,MAAM;MACL,IAAI,CAACA,IAAI,GAAG,QAAQ;;IAGtB,IAAI,IAAI,CAACA,IAAI,KAAK,OAAO,EAAE;MACzB;MACA;MACA;MACA,IAAI,CAACC,cAAc,GAAGC,0CAAiC,CACrD,IAAI,CAACC,YAAY,CAClB;KACF,MAAM;MACL;MACA,IAAI,CAACF,cAAc,GAAG,KAAK;;EAE/B;EAEA,OAAOG,gBAAgB,CAACL,OAAmB;IACzC,OAAO,IAAIF,cAAc,CAACE,OAAO,CAAC;EACpC;EAEA,OAAOM,iBAAiB,CAACN,OAAkC;IACzD,OAAO,IAAIF,cAAc,CAACE,OAAO,CAAC;EACpC;EAEA,OAAOO,sBAAsB,CAACC,YAAwB;IACpD,OAAO,IAAIV,cAAc,CAACW,cAAM,CAACC,EAAE,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACL,YAAY,CAAC,CAAC;EAC3E;EAEAM,KAAK;IACH,OAAO,IAAIhB,cAAc,CAAC,IAAI,CAACE,OAAO,CAAC;EACzC;EAEA,IAAIe,YAAY;IACd,IAAI,IAAI,CAACd,IAAI,KAAK,OAAO,EAAE;MACzB,MAAM,IAAIe,KAAK,CAAC,mCAAmC,CAAC;;IAEtD,IAAI,MAAM,IAAI,IAAI,CAAChB,OAAO,EAAE;MAC1B,MAAM,IAAIgB,KAAK,CAAC,kBAAkB,CAAC;;IAGrC,IAAI,CAAC,IAAI,CAACC,aAAa,EAAE;MACvB,IAAI,CAACA,aAAa,GAAG,IAAIC,6BAAmB,CAAC,IAAI,CAAClB,OAAO,CAAC;;IAG5D,OAAO,IAAI,CAACiB,aAAa;EAC3B;EAEA,IAAIb,YAAY;IACd,IAAI,IAAI,CAACH,IAAI,KAAK,QAAQ,EAAE;MAC1B,MAAM,IAAIe,KAAK,CAAC,iCAAiC,CAAC;;IAEpD,IAAI,EAAE,MAAM,IAAI,IAAI,CAAChB,OAAO,CAAC,EAAE;MAC7B,MAAM,IAAIgB,KAAK,CAAC,kBAAkB,CAAC;;IAGrC,OAAO,IAAI,CAAChB,OAAO;EACrB;EAEA,IAAImB,OAAO;IACT,IAAI,IAAI,CAAClB,IAAI,KAAK,QAAQ,EAAE;MAC1B,OAAO,IAAI,CAACc,YAAY,CAACI,OAAO;;IAGlC,OAAO,IAAI,CAACf,YAAY,CAACgB,QAAQ;EACnC;EAEA,IAAIC,IAAI;IACN,IAAI,IAAI,CAACpB,IAAI,KAAK,QAAQ,EAAE;MAC1B,OAAO,IAAI,CAACc,YAAY,CAACO,MAAM,CAACD,IAAI;;IAGtC,OAAO,IAAI,CAACjB,YAAY,CAACiB,IAAI;EAC/B;EAEA,IAAIE,IAAI;;IACN,IAAI,IAAI,CAACtB,IAAI,KAAK,QAAQ,EAAE;MAC1B,MAAMsB,IAAI,GAAW,EAAE;MACvB,KAAK,MAAMC,OAAO,gBAAI,IAAI,CAACT,YAAY,CAACU,QAAQ,CAACC,GAAG,0CAAEC,MAAM,mCAAI,EAAE,EAAE;QAClE,IAAIH,OAAO,CAACI,KAAK,IAAI,IAAI,IAAIJ,OAAO,CAACG,MAAM,IAAI,IAAI,EAAE;UACnD,MAAM,IAAIX,KAAK,CAAC,aAAa,CAAC;;QAEhCO,IAAI,CAACM,IAAI,CAAC;UACRD,KAAK,EAAEJ,OAAO,CAACI,KAAK;UACpBD,MAAM,EAAEH,OAAO,CAACG;SACjB,CAAC;;MAGJ,OAAOJ,IAAI;;IAGb,OAAO,IAAI,CAACnB,YAAY,CAACsB,GAAG,CAACC,MAAM;EACrC;EAEA,IAAIG,GAAG;;IACL,IAAI,IAAI,CAAC7B,IAAI,KAAK,QAAQ,EAAE;MAC1B,yBAAO,IAAI,CAACc,YAAY,CAACU,QAAQ,CAACC,GAAG,0CAAEK,QAAQ,0CAAEC,QAAQ,qCAAM,CAAC;;IAGlE,OAAOC,QAAQ,CAAC,IAAI,CAAC7B,YAAY,CAACsB,GAAG,CAACI,GAAG,CAAC;EAC5C;;AAhHFI","names":["SignDocWrapper","constructor","signDoc","mode","isADR36SignDoc","adr_36_1","aminoSignDoc","fromAminoSignDoc","fromDirectSignDoc","fromDirectSignDocBytes","signDocBytes","proto_1","tx","v1beta1","SignDoc","decode","clone","protoSignDoc","Error","_protoSignDoc","decoder_1","chainId","chain_id","memo","txBody","fees","coinObj","authInfo","fee","amount","denom","push","gas","gasLimit","toNumber","parseInt","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/cosmos/src/stargate/wrapper/index.ts"],"sourcesContent":["import { ProtoSignDocDecoder } from \"../decoder\";\nimport { Coin, StdSignDoc } from \"@cosmjs/launchpad\";\n\nimport { cosmos } from \"../proto\";\nimport { checkAndValidateADR36AminoSignDoc } from \"../../adr-36\";\n\nexport class SignDocWrapper {\n  protected _protoSignDoc?: ProtoSignDocDecoder;\n\n  public readonly isADR36SignDoc: boolean;\n\n  public readonly mode: \"amino\" | \"direct\";\n\n  constructor(\n    protected readonly signDoc: StdSignDoc | cosmos.tx.v1beta1.SignDoc\n  ) {\n    if (\"msgs\" in signDoc) {\n      this.mode = \"amino\";\n    } else {\n      this.mode = \"direct\";\n    }\n\n    if (this.mode === \"amino\") {\n      // Check that the sign doc is for ADR-36.\n      // The validation should be performed on the background process.\n      // So, here, we check once more, but the validation related to bech32 is considered to be done in the background process.\n      this.isADR36SignDoc = checkAndValidateADR36AminoSignDoc(\n        this.aminoSignDoc\n      );\n    } else {\n      // Currently, only support amino sign doc for ADR-36\n      this.isADR36SignDoc = false;\n    }\n  }\n\n  static fromAminoSignDoc(signDoc: StdSignDoc) {\n    return new SignDocWrapper(signDoc);\n  }\n\n  static fromDirectSignDoc(signDoc: cosmos.tx.v1beta1.SignDoc) {\n    return new SignDocWrapper(signDoc);\n  }\n\n  static fromDirectSignDocBytes(signDocBytes: Uint8Array) {\n    return new SignDocWrapper(cosmos.tx.v1beta1.SignDoc.decode(signDocBytes));\n  }\n\n  clone(): SignDocWrapper {\n    return new SignDocWrapper(this.signDoc);\n  }\n\n  get protoSignDoc(): ProtoSignDocDecoder {\n    if (this.mode === \"amino\") {\n      throw new Error(\"Sign doc is encoded as Amino Json\");\n    }\n    if (\"msgs\" in this.signDoc) {\n      throw new Error(\"Unexpected error\");\n    }\n\n    if (!this._protoSignDoc) {\n      this._protoSignDoc = new ProtoSignDocDecoder(this.signDoc);\n    }\n\n    return this._protoSignDoc;\n  }\n\n  get aminoSignDoc(): StdSignDoc {\n    if (this.mode === \"direct\") {\n      throw new Error(\"Sign doc is encoded as Protobuf\");\n    }\n    if (!(\"msgs\" in this.signDoc)) {\n      throw new Error(\"Unexpected error\");\n    }\n\n    return this.signDoc;\n  }\n\n  get chainId(): string {\n    if (this.mode === \"direct\") {\n      return this.protoSignDoc.chainId;\n    }\n\n    return this.aminoSignDoc.chain_id;\n  }\n\n  get memo(): string {\n    if (this.mode === \"direct\") {\n      return this.protoSignDoc.txBody.memo;\n    }\n\n    return this.aminoSignDoc.memo;\n  }\n\n  get fees(): readonly Coin[] {\n    if (this.mode === \"direct\") {\n      const fees: Coin[] = [];\n      for (const coinObj of this.protoSignDoc.authInfo.fee?.amount ?? []) {\n        if (coinObj.denom == null || coinObj.amount == null) {\n          throw new Error(\"Invalid fee\");\n        }\n        fees.push({\n          denom: coinObj.denom,\n          amount: coinObj.amount,\n        });\n      }\n\n      return fees;\n    }\n\n    return this.aminoSignDoc.fee.amount;\n  }\n\n  get gas(): number {\n    if (this.mode === \"direct\") {\n      return this.protoSignDoc.authInfo.fee?.gasLimit?.toNumber() ?? 0;\n    }\n\n    return parseInt(this.aminoSignDoc.fee.gas);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}