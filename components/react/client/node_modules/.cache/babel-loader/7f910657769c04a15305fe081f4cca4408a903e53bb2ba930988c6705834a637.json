{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IBCChannelStore = exports.IBCChannelStoreInner = void 0;\nconst common_1 = require(\"@keplr-wallet/common\");\nconst mobx_1 = require(\"mobx\");\nconst mobx_utils_1 = require(\"mobx-utils\");\nconst common_2 = require(\"../common\");\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nclass IBCChannelStoreInner {\n  constructor(kvStore, chainId) {\n    this.kvStore = kvStore;\n    this.chainId = chainId;\n    // channelMap[portId][channelId]\n    this.channelMap = new Map();\n    this.getChannelsToPort = mobx_utils_1.computedFn(portId => {\n      if (!this.channelMap.has(portId)) {\n        mobx_1.runInAction(() => {\n          this.channelMap.set(portId, mobx_1.observable.map({}, {\n            deep: false\n          }));\n        });\n      }\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const channelMapOfPort = this.channelMap.get(portId);\n      const channels = [];\n      for (const channel of channelMapOfPort.values()) {\n        channels.push(channel);\n      }\n      return channels;\n    });\n    this.getChannel = mobx_utils_1.computedFn((portId, channelId) => {\n      var _a;\n      return (_a = this.channelMap.get(portId)) === null || _a === void 0 ? void 0 : _a.get(channelId);\n    });\n    mobx_1.makeObservable(this);\n    this.loadChannels();\n  }\n  getTransferChannels() {\n    return this.getChannelsToPort(\"transfer\");\n  }\n  *addChannel(channel) {\n    if (!this.channelMap.has(channel.portId)) {\n      this.channelMap.set(channel.portId, mobx_1.observable.map({}, {\n        deep: false\n      }));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.channelMap.get(channel.portId).set(channel.channelId, channel);\n    yield this.saveChannels();\n  }\n  *loadChannels() {\n    const obj = yield* common_1.toGenerator(this.kvStore.get(`${cosmos_1.ChainIdHelper.parse(this.chainId).identifier}-channels`));\n    if (obj) {\n      for (const portId of Object.keys(obj)) {\n        const map = obj[portId];\n        for (const channelId of Object.keys(map)) {\n          if (!this.channelMap.has(portId)) {\n            this.channelMap.set(portId, mobx_1.observable.map({}, {\n              deep: false\n            }));\n          }\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const innerMap = this.channelMap.get(portId);\n          innerMap.set(channelId, map[channelId]);\n        }\n      }\n    }\n  }\n  saveChannels() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const obj = {};\n      this.channelMap.forEach((v, portId) => {\n        obj[portId] = (() => {\n          const obj = {};\n          v.forEach((channel, channelId) => {\n            obj[channelId] = channel;\n          });\n          return obj;\n        })();\n      });\n      yield this.kvStore.set(`${cosmos_1.ChainIdHelper.parse(this.chainId).identifier}-channels`, obj);\n    });\n  }\n}\n__decorate([mobx_1.observable.shallow], IBCChannelStoreInner.prototype, \"channelMap\", void 0);\n__decorate([mobx_1.flow], IBCChannelStoreInner.prototype, \"addChannel\", null);\n__decorate([mobx_1.flow], IBCChannelStoreInner.prototype, \"loadChannels\", null);\nexports.IBCChannelStoreInner = IBCChannelStoreInner;\n/**\n * IBCChannelStore saves the IBC channel infomations to the storage.\n */\nclass IBCChannelStore extends common_2.HasMapStore {\n  constructor(kvStore) {\n    super(chainId => {\n      return new IBCChannelStoreInner(kvStore, chainId);\n    });\n    this.kvStore = kvStore;\n  }\n  get(chainId) {\n    return super.get(chainId);\n  }\n}\nexports.IBCChannelStore = IBCChannelStore;","map":{"version":3,"mappings":"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","names":["IBCChannelStoreInner","constructor","kvStore","chainId","Map","mobx_utils_1","portId","channelMap","has","mobx_1","set","map","deep","channelMapOfPort","get","channels","channel","values","push","channelId","loadChannels","getTransferChannels","getChannelsToPort","addChannel","saveChannels","obj","common_1","cosmos_1","parse","identifier","Object","keys","innerMap","forEach","v","__decorate","shallow","exports","IBCChannelStore","common_2"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/ibc/channel.ts"],"sourcesContent":["import { KVStore, toGenerator } from \"@keplr-wallet/common\";\nimport { flow, makeObservable, observable, runInAction } from \"mobx\";\nimport { computedFn } from \"mobx-utils\";\nimport { Channel } from \"./types\";\nimport { HasMapStore } from \"../common\";\nimport { ChainIdHelper } from \"@keplr-wallet/cosmos\";\n\nexport class IBCChannelStoreInner {\n  // channelMap[portId][channelId]\n  @observable.shallow\n  protected channelMap: Map<string, Map<string, Channel>> = new Map();\n\n  constructor(\n    protected readonly kvStore: KVStore,\n    protected readonly chainId: string\n  ) {\n    makeObservable(this);\n\n    this.loadChannels();\n  }\n\n  getTransferChannels(): Channel[] {\n    return this.getChannelsToPort(\"transfer\");\n  }\n\n  readonly getChannelsToPort = computedFn((portId: string) => {\n    if (!this.channelMap.has(portId)) {\n      runInAction(() => {\n        this.channelMap.set(\n          portId,\n          observable.map(\n            {},\n            {\n              deep: false,\n            }\n          )\n        );\n      });\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const channelMapOfPort = this.channelMap.get(portId)!;\n\n    const channels: Channel[] = [];\n    for (const channel of channelMapOfPort.values()) {\n      channels.push(channel);\n    }\n\n    return channels;\n  });\n\n  readonly getChannel = computedFn((portId: string, channelId: string) => {\n    return this.channelMap.get(portId)?.get(channelId);\n  });\n\n  @flow\n  *addChannel(channel: Channel) {\n    if (!this.channelMap.has(channel.portId)) {\n      this.channelMap.set(\n        channel.portId,\n        observable.map(\n          {},\n          {\n            deep: false,\n          }\n        )\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.channelMap.get(channel.portId)!.set(channel.channelId, channel);\n\n    yield this.saveChannels();\n  }\n\n  @flow\n  protected *loadChannels() {\n    const obj = yield* toGenerator(\n      this.kvStore.get<{\n        [portId: string]: { [channelId: string]: Channel };\n      }>(`${ChainIdHelper.parse(this.chainId).identifier}-channels`)\n    );\n\n    if (obj) {\n      for (const portId of Object.keys(obj)) {\n        const map = obj[portId];\n        for (const channelId of Object.keys(map)) {\n          if (!this.channelMap.has(portId)) {\n            this.channelMap.set(portId, observable.map({}, { deep: false }));\n          }\n\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const innerMap = this.channelMap.get(portId)!;\n          innerMap.set(channelId, map[channelId]);\n        }\n      }\n    }\n  }\n\n  async saveChannels() {\n    const obj: {\n      [portId: string]: { [channelId: string]: Channel };\n    } = {};\n    this.channelMap.forEach((v, portId) => {\n      obj[portId] = (() => {\n        const obj: { [channelId: string]: Channel } = {};\n        v.forEach((channel, channelId) => {\n          obj[channelId] = channel;\n        });\n        return obj;\n      })();\n    });\n\n    await this.kvStore.set(\n      `${ChainIdHelper.parse(this.chainId).identifier}-channels`,\n      obj\n    );\n  }\n}\n\n/**\n * IBCChannelStore saves the IBC channel infomations to the storage.\n */\nexport class IBCChannelStore extends HasMapStore<IBCChannelStoreInner> {\n  constructor(protected readonly kvStore: KVStore) {\n    super((chainId: string) => {\n      return new IBCChannelStoreInner(kvStore, chainId);\n    });\n  }\n\n  get(chainId: string): IBCChannelStoreInner {\n    return super.get(chainId);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}