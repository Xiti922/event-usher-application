{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IBCCurrencyRegsitrar = exports.IBCCurrencyRegsitrarInner = void 0;\nconst mobx_1 = require(\"mobx\");\nconst common_1 = require(\"@keplr-wallet/common\");\nclass IBCCurrencyRegsitrarInner {\n  constructor(kvStore, cacheDuration, chainInfoInner, chainStore, accountStore, queriesStore, cosmwasmQueriesStore, coinDenomGenerator) {\n    this.kvStore = kvStore;\n    this.cacheDuration = cacheDuration;\n    this.chainInfoInner = chainInfoInner;\n    this.chainStore = chainStore;\n    this.accountStore = accountStore;\n    this.queriesStore = queriesStore;\n    this.cosmwasmQueriesStore = cosmwasmQueriesStore;\n    this.coinDenomGenerator = coinDenomGenerator;\n    this.isInitialized = false;\n    this.isInitializing = false;\n    /**\n     * Because the `QueryStore` returns the response from cache first if the last response exists, it takes the IO.\n     * But, if many unknown currencies requested, this make many IO and queries occur at the same time.\n     * This can make the performance issue, so to reduce this problem, use the alternative caching logic\n     * and the denom trace shouldn't be changed in the normal case.\n     * To decrease the number of IO, make sure that reading from storage should happen when the unknown currencies exist\n     * and don't split the data with keys and as posible as combine them to one data structure and key.\n     * @protected\n     */\n    this.cacheDenomTracePaths = new Map();\n    mobx_1.makeObservable(this);\n  }\n  *restoreCache() {\n    this.isInitializing = true;\n    const key = `cache-ibc-denom-trace-paths/${this.chainInfoInner.chainId}`;\n    const obj = yield* common_1.toGenerator(this.kvStore.get(key));\n    if (obj) {\n      for (const key of Object.keys(obj)) {\n        this.cacheDenomTracePaths.set(key, obj[key]);\n      }\n    }\n    this.isInitialized = true;\n    this.isInitializing = false;\n  }\n  getCacheIBCDenomData(denomTraceHash) {\n    const result = this.cacheDenomTracePaths.get(denomTraceHash);\n    if (result && result.timestamp + this.cacheDuration > Date.now()) {\n      return result;\n    }\n  }\n  *setCacheIBCDenomData(denomTraceHash, data) {\n    this.cacheDenomTracePaths.set(denomTraceHash, Object.assign(Object.assign({}, data), {\n      timestamp: Date.now()\n    }));\n    const obj = {};\n    this.cacheDenomTracePaths.forEach((value, key) => {\n      obj[key] = value;\n    });\n    const key = `cache-ibc-denom-trace-paths/${this.chainInfoInner.chainId}`;\n    yield this.kvStore.set(key, obj);\n  }\n  registerUnknownCurrencies(coinMinimalDenom) {\n    const denomHelper = new common_1.DenomHelper(coinMinimalDenom);\n    if (denomHelper.type !== \"native\" || !denomHelper.denom.startsWith(\"ibc/\")) {\n      // IBC Currency's denom should start with \"ibc/\"\n      return;\n    }\n    // When the unknown ibc denom is delivered, try to restore the cache from storage.\n    if (!this.isInitialized) {\n      this.restoreCache();\n    }\n    if (this.isInitializing) {\n      return [undefined, false];\n    }\n    const queries = this.queriesStore.get(this.chainInfoInner.chainId);\n    const hash = denomHelper.denom.replace(\"ibc/\", \"\");\n    const cached = this.getCacheIBCDenomData(hash);\n    let counterpartyChainInfo;\n    let originChainInfo;\n    let denomTrace;\n    if (cached) {\n      denomTrace = cached.denomTrace;\n      if (cached.originChainId && this.chainStore.hasChain(cached.originChainId)) {\n        originChainInfo = this.chainStore.getChain(cached.originChainId);\n      }\n      if (cached.counterpartyChainId && this.chainStore.hasChain(cached.counterpartyChainId)) {\n        counterpartyChainInfo = this.chainStore.getChain(cached.counterpartyChainId);\n      }\n    } else {\n      const queryDenomTrace = queries.cosmos.queryIBCDenomTrace.getDenomTrace(hash);\n      denomTrace = queryDenomTrace.denomTrace;\n      if (denomTrace) {\n        const paths = denomTrace.paths;\n        // The previous chain id from current path.\n        let chainIdBefore = this.chainInfoInner.chainId;\n        for (const path of paths) {\n          const clientState = this.queriesStore.get(chainIdBefore).cosmos.queryIBCClientState.getClientState(path.portId, path.channelId);\n          if (clientState.clientChainId && this.chainStore.hasChain(clientState.clientChainId)) {\n            chainIdBefore = clientState.clientChainId;\n            originChainInfo = this.chainStore.getChain(clientState.clientChainId);\n            if (!counterpartyChainInfo) {\n              counterpartyChainInfo = this.chainStore.getChain(clientState.clientChainId);\n            }\n          } else {\n            originChainInfo = undefined;\n            break;\n          }\n        }\n        if (originChainInfo) {\n          this.setCacheIBCDenomData(hash, {\n            counterpartyChainId: counterpartyChainInfo === null || counterpartyChainInfo === void 0 ? void 0 : counterpartyChainInfo.chainId,\n            denomTrace,\n            originChainId: originChainInfo.chainId\n          });\n        }\n      }\n    }\n    if (originChainInfo && denomTrace) {\n      if (denomTrace.denom.split(/^(cw20):(\\w+)$/).length === 4) {\n        // If the origin currency is ics20-cw20.\n        let cw20Currency = originChainInfo.currencies.find(cur => denomTrace && cur.coinMinimalDenom.startsWith(denomTrace.denom));\n        if (!cw20Currency && this.cosmwasmQueriesStore) {\n          const cosmwasmQuries = this.cosmwasmQueriesStore.get(originChainInfo.chainId);\n          const contractAddress = denomTrace.denom.replace(\"cw20:\", \"\");\n          const contractInfo = cosmwasmQuries.cosmwasm.querycw20ContractInfo.getQueryContract(contractAddress);\n          if (contractInfo.response) {\n            cw20Currency = {\n              type: \"cw20\",\n              contractAddress,\n              coinDecimals: contractInfo.response.data.decimals,\n              coinDenom: contractInfo.response.data.symbol,\n              coinMinimalDenom: `cw20:${contractAddress}:${contractInfo.response.data.name}`\n            };\n            originChainInfo.addCurrencies(cw20Currency);\n          }\n        }\n        if (cw20Currency) {\n          return [{\n            coinDecimals: cw20Currency.coinDecimals,\n            coinGeckoId: cw20Currency.coinGeckoId,\n            coinImageUrl: cw20Currency.coinImageUrl,\n            coinMinimalDenom: denomHelper.denom,\n            coinDenom: this.coinDenomGenerator(denomTrace, originChainInfo, counterpartyChainInfo, cw20Currency),\n            paths: denomTrace.paths,\n            originChainId: originChainInfo.chainId,\n            originCurrency: cw20Currency\n          }, true];\n        }\n      } else {\n        const currency = originChainInfo.findCurrency(denomTrace.denom);\n        if (currency && !(\"paths\" in currency)) {\n          return [{\n            coinDecimals: currency.coinDecimals,\n            coinGeckoId: currency.coinGeckoId,\n            coinImageUrl: currency.coinImageUrl,\n            coinMinimalDenom: denomHelper.denom,\n            coinDenom: this.coinDenomGenerator(denomTrace, originChainInfo, counterpartyChainInfo, currency),\n            paths: denomTrace.paths,\n            originChainId: originChainInfo.chainId,\n            originCurrency: currency\n          }, true];\n        }\n      }\n      // In this case, just show the raw currency.\n      // But, it is possible to know the currency from query later.\n      // So, let them to be observed.\n      return [{\n        coinDecimals: 0,\n        coinMinimalDenom: denomHelper.denom,\n        coinDenom: this.coinDenomGenerator(denomTrace, originChainInfo, counterpartyChainInfo, undefined),\n        paths: denomTrace.paths,\n        originChainId: undefined,\n        originCurrency: undefined\n      }, false];\n    }\n    return [undefined, false];\n  }\n}\n__decorate([mobx_1.observable], IBCCurrencyRegsitrarInner.prototype, \"isInitialized\", void 0);\n__decorate([mobx_1.observable], IBCCurrencyRegsitrarInner.prototype, \"isInitializing\", void 0);\n__decorate([mobx_1.observable.shallow], IBCCurrencyRegsitrarInner.prototype, \"cacheDenomTracePaths\", void 0);\n__decorate([mobx_1.flow], IBCCurrencyRegsitrarInner.prototype, \"restoreCache\", null);\n__decorate([mobx_1.flow], IBCCurrencyRegsitrarInner.prototype, \"setCacheIBCDenomData\", null);\nexports.IBCCurrencyRegsitrarInner = IBCCurrencyRegsitrarInner;\n/**\n * IBCCurrencyRegsitrar gets the native balances that exist on the chain itself (ex. atom, scrt...)\n * And, IBCCurrencyRegsitrar registers the currencies from IBC to the chain info.\n * In cosmos-sdk, the denomination of IBC token has the form of \"ibc/{hash}\".\n * And, its paths can be found by getting the denom trace from the node.\n * If the native balance querier's response have the token that is form of IBC token,\n * this will try to get the denom info by traversing the paths, and register the currency with the decimal and denom info.\n * But, if failed to traverse the paths, this will register the currency with 0 decimal and the minimal denom even though it is not suitable for human.\n */\nclass IBCCurrencyRegsitrar {\n  constructor(kvStore) {\n    let cacheDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24 * 3600 * 1000;\n    let\n    // 1 days\n    chainStore = arguments.length > 2 ? arguments[2] : undefined;\n    let accountStore = arguments.length > 3 ? arguments[3] : undefined;\n    let queriesStore = arguments.length > 4 ? arguments[4] : undefined;\n    let cosmwasmQueriesStore = arguments.length > 5 ? arguments[5] : undefined;\n    let coinDenomGenerator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : IBCCurrencyRegsitrar.defaultCoinDenomGenerator;\n    this.kvStore = kvStore;\n    this.cacheDuration = cacheDuration;\n    this.chainStore = chainStore;\n    this.accountStore = accountStore;\n    this.queriesStore = queriesStore;\n    this.cosmwasmQueriesStore = cosmwasmQueriesStore;\n    this.coinDenomGenerator = coinDenomGenerator;\n    this.map = new Map();\n    this.chainStore.addSetChainInfoHandler(chainInfoInner => this.setChainInfoHandler(chainInfoInner));\n  }\n  static defaultCoinDenomGenerator(denomTrace, _, counterpartyChainInfo, originCurrency) {\n    if (originCurrency) {\n      return `${originCurrency.coinDenom} (${counterpartyChainInfo ? counterpartyChainInfo.chainName : \"Unknown\"}/${denomTrace.paths[0].channelId})`;\n    } else {\n      return `${denomTrace.denom} (${counterpartyChainInfo ? counterpartyChainInfo.chainName : \"Unknown\"}/${denomTrace.paths[0].channelId})`;\n    }\n  }\n  setChainInfoHandler(chainInfoInner) {\n    const inner = this.get(chainInfoInner);\n    chainInfoInner.registerCurrencyRegistrar(coinMinimalDenom => inner.registerUnknownCurrencies(coinMinimalDenom));\n  }\n  get(chainInfoInner) {\n    if (!this.map.has(chainInfoInner.chainId)) {\n      mobx_1.runInAction(() => {\n        this.map.set(chainInfoInner.chainId, new IBCCurrencyRegsitrarInner(this.kvStore, this.cacheDuration, chainInfoInner, this.chainStore, this.accountStore, this.queriesStore, this.cosmwasmQueriesStore, this.coinDenomGenerator));\n      });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.map.get(chainInfoInner.chainId);\n  }\n}\n__decorate([mobx_1.observable.shallow], IBCCurrencyRegsitrar.prototype, \"map\", void 0);\nexports.IBCCurrencyRegsitrar = IBCCurrencyRegsitrar;","map":{"version":3,"mappings":"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","names":["IBCCurrencyRegsitrarInner","constructor","kvStore","cacheDuration","chainInfoInner","chainStore","accountStore","queriesStore","cosmwasmQueriesStore","coinDenomGenerator","Map","mobx_1","restoreCache","isInitializing","key","chainId","obj","common_1","get","Object","keys","cacheDenomTracePaths","set","isInitialized","getCacheIBCDenomData","denomTraceHash","result","timestamp","Date","now","setCacheIBCDenomData","data","forEach","value","registerUnknownCurrencies","coinMinimalDenom","denomHelper","type","denom","startsWith","undefined","queries","hash","replace","cached","counterpartyChainInfo","originChainInfo","denomTrace","originChainId","hasChain","getChain","counterpartyChainId","queryDenomTrace","cosmos","queryIBCDenomTrace","getDenomTrace","paths","chainIdBefore","path","clientState","queryIBCClientState","getClientState","portId","channelId","clientChainId","split","length","cw20Currency","currencies","find","cur","cosmwasmQuries","contractAddress","contractInfo","cosmwasm","querycw20ContractInfo","getQueryContract","response","coinDecimals","decimals","coinDenom","symbol","name","addCurrencies","coinGeckoId","coinImageUrl","originCurrency","currency","findCurrency","__decorate","shallow","exports","IBCCurrencyRegsitrar","defaultCoinDenomGenerator","addSetChainInfoHandler","setChainInfoHandler","_","chainName","inner","registerCurrencyRegistrar","map","has"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/ibc/currency-registrar.ts"],"sourcesContent":["import { flow, makeObservable, observable, runInAction } from \"mobx\";\nimport { AppCurrency, ChainInfo } from \"@keplr-wallet/types\";\nimport { ChainInfoInner, ChainStore } from \"../chain\";\nimport {\n  CosmosQueries,\n  CosmwasmQueries,\n  IQueriesStore,\n  QueriesSetBase,\n} from \"../query\";\nimport { DenomHelper, KVStore, toGenerator } from \"@keplr-wallet/common\";\n\ntype CacheIBCDenomData = {\n  denomTrace: {\n    denom: string;\n    paths: {\n      portId: string;\n      channelId: string;\n    }[];\n  };\n  originChainId: string | undefined;\n  counterpartyChainId: string | undefined;\n};\n\nexport class IBCCurrencyRegsitrarInner<C extends ChainInfo = ChainInfo> {\n  @observable\n  protected isInitialized = false;\n  @observable\n  protected isInitializing = false;\n\n  /**\n   * Because the `QueryStore` returns the response from cache first if the last response exists, it takes the IO.\n   * But, if many unknown currencies requested, this make many IO and queries occur at the same time.\n   * This can make the performance issue, so to reduce this problem, use the alternative caching logic\n   * and the denom trace shouldn't be changed in the normal case.\n   * To decrease the number of IO, make sure that reading from storage should happen when the unknown currencies exist\n   * and don't split the data with keys and as posible as combine them to one data structure and key.\n   * @protected\n   */\n  @observable.shallow\n  protected cacheDenomTracePaths: Map<\n    string,\n    CacheIBCDenomData & { timestamp: number }\n  > = new Map();\n\n  constructor(\n    protected readonly kvStore: KVStore,\n    protected readonly cacheDuration: number,\n    protected readonly chainInfoInner: ChainInfoInner<C>,\n    protected readonly chainStore: ChainStore<C>,\n    protected readonly accountStore: {\n      hasAccount(chainId: string): boolean;\n      getAccount(\n        chainId: string\n      ): {\n        bech32Address: string;\n      };\n    },\n    protected readonly queriesStore: IQueriesStore<CosmosQueries>,\n    protected readonly cosmwasmQueriesStore:\n      | IQueriesStore<CosmwasmQueries>\n      | undefined,\n    protected readonly coinDenomGenerator: (\n      denomTrace: {\n        denom: string;\n        paths: {\n          portId: string;\n          channelId: string;\n        }[];\n      },\n      originChainInfo: ChainInfoInner | undefined,\n      counterpartyChainInfo: ChainInfoInner | undefined,\n      originCurrency: AppCurrency | undefined\n    ) => string\n  ) {\n    makeObservable(this);\n  }\n\n  @flow\n  protected *restoreCache() {\n    this.isInitializing = true;\n\n    const key = `cache-ibc-denom-trace-paths/${this.chainInfoInner.chainId}`;\n    const obj = yield* toGenerator(\n      this.kvStore.get<\n        Record<string, CacheIBCDenomData & { timestamp: number }>\n      >(key)\n    );\n\n    if (obj) {\n      for (const key of Object.keys(obj)) {\n        this.cacheDenomTracePaths.set(key, obj[key]);\n      }\n    }\n\n    this.isInitialized = true;\n    this.isInitializing = false;\n  }\n\n  protected getCacheIBCDenomData(\n    denomTraceHash: string\n  ): CacheIBCDenomData | undefined {\n    const result = this.cacheDenomTracePaths.get(denomTraceHash);\n    if (result && result.timestamp + this.cacheDuration > Date.now()) {\n      return result;\n    }\n  }\n\n  @flow\n  protected *setCacheIBCDenomData(\n    denomTraceHash: string,\n    data: CacheIBCDenomData\n  ) {\n    this.cacheDenomTracePaths.set(denomTraceHash, {\n      ...data,\n      timestamp: Date.now(),\n    });\n\n    const obj: Record<string, CacheIBCDenomData> = {};\n\n    this.cacheDenomTracePaths.forEach((value, key) => {\n      obj[key] = value;\n    });\n\n    const key = `cache-ibc-denom-trace-paths/${this.chainInfoInner.chainId}`;\n    yield this.kvStore.set(key, obj);\n  }\n\n  registerUnknownCurrencies(\n    coinMinimalDenom: string\n  ): [AppCurrency | undefined, boolean] | undefined {\n    const denomHelper = new DenomHelper(coinMinimalDenom);\n    if (\n      denomHelper.type !== \"native\" ||\n      !denomHelper.denom.startsWith(\"ibc/\")\n    ) {\n      // IBC Currency's denom should start with \"ibc/\"\n      return;\n    }\n\n    // When the unknown ibc denom is delivered, try to restore the cache from storage.\n    if (!this.isInitialized) {\n      this.restoreCache();\n    }\n\n    if (this.isInitializing) {\n      return [undefined, false];\n    }\n\n    const queries = this.queriesStore.get(this.chainInfoInner.chainId);\n\n    const hash = denomHelper.denom.replace(\"ibc/\", \"\");\n\n    const cached = this.getCacheIBCDenomData(hash);\n\n    let counterpartyChainInfo: ChainInfoInner | undefined;\n    let originChainInfo: ChainInfoInner | undefined;\n    let denomTrace:\n      | {\n          denom: string;\n          paths: {\n            portId: string;\n            channelId: string;\n          }[];\n        }\n      | undefined;\n\n    if (cached) {\n      denomTrace = cached.denomTrace;\n      if (\n        cached.originChainId &&\n        this.chainStore.hasChain(cached.originChainId)\n      ) {\n        originChainInfo = this.chainStore.getChain(cached.originChainId);\n      }\n      if (\n        cached.counterpartyChainId &&\n        this.chainStore.hasChain(cached.counterpartyChainId)\n      ) {\n        counterpartyChainInfo = this.chainStore.getChain(\n          cached.counterpartyChainId\n        );\n      }\n    } else {\n      const queryDenomTrace = queries.cosmos.queryIBCDenomTrace.getDenomTrace(\n        hash\n      );\n      denomTrace = queryDenomTrace.denomTrace;\n\n      if (denomTrace) {\n        const paths = denomTrace.paths;\n        // The previous chain id from current path.\n        let chainIdBefore = this.chainInfoInner.chainId;\n        for (const path of paths) {\n          const clientState = this.queriesStore\n            .get(chainIdBefore)\n            .cosmos.queryIBCClientState.getClientState(\n              path.portId,\n              path.channelId\n            );\n\n          if (\n            clientState.clientChainId &&\n            this.chainStore.hasChain(clientState.clientChainId)\n          ) {\n            chainIdBefore = clientState.clientChainId;\n            originChainInfo = this.chainStore.getChain(\n              clientState.clientChainId\n            );\n            if (!counterpartyChainInfo) {\n              counterpartyChainInfo = this.chainStore.getChain(\n                clientState.clientChainId\n              );\n            }\n          } else {\n            originChainInfo = undefined;\n            break;\n          }\n        }\n\n        if (originChainInfo) {\n          this.setCacheIBCDenomData(hash, {\n            counterpartyChainId: counterpartyChainInfo?.chainId,\n            denomTrace,\n            originChainId: originChainInfo.chainId,\n          });\n        }\n      }\n    }\n\n    if (originChainInfo && denomTrace) {\n      if (denomTrace.denom.split(/^(cw20):(\\w+)$/).length === 4) {\n        // If the origin currency is ics20-cw20.\n        let cw20Currency = originChainInfo.currencies.find(\n          (cur) =>\n            denomTrace && cur.coinMinimalDenom.startsWith(denomTrace.denom)\n        );\n        if (!cw20Currency && this.cosmwasmQueriesStore) {\n          const cosmwasmQuries = this.cosmwasmQueriesStore.get(\n            originChainInfo.chainId\n          );\n          const contractAddress = denomTrace.denom.replace(\"cw20:\", \"\");\n          const contractInfo = cosmwasmQuries.cosmwasm.querycw20ContractInfo.getQueryContract(\n            contractAddress\n          );\n          if (contractInfo.response) {\n            cw20Currency = {\n              type: \"cw20\",\n              contractAddress,\n              coinDecimals: contractInfo.response.data.decimals,\n              coinDenom: contractInfo.response.data.symbol,\n              coinMinimalDenom: `cw20:${contractAddress}:${contractInfo.response.data.name}`,\n            };\n            originChainInfo.addCurrencies(cw20Currency);\n          }\n        }\n\n        if (cw20Currency) {\n          return [\n            {\n              coinDecimals: cw20Currency.coinDecimals,\n              coinGeckoId: cw20Currency.coinGeckoId,\n              coinImageUrl: cw20Currency.coinImageUrl,\n              coinMinimalDenom: denomHelper.denom,\n              coinDenom: this.coinDenomGenerator(\n                denomTrace,\n                originChainInfo,\n                counterpartyChainInfo,\n                cw20Currency\n              ),\n              paths: denomTrace.paths,\n              originChainId: originChainInfo.chainId,\n              originCurrency: cw20Currency,\n            },\n            true,\n          ];\n        }\n      } else {\n        const currency = originChainInfo.findCurrency(denomTrace.denom);\n\n        if (currency && !(\"paths\" in currency)) {\n          return [\n            {\n              coinDecimals: currency.coinDecimals,\n              coinGeckoId: currency.coinGeckoId,\n              coinImageUrl: currency.coinImageUrl,\n              coinMinimalDenom: denomHelper.denom,\n              coinDenom: this.coinDenomGenerator(\n                denomTrace,\n                originChainInfo,\n                counterpartyChainInfo,\n                currency\n              ),\n              paths: denomTrace.paths,\n              originChainId: originChainInfo.chainId,\n              originCurrency: currency,\n            },\n            true,\n          ];\n        }\n      }\n\n      // In this case, just show the raw currency.\n      // But, it is possible to know the currency from query later.\n      // So, let them to be observed.\n      return [\n        {\n          coinDecimals: 0,\n          coinMinimalDenom: denomHelper.denom,\n          coinDenom: this.coinDenomGenerator(\n            denomTrace,\n            originChainInfo,\n            counterpartyChainInfo,\n            undefined\n          ),\n          paths: denomTrace.paths,\n          originChainId: undefined,\n          originCurrency: undefined,\n        },\n        false,\n      ];\n    }\n\n    return [undefined, false];\n  }\n}\n\n/**\n * IBCCurrencyRegsitrar gets the native balances that exist on the chain itself (ex. atom, scrt...)\n * And, IBCCurrencyRegsitrar registers the currencies from IBC to the chain info.\n * In cosmos-sdk, the denomination of IBC token has the form of \"ibc/{hash}\".\n * And, its paths can be found by getting the denom trace from the node.\n * If the native balance querier's response have the token that is form of IBC token,\n * this will try to get the denom info by traversing the paths, and register the currency with the decimal and denom info.\n * But, if failed to traverse the paths, this will register the currency with 0 decimal and the minimal denom even though it is not suitable for human.\n */\nexport class IBCCurrencyRegsitrar<C extends ChainInfo = ChainInfo> {\n  @observable.shallow\n  protected map: Map<string, IBCCurrencyRegsitrarInner<C>> = new Map();\n\n  static defaultCoinDenomGenerator(\n    denomTrace: {\n      denom: string;\n      paths: {\n        portId: string;\n        channelId: string;\n      }[];\n    },\n    _: ChainInfoInner | undefined,\n    counterpartyChainInfo: ChainInfoInner | undefined,\n    originCurrency: AppCurrency | undefined\n  ): string {\n    if (originCurrency) {\n      return `${originCurrency.coinDenom} (${\n        counterpartyChainInfo ? counterpartyChainInfo.chainName : \"Unknown\"\n      }/${denomTrace.paths[0].channelId})`;\n    } else {\n      return `${denomTrace.denom} (${\n        counterpartyChainInfo ? counterpartyChainInfo.chainName : \"Unknown\"\n      }/${denomTrace.paths[0].channelId})`;\n    }\n  }\n\n  constructor(\n    protected readonly kvStore: KVStore,\n    protected readonly cacheDuration: number = 24 * 3600 * 1000, // 1 days\n    protected readonly chainStore: ChainStore<C>,\n    protected readonly accountStore: {\n      hasAccount(chainId: string): boolean;\n      getAccount(\n        chainId: string\n      ): {\n        bech32Address: string;\n      };\n    },\n    protected readonly queriesStore: {\n      get(chainId: string): QueriesSetBase & CosmosQueries;\n    },\n    protected readonly cosmwasmQueriesStore:\n      | {\n          get(chainId: string): QueriesSetBase & CosmwasmQueries;\n        }\n      | undefined,\n    protected readonly coinDenomGenerator: (\n      denomTrace: {\n        denom: string;\n        paths: {\n          portId: string;\n          channelId: string;\n        }[];\n      },\n      originChainInfo: ChainInfoInner | undefined,\n      counterpartyChainInfo: ChainInfoInner | undefined,\n      originCurrency: AppCurrency | undefined\n    ) => string = IBCCurrencyRegsitrar.defaultCoinDenomGenerator\n  ) {\n    this.chainStore.addSetChainInfoHandler((chainInfoInner) =>\n      this.setChainInfoHandler(chainInfoInner)\n    );\n  }\n\n  setChainInfoHandler(chainInfoInner: ChainInfoInner<C>): void {\n    const inner = this.get(chainInfoInner);\n    chainInfoInner.registerCurrencyRegistrar((coinMinimalDenom) =>\n      inner.registerUnknownCurrencies(coinMinimalDenom)\n    );\n  }\n\n  protected get(\n    chainInfoInner: ChainInfoInner<C>\n  ): IBCCurrencyRegsitrarInner<C> {\n    if (!this.map.has(chainInfoInner.chainId)) {\n      runInAction(() => {\n        this.map.set(\n          chainInfoInner.chainId,\n          new IBCCurrencyRegsitrarInner<C>(\n            this.kvStore,\n            this.cacheDuration,\n            chainInfoInner,\n            this.chainStore,\n            this.accountStore,\n            this.queriesStore,\n            this.cosmwasmQueriesStore,\n            this.coinDenomGenerator\n          )\n        );\n      });\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.map.get(chainInfoInner.chainId)!;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}