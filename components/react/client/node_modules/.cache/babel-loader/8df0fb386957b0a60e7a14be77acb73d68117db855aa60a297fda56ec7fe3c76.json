{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findSequenceForSignedTx = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"./encoding\");\nconst signature_1 = require(\"./signature\");\n/**\n * Serach for sequence s with `min` <= `s` < `upperBound` to find the sequence that was used to sign the transaction\n *\n * @param tx The signed transaction\n * @param chainId The chain ID for which this transaction was signed\n * @param accountNumber The account number for which this transaction was signed\n * @param upperBound The upper bound for the testing, i.e. sequence must be lower than this value\n * @param min The lowest sequence that is tested\n *\n * @returns the sequence if a match was found and undefined otherwise\n */\nasync function findSequenceForSignedTx(tx, chainId, accountNumber, upperBound) {\n  let min = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  const firstSignature = tx.value.signatures.find(() => true);\n  if (!firstSignature) throw new Error(\"Signature missing in tx\");\n  const {\n    pubkey,\n    signature\n  } = signature_1.decodeSignature(firstSignature);\n  const secp256keSignature = crypto_1.Secp256k1Signature.fromFixedLength(signature);\n  for (let s = min; s < upperBound; s++) {\n    // console.log(`Trying sequence ${s}`);\n    const signBytes = encoding_1.serializeSignDoc(encoding_1.makeSignDoc(tx.value.msg, tx.value.fee, chainId, tx.value.memo || \"\", accountNumber, s));\n    const prehashed = crypto_1.sha256(signBytes);\n    const valid = await crypto_1.Secp256k1.verifySignature(secp256keSignature, prehashed, pubkey);\n    if (valid) return s;\n  }\n  return undefined;\n}\nexports.findSequenceForSignedTx = findSequenceForSignedTx;","map":{"version":3,"mappings":";;;;;;AAAA;AAEA;AACA;AAGA;;;;;;;;;;;AAWO,eAAeA,uBAAuB,CAC3CC,EAAgB,EAChBC,OAAe,EACfC,aAAqB,EACrBC,UAAkB,EACX;EAAA,IAAPC,GAAG,uEAAG,CAAC;EAEP,MAAMC,cAAc,GAAGL,EAAE,CAACM,KAAK,CAACC,UAAU,CAACC,IAAI,CAAC,MAAM,IAAI,CAAC;EAC3D,IAAI,CAACH,cAAc,EAAE,MAAM,IAAII,KAAK,CAAC,yBAAyB,CAAC;EAE/D,MAAM;IAAEC,MAAM;IAAEC;EAAS,CAAE,GAAGC,2BAAe,CAACP,cAAc,CAAC;EAC7D,MAAMQ,kBAAkB,GAAGC,2BAAkB,CAACC,eAAe,CAACJ,SAAS,CAAC;EAExE,KAAK,IAAIK,CAAC,GAAGZ,GAAG,EAAEY,CAAC,GAAGb,UAAU,EAAEa,CAAC,EAAE,EAAE;IACrC;IACA,MAAMC,SAAS,GAAGC,2BAAgB,CAChCA,sBAAW,CAAClB,EAAE,CAACM,KAAK,CAACa,GAAG,EAAEnB,EAAE,CAACM,KAAK,CAACc,GAAG,EAAEnB,OAAO,EAAED,EAAE,CAACM,KAAK,CAACe,IAAI,IAAI,EAAE,EAAEnB,aAAa,EAAEc,CAAC,CAAC,CACxF;IACD,MAAMM,SAAS,GAAGR,eAAM,CAACG,SAAS,CAAC;IACnC,MAAMM,KAAK,GAAG,MAAMT,kBAAS,CAACU,eAAe,CAACX,kBAAkB,EAAES,SAAS,EAAEZ,MAAM,CAAC;IACpF,IAAIa,KAAK,EAAE,OAAOP,CAAC;;EAErB,OAAOS,SAAS;AAClB;AAvBAC","names":["findSequenceForSignedTx","tx","chainId","accountNumber","upperBound","min","firstSignature","value","signatures","find","Error","pubkey","signature","signature_1","secp256keSignature","crypto_1","fromFixedLength","s","signBytes","encoding_1","msg","fee","memo","prehashed","valid","verifySignature","undefined","exports"],"sources":["../src/sequence.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}