{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableQuerySecret20BalanceRegistry = exports.ObservableQuerySecret20BalanceInner = exports.ObservableQuerySecret20Balance = void 0;\nconst mobx_1 = require(\"mobx\");\nconst common_1 = require(\"@keplr-wallet/common\");\nconst unit_1 = require(\"@keplr-wallet/unit\");\nconst balances_1 = require(\"../balances\");\nconst contract_query_1 = require(\"./contract-query\");\nconst errors_1 = require(\"./errors\");\nclass ObservableQuerySecret20Balance extends contract_query_1.ObservableSecretContractChainQuery {\n  constructor(kvStore, chainId, chainGetter, apiGetter, contractAddress, bech32Address, viewingKey, querySecretContractCodeHash) {\n    super(kvStore, chainId, chainGetter, apiGetter, contractAddress, {\n      balance: {\n        address: bech32Address,\n        key: viewingKey\n      }\n    }, querySecretContractCodeHash);\n    this.apiGetter = apiGetter;\n    this.contractAddress = contractAddress;\n    this.bech32Address = bech32Address;\n    this.viewingKey = viewingKey;\n    this.querySecretContractCodeHash = querySecretContractCodeHash;\n    mobx_1.makeObservable(this);\n    if (!this.viewingKey) {\n      this.setError({\n        status: 0,\n        statusText: \"Viewing key is empty\",\n        message: \"Viewing key is empty\"\n      });\n    }\n  }\n  canFetch() {\n    return super.canFetch() && this.bech32Address !== \"\" && this.viewingKey !== \"\";\n  }\n  fetchResponse(abortController) {\n    const _super = Object.create(null, {\n      fetchResponse: {\n        get: () => super.fetchResponse\n      }\n    });\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        response,\n        headers\n      } = yield _super.fetchResponse.call(this, abortController);\n      if (response.data[\"viewing_key_error\"]) {\n        throw new errors_1.WrongViewingKeyError((_a = response.data[\"viewing_key_error\"]) === null || _a === void 0 ? void 0 : _a.msg);\n      }\n      return {\n        headers,\n        response\n      };\n    });\n  }\n}\nexports.ObservableQuerySecret20Balance = ObservableQuerySecret20Balance;\nclass ObservableQuerySecret20BalanceInner extends balances_1.ObservableQueryBalanceInner {\n  constructor(kvStore, chainId, chainGetter, apiGetter, denomHelper, bech32Address, querySecretContractCodeHash) {\n    super(kvStore, chainId, chainGetter,\n    // No need to set the url at initial.\n    \"\", denomHelper);\n    this.apiGetter = apiGetter;\n    this.bech32Address = bech32Address;\n    this.querySecretContractCodeHash = querySecretContractCodeHash;\n    mobx_1.makeObservable(this);\n    const viewingKey = (() => {\n      const currency = this.currency;\n      if (\"type\" in currency && currency.type === \"secret20\") {\n        return currency.viewingKey;\n      }\n      return \"\";\n    })();\n    this.querySecret20Balance = new ObservableQuerySecret20Balance(kvStore, chainId, chainGetter, this.apiGetter, denomHelper.contractAddress, bech32Address, viewingKey, this.querySecretContractCodeHash);\n  }\n  // This method doesn't have the role because the fetching is actually exeucnted in the `ObservableQuerySecret20Balance`.\n  canFetch() {\n    return false;\n  }\n  *fetch() {\n    yield this.querySecret20Balance.fetch();\n  }\n  get isFetching() {\n    return this.querySecretContractCodeHash.getQueryContract(this.denomHelper.contractAddress).isFetching || this.querySecret20Balance.isFetching;\n  }\n  get error() {\n    return this.querySecretContractCodeHash.getQueryContract(this.denomHelper.contractAddress).error || this.querySecret20Balance.error;\n  }\n  get balance() {\n    const denom = this.denomHelper.denom;\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    const currency = chainInfo.findCurrency(denom);\n    // TODO: Infer the currency according to its denom (such if denom is `uatom` -> `Atom` with decimal 6)?\n    if (!currency) {\n      throw new Error(`Unknown currency: ${denom}`);\n    }\n    if (!this.querySecret20Balance.response || !this.querySecret20Balance.response.data.balance) {\n      return new unit_1.CoinPretty(currency, new unit_1.Int(0)).ready(false);\n    }\n    return new unit_1.CoinPretty(currency, new unit_1.Int(this.querySecret20Balance.response.data.balance.amount));\n  }\n}\n__decorate([mobx_1.override], ObservableQuerySecret20BalanceInner.prototype, \"fetch\", null);\n__decorate([mobx_1.computed], ObservableQuerySecret20BalanceInner.prototype, \"balance\", null);\nexports.ObservableQuerySecret20BalanceInner = ObservableQuerySecret20BalanceInner;\nclass ObservableQuerySecret20BalanceRegistry {\n  constructor(kvStore, apiGetter, querySecretContractCodeHash) {\n    this.kvStore = kvStore;\n    this.apiGetter = apiGetter;\n    this.querySecretContractCodeHash = querySecretContractCodeHash;\n  }\n  getBalanceInner(chainId, chainGetter, bech32Address, minimalDenom) {\n    const denomHelper = new common_1.DenomHelper(minimalDenom);\n    if (denomHelper.type === \"secret20\") {\n      return new ObservableQuerySecret20BalanceInner(this.kvStore, chainId, chainGetter, this.apiGetter, denomHelper, bech32Address, this.querySecretContractCodeHash);\n    }\n  }\n}\nexports.ObservableQuerySecret20BalanceRegistry = ObservableQuerySecret20BalanceRegistry;","map":{"version":3,"mappings":"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","names":["ObservableQuerySecret20Balance","contract_query_1","constructor","kvStore","chainId","chainGetter","apiGetter","contractAddress","bech32Address","viewingKey","querySecretContractCodeHash","balance","address","key","mobx_1","setError","status","statusText","message","canFetch","fetchResponse","abortController","response","headers","_super","data","errors_1","msg","exports","ObservableQuerySecret20BalanceInner","balances_1","denomHelper","currency","type","querySecret20Balance","fetch","isFetching","getQueryContract","error","denom","chainInfo","getChain","findCurrency","Error","unit_1","ready","amount","__decorate","ObservableQuerySecret20BalanceRegistry","getBalanceInner","minimalDenom","common_1"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/query/secret-wasm/secret20-balance.ts"],"sourcesContent":["import { computed, makeObservable, override } from \"mobx\";\nimport { DenomHelper, KVStore } from \"@keplr-wallet/common\";\nimport { ChainGetter, QueryResponse } from \"../../common\";\nimport { ObservableQuerySecretContractCodeHash } from \"./contract-hash\";\nimport { QueryError } from \"../../common\";\nimport { CoinPretty, Int } from \"@keplr-wallet/unit\";\nimport { BalanceRegistry, ObservableQueryBalanceInner } from \"../balances\";\nimport { ObservableSecretContractChainQuery } from \"./contract-query\";\nimport { WrongViewingKeyError } from \"./errors\";\nimport { Keplr } from \"@keplr-wallet/types\";\n\nexport class ObservableQuerySecret20Balance extends ObservableSecretContractChainQuery<{\n  balance: { amount: string };\n  [\"viewing_key_error\"]?: {\n    msg: string;\n  };\n}> {\n  constructor(\n    kvStore: KVStore,\n    chainId: string,\n    chainGetter: ChainGetter,\n    protected readonly apiGetter: () => Promise<Keplr | undefined>,\n    protected readonly contractAddress: string,\n    protected readonly bech32Address: string,\n    protected readonly viewingKey: string,\n    protected readonly querySecretContractCodeHash: ObservableQuerySecretContractCodeHash\n  ) {\n    super(\n      kvStore,\n      chainId,\n      chainGetter,\n      apiGetter,\n      contractAddress,\n      {\n        balance: { address: bech32Address, key: viewingKey },\n      },\n      querySecretContractCodeHash\n    );\n\n    makeObservable(this);\n\n    if (!this.viewingKey) {\n      this.setError({\n        status: 0,\n        statusText: \"Viewing key is empty\",\n        message: \"Viewing key is empty\",\n      });\n    }\n  }\n\n  protected canFetch(): boolean {\n    return (\n      super.canFetch() && this.bech32Address !== \"\" && this.viewingKey !== \"\"\n    );\n  }\n\n  protected async fetchResponse(\n    abortController: AbortController\n  ): Promise<{\n    response: QueryResponse<{ balance: { amount: string } }>;\n    headers: any;\n  }> {\n    const { response, headers } = await super.fetchResponse(abortController);\n\n    if (response.data[\"viewing_key_error\"]) {\n      throw new WrongViewingKeyError(response.data[\"viewing_key_error\"]?.msg);\n    }\n\n    return {\n      headers,\n      response,\n    };\n  }\n}\n\nexport class ObservableQuerySecret20BalanceInner extends ObservableQueryBalanceInner {\n  protected readonly querySecret20Balance: ObservableQuerySecret20Balance;\n\n  constructor(\n    kvStore: KVStore,\n    chainId: string,\n    chainGetter: ChainGetter,\n    protected readonly apiGetter: () => Promise<Keplr | undefined>,\n    denomHelper: DenomHelper,\n    protected readonly bech32Address: string,\n    protected readonly querySecretContractCodeHash: ObservableQuerySecretContractCodeHash\n  ) {\n    super(\n      kvStore,\n      chainId,\n      chainGetter,\n      // No need to set the url at initial.\n      \"\",\n      denomHelper\n    );\n\n    makeObservable(this);\n\n    const viewingKey = (() => {\n      const currency = this.currency;\n      if (\"type\" in currency && currency.type === \"secret20\") {\n        return currency.viewingKey;\n      }\n\n      return \"\";\n    })();\n\n    this.querySecret20Balance = new ObservableQuerySecret20Balance(\n      kvStore,\n      chainId,\n      chainGetter,\n      this.apiGetter,\n      denomHelper.contractAddress,\n      bech32Address,\n      viewingKey,\n      this.querySecretContractCodeHash\n    );\n  }\n\n  // This method doesn't have the role because the fetching is actually exeucnted in the `ObservableQuerySecret20Balance`.\n  protected canFetch(): boolean {\n    return false;\n  }\n\n  @override\n  *fetch() {\n    yield this.querySecret20Balance.fetch();\n  }\n\n  get isFetching(): boolean {\n    return (\n      this.querySecretContractCodeHash.getQueryContract(\n        this.denomHelper.contractAddress\n      ).isFetching || this.querySecret20Balance.isFetching\n    );\n  }\n\n  get error(): Readonly<QueryError<unknown>> | undefined {\n    return (\n      this.querySecretContractCodeHash.getQueryContract(\n        this.denomHelper.contractAddress\n      ).error || this.querySecret20Balance.error\n    );\n  }\n\n  @computed\n  get balance(): CoinPretty {\n    const denom = this.denomHelper.denom;\n\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    const currency = chainInfo.findCurrency(denom);\n\n    // TODO: Infer the currency according to its denom (such if denom is `uatom` -> `Atom` with decimal 6)?\n    if (!currency) {\n      throw new Error(`Unknown currency: ${denom}`);\n    }\n\n    if (\n      !this.querySecret20Balance.response ||\n      !this.querySecret20Balance.response.data.balance\n    ) {\n      return new CoinPretty(currency, new Int(0)).ready(false);\n    }\n\n    return new CoinPretty(\n      currency,\n      new Int(this.querySecret20Balance.response.data.balance.amount)\n    );\n  }\n}\n\nexport class ObservableQuerySecret20BalanceRegistry implements BalanceRegistry {\n  constructor(\n    protected readonly kvStore: KVStore,\n    protected readonly apiGetter: () => Promise<Keplr | undefined>,\n    protected readonly querySecretContractCodeHash: ObservableQuerySecretContractCodeHash\n  ) {}\n\n  getBalanceInner(\n    chainId: string,\n    chainGetter: ChainGetter,\n    bech32Address: string,\n    minimalDenom: string\n  ): ObservableQueryBalanceInner | undefined {\n    const denomHelper = new DenomHelper(minimalDenom);\n    if (denomHelper.type === \"secret20\") {\n      return new ObservableQuerySecret20BalanceInner(\n        this.kvStore,\n        chainId,\n        chainGetter,\n        this.apiGetter,\n        denomHelper,\n        bech32Address,\n        this.querySecretContractCodeHash\n      );\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}