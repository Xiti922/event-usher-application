{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DenomHelper = void 0;\nconst buffer_1 = require(\"buffer/\");\nconst crypto_1 = require(\"@keplr-wallet/crypto\");\nclass DenomHelper {\n  constructor(_denom) {\n    this._denom = _denom;\n    // Remember that the coin's actual denom should start with \"type:contractAddress:denom\" if it is for the token based on contract.\n    const split = this.denom.split(/(\\w+):(\\w+):(.+)/).filter(Boolean);\n    if (split.length !== 1 && split.length !== 3) {\n      throw new Error(`Invalid denom: ${this.denom}`);\n    }\n    this._type = split.length === 3 ? split[0] : \"\";\n    this._contractAddress = split.length === 3 ? split[1] : \"\";\n  }\n  static ibcDenom(paths, coinMinimalDenom) {\n    const prefixes = [];\n    for (const path of paths) {\n      prefixes.push(`${path.portId}/${path.channelId}`);\n    }\n    const prefix = prefixes.join(\"/\");\n    const denom = `${prefix}/${coinMinimalDenom}`;\n    return \"ibc/\" + buffer_1.Buffer.from(crypto_1.Hash.sha256(buffer_1.Buffer.from(denom))).toString(\"hex\").toUpperCase();\n  }\n  get denom() {\n    return this._denom;\n  }\n  get type() {\n    return this._type || \"native\";\n  }\n  get contractAddress() {\n    return this._contractAddress;\n  }\n}\nexports.DenomHelper = DenomHelper;","map":{"version":3,"mappings":";;;;;;AAAA;AACA;AAEA,MAAaA,WAAW;EA2BtBC,YAA+BC,MAAc;IAAd,WAAM,GAANA,MAAM;IACnC;IACA,MAAMC,KAAK,GAAG,IAAI,CAACC,KAAK,CAACD,KAAK,CAAC,kBAAkB,CAAC,CAACE,MAAM,CAACC,OAAO,CAAC;IAClE,IAAIH,KAAK,CAACI,MAAM,KAAK,CAAC,IAAIJ,KAAK,CAACI,MAAM,KAAK,CAAC,EAAE;MAC5C,MAAM,IAAIC,KAAK,CAAC,kBAAkB,IAAI,CAACJ,KAAK,EAAE,CAAC;;IAGjD,IAAI,CAACK,KAAK,GAAGN,KAAK,CAACI,MAAM,KAAK,CAAC,GAAGJ,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE;IAC/C,IAAI,CAACO,gBAAgB,GAAGP,KAAK,CAACI,MAAM,KAAK,CAAC,GAAGJ,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE;EAC5D;EAnCA,OAAOQ,QAAQ,CACbC,KAGG,EACHC,gBAAwB;IAExB,MAAMC,QAAQ,GAAa,EAAE;IAC7B,KAAK,MAAMC,IAAI,IAAIH,KAAK,EAAE;MACxBE,QAAQ,CAACE,IAAI,CAAC,GAAGD,IAAI,CAACE,MAAM,IAAIF,IAAI,CAACG,SAAS,EAAE,CAAC;;IAGnD,MAAMC,MAAM,GAAGL,QAAQ,CAACM,IAAI,CAAC,GAAG,CAAC;IACjC,MAAMhB,KAAK,GAAG,GAAGe,MAAM,IAAIN,gBAAgB,EAAE;IAE7C,OACE,MAAM,GACNQ,eAAM,CAACC,IAAI,CAACC,aAAI,CAACC,MAAM,CAACH,eAAM,CAACC,IAAI,CAAClB,KAAK,CAAC,CAAC,CAAC,CACzCqB,QAAQ,CAAC,KAAK,CAAC,CACfC,WAAW,EAAE;EAEpB;EAgBA,IAAItB,KAAK;IACP,OAAO,IAAI,CAACF,MAAM;EACpB;EAEA,IAAIyB,IAAI;IACN,OAAO,IAAI,CAAClB,KAAK,IAAI,QAAQ;EAC/B;EAEA,IAAImB,eAAe;IACjB,OAAO,IAAI,CAAClB,gBAAgB;EAC9B;;AAhDFmB","names":["DenomHelper","constructor","_denom","split","denom","filter","Boolean","length","Error","_type","_contractAddress","ibcDenom","paths","coinMinimalDenom","prefixes","path","push","portId","channelId","prefix","join","buffer_1","from","crypto_1","sha256","toString","toUpperCase","type","contractAddress","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/node_modules/@keplr-wallet/common/src/denom/index.ts"],"sourcesContent":["import { Buffer } from \"buffer/\";\nimport { Hash } from \"@keplr-wallet/crypto\";\n\nexport class DenomHelper {\n  static ibcDenom(\n    paths: {\n      portId: string;\n      channelId: string;\n    }[],\n    coinMinimalDenom: string\n  ): string {\n    const prefixes: string[] = [];\n    for (const path of paths) {\n      prefixes.push(`${path.portId}/${path.channelId}`);\n    }\n\n    const prefix = prefixes.join(\"/\");\n    const denom = `${prefix}/${coinMinimalDenom}`;\n\n    return (\n      \"ibc/\" +\n      Buffer.from(Hash.sha256(Buffer.from(denom)))\n        .toString(\"hex\")\n        .toUpperCase()\n    );\n  }\n\n  protected readonly _type: string;\n  protected readonly _contractAddress: string;\n\n  constructor(protected readonly _denom: string) {\n    // Remember that the coin's actual denom should start with \"type:contractAddress:denom\" if it is for the token based on contract.\n    const split = this.denom.split(/(\\w+):(\\w+):(.+)/).filter(Boolean);\n    if (split.length !== 1 && split.length !== 3) {\n      throw new Error(`Invalid denom: ${this.denom}`);\n    }\n\n    this._type = split.length === 3 ? split[0] : \"\";\n    this._contractAddress = split.length === 3 ? split[1] : \"\";\n  }\n\n  get denom(): string {\n    return this._denom;\n  }\n\n  get type(): string {\n    return this._type || \"native\";\n  }\n\n  get contractAddress(): string {\n    return this._contractAddress;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}