{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableQueryDenomTrace = exports.ObservableChainQueryDenomTrace = void 0;\nconst chain_query_1 = require(\"../../chain-query\");\nconst mobx_1 = require(\"mobx\");\nclass ObservableChainQueryDenomTrace extends chain_query_1.ObservableChainQuery {\n  constructor(kvStore, chainId, chainGetter, hash) {\n    super(kvStore, chainId, chainGetter, `/ibc/applications/transfer/v1beta1/denom_traces/${hash}`);\n    this.hash = hash;\n  }\n  onStart() {\n    super.onStart();\n    return new Promise(resolve => {\n      this.disposer = mobx_1.autorun(() => {\n        const chainInfo = this.chainGetter.getChain(this.chainId);\n        if (chainInfo.features && chainInfo.features.includes(\"ibc-go\")) {\n          this.setUrl(`/ibc/apps/transfer/v1/denom_traces/${this.hash}`);\n        }\n        resolve();\n      });\n    });\n  }\n  onStop() {\n    if (this.disposer) {\n      this.disposer();\n      this.disposer = undefined;\n    }\n    super.onStop();\n  }\n  get paths() {\n    if (!this.response) {\n      return [];\n    }\n    const rawPaths = this.response.data.denom_trace.path.split(\"/\");\n    if (rawPaths.length % 2 !== 0) {\n      console.log(\"Failed to parse paths\", rawPaths);\n      return [];\n    }\n    const rawPathChunks = [];\n    for (let i = 0; i < rawPaths.length; i += 2) {\n      rawPathChunks.push(rawPaths.slice(i, i + 2));\n    }\n    return rawPathChunks.map(chunk => {\n      return {\n        portId: chunk[0],\n        channelId: chunk[1]\n      };\n    });\n  }\n  get denom() {\n    if (!this.response) {\n      return undefined;\n    }\n    return this.response.data.denom_trace.base_denom;\n  }\n  get denomTrace() {\n    if (!this.response || !this.denom) {\n      return undefined;\n    }\n    return {\n      denom: this.denom,\n      paths: this.paths\n    };\n  }\n}\n__decorate([mobx_1.computed], ObservableChainQueryDenomTrace.prototype, \"paths\", null);\n__decorate([mobx_1.computed], ObservableChainQueryDenomTrace.prototype, \"denomTrace\", null);\nexports.ObservableChainQueryDenomTrace = ObservableChainQueryDenomTrace;\nclass ObservableQueryDenomTrace extends chain_query_1.ObservableChainQueryMap {\n  constructor(kvStore, chainId, chainGetter) {\n    super(kvStore, chainId, chainGetter, hash => {\n      return new ObservableChainQueryDenomTrace(this.kvStore, this.chainId, this.chainGetter, hash);\n    });\n    this.kvStore = kvStore;\n    this.chainId = chainId;\n    this.chainGetter = chainGetter;\n  }\n  getDenomTrace(hash) {\n    return this.get(hash);\n  }\n}\nexports.ObservableQueryDenomTrace = ObservableQueryDenomTrace;","map":{"version":3,"mappings":"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","names":["ObservableChainQueryDenomTrace","chain_query_1","constructor","kvStore","chainId","chainGetter","hash","onStart","Promise","resolve","disposer","mobx_1","chainInfo","getChain","features","includes","setUrl","onStop","undefined","paths","response","rawPaths","data","denom_trace","path","split","length","console","log","rawPathChunks","i","push","slice","map","chunk","portId","channelId","denom","base_denom","denomTrace","__decorate","exports","ObservableQueryDenomTrace","getDenomTrace","get"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/query/cosmos/ibc/denom-trace.ts"],"sourcesContent":["import { KVStore } from \"@keplr-wallet/common\";\nimport {\n  ObservableChainQuery,\n  ObservableChainQueryMap,\n} from \"../../chain-query\";\nimport { ChainGetter } from \"../../../common\";\nimport { DenomTraceResponse } from \"./types\";\nimport { autorun, computed } from \"mobx\";\n\nexport class ObservableChainQueryDenomTrace extends ObservableChainQuery<DenomTraceResponse> {\n  protected disposer?: () => void;\n\n  constructor(\n    kvStore: KVStore,\n    chainId: string,\n    chainGetter: ChainGetter,\n    protected readonly hash: string\n  ) {\n    super(\n      kvStore,\n      chainId,\n      chainGetter,\n      `/ibc/applications/transfer/v1beta1/denom_traces/${hash}`\n    );\n  }\n\n  protected onStart() {\n    super.onStart();\n\n    return new Promise<void>((resolve) => {\n      this.disposer = autorun(() => {\n        const chainInfo = this.chainGetter.getChain(this.chainId);\n        if (chainInfo.features && chainInfo.features.includes(\"ibc-go\")) {\n          this.setUrl(`/ibc/apps/transfer/v1/denom_traces/${this.hash}`);\n        }\n        resolve();\n      });\n    });\n  }\n\n  protected onStop() {\n    if (this.disposer) {\n      this.disposer();\n      this.disposer = undefined;\n    }\n    super.onStop();\n  }\n\n  @computed\n  get paths(): {\n    portId: string;\n    channelId: string;\n  }[] {\n    if (!this.response) {\n      return [];\n    }\n\n    const rawPaths = this.response.data.denom_trace.path.split(\"/\");\n\n    if (rawPaths.length % 2 !== 0) {\n      console.log(\"Failed to parse paths\", rawPaths);\n      return [];\n    }\n\n    const rawPathChunks: string[][] = [];\n    for (let i = 0; i < rawPaths.length; i += 2) {\n      rawPathChunks.push(rawPaths.slice(i, i + 2));\n    }\n\n    return rawPathChunks.map((chunk) => {\n      return {\n        portId: chunk[0],\n        channelId: chunk[1],\n      };\n    });\n  }\n\n  get denom(): string | undefined {\n    if (!this.response) {\n      return undefined;\n    }\n\n    return this.response.data.denom_trace.base_denom;\n  }\n\n  @computed\n  get denomTrace():\n    | {\n        denom: string;\n        paths: {\n          portId: string;\n          channelId: string;\n        }[];\n      }\n    | undefined {\n    if (!this.response || !this.denom) {\n      return undefined;\n    }\n\n    return {\n      denom: this.denom,\n      paths: this.paths,\n    };\n  }\n}\n\nexport class ObservableQueryDenomTrace extends ObservableChainQueryMap<DenomTraceResponse> {\n  constructor(\n    protected readonly kvStore: KVStore,\n    protected readonly chainId: string,\n    protected readonly chainGetter: ChainGetter\n  ) {\n    super(kvStore, chainId, chainGetter, (hash: string) => {\n      return new ObservableChainQueryDenomTrace(\n        this.kvStore,\n        this.chainId,\n        this.chainGetter,\n        hash\n      );\n    });\n  }\n\n  getDenomTrace(hash: string): ObservableChainQueryDenomTrace {\n    return this.get(hash) as ObservableChainQueryDenomTrace;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}