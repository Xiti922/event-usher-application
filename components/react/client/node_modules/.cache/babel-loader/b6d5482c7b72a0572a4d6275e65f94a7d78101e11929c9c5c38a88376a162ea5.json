{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Keplr = void 0;\nconst router_1 = require(\"@keplr-wallet/router\");\nconst types_1 = require(\"./types\");\nconst enigma_1 = require(\"./enigma\");\nconst cosmjs_1 = require(\"./cosmjs\");\nconst deepmerge_1 = __importDefault(require(\"deepmerge\"));\nconst long_1 = __importDefault(require(\"long\"));\nconst buffer_1 = require(\"buffer/\");\nclass Keplr {\n  constructor(version, mode, requester) {\n    this.version = version;\n    this.mode = mode;\n    this.requester = requester;\n    this.enigmaUtils = new Map();\n    this.defaultOptions = {};\n  }\n  enable(chainIds) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof chainIds === \"string\") {\n        chainIds = [chainIds];\n      }\n      yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new types_1.EnableAccessMsg(chainIds));\n    });\n  }\n  experimentalSuggestChain(chainInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = new types_1.SuggestChainInfoMsg(chainInfo);\n      yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);\n    });\n  }\n  getKey(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = new types_1.GetKeyMsg(chainId);\n      return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);\n    });\n  }\n  sendTx(chainId, tx, mode) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = new types_1.SendTxMsg(chainId, tx, mode);\n      return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);\n    });\n  }\n  signAmino(chainId, signer, signDoc) {\n    let signOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = new types_1.RequestSignAminoMsg(chainId, signer, signDoc, deepmerge_1.default((_a = this.defaultOptions.sign) !== null && _a !== void 0 ? _a : {}, signOptions));\n      return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);\n    });\n  }\n  signDirect(chainId, signer, signDoc) {\n    let signOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = new types_1.RequestSignDirectMsg(chainId, signer, {\n        bodyBytes: signDoc.bodyBytes,\n        authInfoBytes: signDoc.authInfoBytes,\n        chainId: signDoc.chainId,\n        accountNumber: signDoc.accountNumber ? signDoc.accountNumber.toString() : null\n      }, deepmerge_1.default((_a = this.defaultOptions.sign) !== null && _a !== void 0 ? _a : {}, signOptions));\n      const response = yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);\n      return {\n        signed: {\n          bodyBytes: response.signed.bodyBytes,\n          authInfoBytes: response.signed.authInfoBytes,\n          chainId: response.signed.chainId,\n          accountNumber: long_1.default.fromString(response.signed.accountNumber)\n        },\n        signature: response.signature\n      };\n    });\n  }\n  signArbitrary(chainId, signer, data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let isADR36WithString = false;\n      if (typeof data === \"string\") {\n        data = buffer_1.Buffer.from(data).toString(\"base64\");\n        isADR36WithString = true;\n      } else {\n        data = buffer_1.Buffer.from(data).toString(\"base64\");\n      }\n      const signDoc = {\n        chain_id: \"\",\n        account_number: \"0\",\n        sequence: \"0\",\n        fee: {\n          gas: \"0\",\n          amount: []\n        },\n        msgs: [{\n          type: \"sign/MsgSignData\",\n          value: {\n            signer,\n            data\n          }\n        }],\n        memo: \"\"\n      };\n      const msg = new types_1.RequestSignAminoMsg(chainId, signer, signDoc, {\n        isADR36WithString\n      });\n      return (yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg)).signature;\n    });\n  }\n  verifyArbitrary(chainId, signer, data, signature) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof data === \"string\") {\n        data = buffer_1.Buffer.from(data);\n      }\n      return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new types_1.RequestVerifyADR36AminoSignDoc(chainId, signer, data, signature));\n    });\n  }\n  getOfflineSigner(chainId) {\n    return new cosmjs_1.CosmJSOfflineSigner(chainId, this);\n  }\n  getOfflineSignerOnlyAmino(chainId) {\n    return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this);\n  }\n  getOfflineSignerAuto(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const key = yield this.getKey(chainId);\n      if (key.isNanoLedger) {\n        return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this);\n      }\n      return new cosmjs_1.CosmJSOfflineSigner(chainId, this);\n    });\n  }\n  suggestToken(chainId, contractAddress, viewingKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = new types_1.SuggestTokenMsg(chainId, contractAddress, viewingKey);\n      yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);\n    });\n  }\n  getSecret20ViewingKey(chainId, contractAddress) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = new types_1.GetSecret20ViewingKey(chainId, contractAddress);\n      return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);\n    });\n  }\n  getEnigmaPubKey(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new types_1.GetPubkeyMsg(chainId));\n    });\n  }\n  getEnigmaTxEncryptionKey(chainId, nonce) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new types_1.GetTxEncryptionKeyMsg(chainId, nonce));\n    });\n  }\n  enigmaEncrypt(chainId, contractCodeHash,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new types_1.ReqeustEncryptMsg(chainId, contractCodeHash, msg));\n    });\n  }\n  enigmaDecrypt(chainId, ciphertext, nonce) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!ciphertext || ciphertext.length === 0) {\n        return new Uint8Array();\n      }\n      return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new types_1.RequestDecryptMsg(chainId, ciphertext, nonce));\n    });\n  }\n  getEnigmaUtils(chainId) {\n    if (this.enigmaUtils.has(chainId)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.enigmaUtils.get(chainId);\n    }\n    const enigmaUtils = new enigma_1.KeplrEnigmaUtils(chainId, this);\n    this.enigmaUtils.set(chainId, enigmaUtils);\n    return enigmaUtils;\n  }\n}\nexports.Keplr = Keplr;","map":{"version":3,"mappings":"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","names":["Keplr","constructor","version","mode","requester","Map","enable","chainIds","sendMessage","router_1","types_1","experimentalSuggestChain","chainInfo","msg","getKey","chainId","sendTx","tx","signAmino","signer","signDoc","signOptions","deepmerge_1","defaultOptions","sign","signDirect","bodyBytes","authInfoBytes","accountNumber","toString","response","signed","long_1","fromString","signature","signArbitrary","data","isADR36WithString","buffer_1","from","chain_id","account_number","sequence","fee","gas","amount","msgs","type","value","memo","verifyArbitrary","getOfflineSigner","cosmjs_1","getOfflineSignerOnlyAmino","getOfflineSignerAuto","key","isNanoLedger","suggestToken","contractAddress","viewingKey","getSecret20ViewingKey","getEnigmaPubKey","getEnigmaTxEncryptionKey","nonce","enigmaEncrypt","contractCodeHash","enigmaDecrypt","ciphertext","length","Uint8Array","getEnigmaUtils","enigmaUtils","has","get","enigma_1","set","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/provider/src/core.ts"],"sourcesContent":["import {\n  ChainInfo,\n  Keplr as IKeplr,\n  KeplrIntereactionOptions,\n  KeplrMode,\n  KeplrSignOptions,\n  Key,\n} from \"@keplr-wallet/types\";\nimport { BACKGROUND_PORT, MessageRequester } from \"@keplr-wallet/router\";\nimport {\n  BroadcastMode,\n  AminoSignResponse,\n  StdSignDoc,\n  StdTx,\n  OfflineSigner,\n  StdSignature,\n} from \"@cosmjs/launchpad\";\nimport {\n  EnableAccessMsg,\n  SuggestChainInfoMsg,\n  GetKeyMsg,\n  SuggestTokenMsg,\n  SendTxMsg,\n  GetSecret20ViewingKey,\n  RequestSignAminoMsg,\n  RequestSignDirectMsg,\n  GetPubkeyMsg,\n  ReqeustEncryptMsg,\n  RequestDecryptMsg,\n  GetTxEncryptionKeyMsg,\n  RequestVerifyADR36AminoSignDoc,\n} from \"./types\";\nimport { SecretUtils } from \"secretjs/types/enigmautils\";\n\nimport { KeplrEnigmaUtils } from \"./enigma\";\nimport { DirectSignResponse, OfflineDirectSigner } from \"@cosmjs/proto-signing\";\n\nimport { CosmJSOfflineSigner, CosmJSOfflineSignerOnlyAmino } from \"./cosmjs\";\nimport deepmerge from \"deepmerge\";\nimport Long from \"long\";\nimport { Buffer } from \"buffer/\";\n\nexport class Keplr implements IKeplr {\n  protected enigmaUtils: Map<string, SecretUtils> = new Map();\n\n  public defaultOptions: KeplrIntereactionOptions = {};\n\n  constructor(\n    public readonly version: string,\n    public readonly mode: KeplrMode,\n    protected readonly requester: MessageRequester\n  ) {}\n\n  async enable(chainIds: string | string[]): Promise<void> {\n    if (typeof chainIds === \"string\") {\n      chainIds = [chainIds];\n    }\n\n    await this.requester.sendMessage(\n      BACKGROUND_PORT,\n      new EnableAccessMsg(chainIds)\n    );\n  }\n\n  async experimentalSuggestChain(chainInfo: ChainInfo): Promise<void> {\n    const msg = new SuggestChainInfoMsg(chainInfo);\n    await this.requester.sendMessage(BACKGROUND_PORT, msg);\n  }\n\n  async getKey(chainId: string): Promise<Key> {\n    const msg = new GetKeyMsg(chainId);\n    return await this.requester.sendMessage(BACKGROUND_PORT, msg);\n  }\n\n  async sendTx(\n    chainId: string,\n    tx: StdTx | Uint8Array,\n    mode: BroadcastMode\n  ): Promise<Uint8Array> {\n    const msg = new SendTxMsg(chainId, tx, mode);\n    return await this.requester.sendMessage(BACKGROUND_PORT, msg);\n  }\n\n  async signAmino(\n    chainId: string,\n    signer: string,\n    signDoc: StdSignDoc,\n    signOptions: KeplrSignOptions = {}\n  ): Promise<AminoSignResponse> {\n    const msg = new RequestSignAminoMsg(\n      chainId,\n      signer,\n      signDoc,\n      deepmerge(this.defaultOptions.sign ?? {}, signOptions)\n    );\n    return await this.requester.sendMessage(BACKGROUND_PORT, msg);\n  }\n\n  async signDirect(\n    chainId: string,\n    signer: string,\n    signDoc: {\n      bodyBytes?: Uint8Array | null;\n      authInfoBytes?: Uint8Array | null;\n      chainId?: string | null;\n      accountNumber?: Long | null;\n    },\n    signOptions: KeplrSignOptions = {}\n  ): Promise<DirectSignResponse> {\n    const msg = new RequestSignDirectMsg(\n      chainId,\n      signer,\n      {\n        bodyBytes: signDoc.bodyBytes,\n        authInfoBytes: signDoc.authInfoBytes,\n        chainId: signDoc.chainId,\n        accountNumber: signDoc.accountNumber\n          ? signDoc.accountNumber.toString()\n          : null,\n      },\n      deepmerge(this.defaultOptions.sign ?? {}, signOptions)\n    );\n    const response = await this.requester.sendMessage(BACKGROUND_PORT, msg);\n\n    return {\n      signed: {\n        bodyBytes: response.signed.bodyBytes,\n        authInfoBytes: response.signed.authInfoBytes,\n        chainId: response.signed.chainId,\n        accountNumber: Long.fromString(response.signed.accountNumber),\n      },\n      signature: response.signature,\n    };\n  }\n\n  async signArbitrary(\n    chainId: string,\n    signer: string,\n    data: string | Uint8Array\n  ): Promise<StdSignature> {\n    let isADR36WithString = false;\n    if (typeof data === \"string\") {\n      data = Buffer.from(data).toString(\"base64\");\n      isADR36WithString = true;\n    } else {\n      data = Buffer.from(data).toString(\"base64\");\n    }\n\n    const signDoc = {\n      chain_id: \"\",\n      account_number: \"0\",\n      sequence: \"0\",\n      fee: {\n        gas: \"0\",\n        amount: [],\n      },\n      msgs: [\n        {\n          type: \"sign/MsgSignData\",\n          value: {\n            signer,\n            data,\n          },\n        },\n      ],\n      memo: \"\",\n    };\n\n    const msg = new RequestSignAminoMsg(chainId, signer, signDoc, {\n      isADR36WithString,\n    });\n    return (await this.requester.sendMessage(BACKGROUND_PORT, msg)).signature;\n  }\n\n  async verifyArbitrary(\n    chainId: string,\n    signer: string,\n    data: string | Uint8Array,\n    signature: StdSignature\n  ): Promise<boolean> {\n    if (typeof data === \"string\") {\n      data = Buffer.from(data);\n    }\n\n    return await this.requester.sendMessage(\n      BACKGROUND_PORT,\n      new RequestVerifyADR36AminoSignDoc(chainId, signer, data, signature)\n    );\n  }\n\n  getOfflineSigner(chainId: string): OfflineSigner & OfflineDirectSigner {\n    return new CosmJSOfflineSigner(chainId, this);\n  }\n\n  getOfflineSignerOnlyAmino(chainId: string): OfflineSigner {\n    return new CosmJSOfflineSignerOnlyAmino(chainId, this);\n  }\n\n  async getOfflineSignerAuto(\n    chainId: string\n  ): Promise<OfflineSigner | OfflineDirectSigner> {\n    const key = await this.getKey(chainId);\n    if (key.isNanoLedger) {\n      return new CosmJSOfflineSignerOnlyAmino(chainId, this);\n    }\n    return new CosmJSOfflineSigner(chainId, this);\n  }\n\n  async suggestToken(\n    chainId: string,\n    contractAddress: string,\n    viewingKey?: string\n  ): Promise<void> {\n    const msg = new SuggestTokenMsg(chainId, contractAddress, viewingKey);\n    await this.requester.sendMessage(BACKGROUND_PORT, msg);\n  }\n\n  async getSecret20ViewingKey(\n    chainId: string,\n    contractAddress: string\n  ): Promise<string> {\n    const msg = new GetSecret20ViewingKey(chainId, contractAddress);\n    return await this.requester.sendMessage(BACKGROUND_PORT, msg);\n  }\n\n  async getEnigmaPubKey(chainId: string): Promise<Uint8Array> {\n    return await this.requester.sendMessage(\n      BACKGROUND_PORT,\n      new GetPubkeyMsg(chainId)\n    );\n  }\n\n  async getEnigmaTxEncryptionKey(\n    chainId: string,\n    nonce: Uint8Array\n  ): Promise<Uint8Array> {\n    return await this.requester.sendMessage(\n      BACKGROUND_PORT,\n      new GetTxEncryptionKeyMsg(chainId, nonce)\n    );\n  }\n\n  async enigmaEncrypt(\n    chainId: string,\n    contractCodeHash: string,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    msg: object\n  ): Promise<Uint8Array> {\n    return await this.requester.sendMessage(\n      BACKGROUND_PORT,\n      new ReqeustEncryptMsg(chainId, contractCodeHash, msg)\n    );\n  }\n\n  async enigmaDecrypt(\n    chainId: string,\n    ciphertext: Uint8Array,\n    nonce: Uint8Array\n  ): Promise<Uint8Array> {\n    if (!ciphertext || ciphertext.length === 0) {\n      return new Uint8Array();\n    }\n\n    return await this.requester.sendMessage(\n      BACKGROUND_PORT,\n      new RequestDecryptMsg(chainId, ciphertext, nonce)\n    );\n  }\n\n  getEnigmaUtils(chainId: string): SecretUtils {\n    if (this.enigmaUtils.has(chainId)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.enigmaUtils.get(chainId)!;\n    }\n\n    const enigmaUtils = new KeplrEnigmaUtils(chainId, this);\n    this.enigmaUtils.set(chainId, enigmaUtils);\n    return enigmaUtils;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}