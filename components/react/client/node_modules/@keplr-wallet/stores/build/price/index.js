"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoinGeckoPriceStore = void 0;
const common_1 = require("../common");
const axios_1 = __importDefault(require("axios"));
const common_2 = require("@keplr-wallet/common");
const unit_1 = require("@keplr-wallet/unit");
const deepmerge_1 = __importDefault(require("deepmerge"));
const mobx_1 = require("mobx");
class Throttler {
    constructor(duration) {
        this.duration = duration;
        this.fns = [];
        this.callback = () => {
            if (this.timeoutId != null) {
                clearTimeout(this.timeoutId);
                this.timeoutId = undefined;
            }
            if (this.fns.length > 0) {
                const fn = this.fns[this.fns.length - 1];
                fn();
                this.fns = [];
            }
        };
    }
    call(fn) {
        if (this.duration <= 0) {
            fn();
            return;
        }
        this.fns.push(fn);
        if (this.timeoutId != null) {
            clearTimeout(this.timeoutId);
        }
        this.timeoutId = setTimeout(this.callback, this.duration);
    }
}
class SortedSetStorage {
    constructor(kvStore, storeKey, throttleDuration = 0) {
        this.array = [];
        this.map = {};
        this.restored = {};
        this.isRestored = false;
        this.storeKey = "";
        if (!storeKey) {
            throw new Error("Empty store key");
        }
        this.kvStore = kvStore;
        this.storeKey = storeKey;
        this.throttler = new Throttler(throttleDuration);
    }
    has(value) {
        return this.map[value] === true;
    }
    add(...values) {
        let forceSave = false;
        let unknowns = [];
        for (const value of values) {
            if (this.isRestored) {
                if (this.restored[value]) {
                    forceSave = true;
                    delete this.restored[value];
                }
            }
            if (!this.has(value)) {
                unknowns.push(value);
            }
        }
        if (unknowns.length === 0) {
            if (this.isRestored && forceSave) {
                // No need to wait
                this.throttler.call(() => this.save());
            }
            return false;
        }
        // Remove duplicated.
        unknowns = [...new Set(unknowns)];
        for (const unknown of unknowns) {
            this.map[unknown] = true;
        }
        let newArray = this.array.slice().concat(unknowns);
        newArray = newArray.sort((id1, id2) => {
            return id1 < id2 ? -1 : 1;
        });
        this.array = newArray;
        if (this.isRestored) {
            // No need to wait
            this.throttler.call(() => this.save());
        }
        return true;
    }
    get values() {
        return this.array.slice();
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.kvStore.set(this.storeKey, this.array.filter((value) => !this.restored[value]));
        });
    }
    restore() {
        return __awaiter(this, void 0, void 0, function* () {
            const saved = yield this.kvStore.get(this.storeKey);
            if (saved) {
                for (const value of saved) {
                    this.restored[value] = true;
                }
                for (const value of this.array) {
                    if (this.restored[value]) {
                        delete this.restored[value];
                    }
                }
                this.add(...saved);
            }
            this.isRestored = true;
        });
    }
}
class CoinGeckoPriceStore extends common_1.ObservableQuery {
    constructor(kvStore, supportedVsCurrencies, defaultVsCurrency, options = {}) {
        var _a;
        const instance = axios_1.default.create({
            baseURL: options.baseURL || "https://api.coingecko.com/api/v3",
        });
        super(kvStore, instance, "/simple/price");
        this.isInitialized = false;
        const throttleDuration = (_a = options.throttleDuration) !== null && _a !== void 0 ? _a : 250;
        this._coinIds = new SortedSetStorage(kvStore, "__coin_ids", throttleDuration);
        this._vsCurrencies = new SortedSetStorage(kvStore, "__vs_currencies", throttleDuration);
        this._defaultVsCurrency = defaultVsCurrency;
        this._supportedVsCurrencies = supportedVsCurrencies;
        this._throttler = new Throttler(throttleDuration);
        mobx_1.makeObservable(this);
        this.restoreDefaultVsCurrency();
    }
    onStart() {
        super.onStart();
        return this.init();
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isInitialized) {
                return;
            }
            yield Promise.all([this._coinIds.restore(), this._vsCurrencies.restore()]);
            // No need to wait
            this._coinIds.save();
            this._vsCurrencies.save();
            this.updateURL([], [], true);
            this.isInitialized = true;
        });
    }
    get defaultVsCurrency() {
        return this._defaultVsCurrency;
    }
    setDefaultVsCurrency(defaultVsCurrency) {
        this._defaultVsCurrency = defaultVsCurrency;
        this.saveDefaultVsCurrency();
    }
    *restoreDefaultVsCurrency() {
        const saved = yield* common_2.toGenerator(this.kvStore.get("__default_vs_currency"));
        if (saved) {
            this._defaultVsCurrency = saved;
        }
    }
    saveDefaultVsCurrency() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.kvStore.set("__default_vs_currency", this.defaultVsCurrency);
        });
    }
    get supportedVsCurrencies() {
        return this._supportedVsCurrencies;
    }
    getFiatCurrency(currency) {
        return this._supportedVsCurrencies[currency];
    }
    canFetch() {
        return (this._coinIds.values.length > 0 && this._vsCurrencies.values.length > 0);
    }
    fetchResponse(abortController) {
        const _super = Object.create(null, {
            fetchResponse: { get: () => super.fetchResponse }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const { response, headers } = yield _super.fetchResponse.call(this, abortController);
            // Because this store only queries the price of the tokens that have been requested from start,
            // it will remove the prior prices that have not been requested to just return the fetching result.
            // So, to prevent this problem, merge the prior response and current response with retaining the prior response's price.
            return {
                headers,
                response: Object.assign(Object.assign({}, response), {
                    data: deepmerge_1.default(this.response ? this.response.data : {}, response.data),
                }),
            };
        });
    }
    updateURL(coinIds, vsCurrencies, forceSetUrl = false) {
        const coinIdsUpdated = this._coinIds.add(...coinIds);
        const vsCurrenciesUpdated = this._vsCurrencies.add(...vsCurrencies);
        if (coinIdsUpdated || vsCurrenciesUpdated || forceSetUrl) {
            const url = `/simple/price?ids=${this._coinIds.values.join(",")}&vs_currencies=${this._vsCurrencies.values.join(",")}`;
            if (!this.isInitialized) {
                this.setUrl(url);
            }
            else {
                this._throttler.call(() => this.setUrl(url));
            }
        }
    }
    getCacheKey() {
        // Because the uri of the coingecko would be changed according to the coin ids and vsCurrencies.
        // Therefore, just using the uri as the cache key is not useful.
        return `${this.instance.name}-${this.instance.defaults.baseURL}${this.instance.getUri({
            url: "/simple/price",
        })}`;
    }
    getPrice(coinId, vsCurrency) {
        if (!vsCurrency) {
            vsCurrency = this.defaultVsCurrency;
        }
        if (!this.supportedVsCurrencies[vsCurrency]) {
            return undefined;
        }
        this.updateURL([coinId], [vsCurrency]);
        if (!this.response) {
            return undefined;
        }
        const coinPrices = this.response.data[coinId];
        if (!coinPrices) {
            return undefined;
        }
        return coinPrices[vsCurrency];
    }
    calculatePrice(coin, vsCurrrency) {
        if (!coin.currency.coinGeckoId) {
            return undefined;
        }
        if (!vsCurrrency) {
            vsCurrrency = this.defaultVsCurrency;
        }
        const fiatCurrency = this.supportedVsCurrencies[vsCurrrency];
        if (!fiatCurrency) {
            return undefined;
        }
        const price = this.getPrice(coin.currency.coinGeckoId, vsCurrrency);
        if (price === undefined) {
            return new unit_1.PricePretty(fiatCurrency, new unit_1.Int(0)).ready(false);
        }
        const dec = coin.toDec();
        const priceDec = new unit_1.Dec(price.toString());
        return new unit_1.PricePretty(fiatCurrency, dec.mul(priceDec));
    }
}
__decorate([
    mobx_1.observable
], CoinGeckoPriceStore.prototype, "_defaultVsCurrency", void 0);
__decorate([
    mobx_1.action
], CoinGeckoPriceStore.prototype, "setDefaultVsCurrency", null);
__decorate([
    mobx_1.flow
], CoinGeckoPriceStore.prototype, "restoreDefaultVsCurrency", null);
exports.CoinGeckoPriceStore = CoinGeckoPriceStore;
//# sourceMappingURL=index.js.map