{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InjectedKeplr = void 0;\nconst router_1 = require(\"@keplr-wallet/router\");\nconst enigma_1 = require(\"./enigma\");\nconst cosmjs_1 = require(\"./cosmjs\");\nconst deepmerge_1 = __importDefault(require(\"deepmerge\"));\nconst long_1 = __importDefault(require(\"long\"));\n/**\n * InjectedKeplr would be injected to the webpage.\n * In the webpage, it can't request any messages to the extension because it doesn't have any API related to the extension.\n * So, to request some methods of the extension, this will proxy the request to the content script that is injected to webpage on the extension level.\n * This will use `window.postMessage` to interact with the content script.\n */\nclass InjectedKeplr {\n  constructor(version, mode) {\n    let eventListener = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      addMessageListener: fn => window.addEventListener(\"message\", fn),\n      removeMessageListener: fn => window.removeEventListener(\"message\", fn),\n      postMessage: message => window.postMessage(message, window.location.origin)\n    };\n    let parseMessage = arguments.length > 3 ? arguments[3] : undefined;\n    this.version = version;\n    this.mode = mode;\n    this.eventListener = eventListener;\n    this.parseMessage = parseMessage;\n    this.enigmaUtils = new Map();\n    this.defaultOptions = {};\n  }\n  static startProxy(keplr) {\n    let eventListener = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      addMessageListener: fn => window.addEventListener(\"message\", fn),\n      postMessage: message => window.postMessage(message, window.location.origin)\n    };\n    let parseMessage = arguments.length > 2 ? arguments[2] : undefined;\n    eventListener.addMessageListener(e => __awaiter(this, void 0, void 0, function* () {\n      const message = parseMessage ? parseMessage(e.data) : e.data;\n      if (!message || message.type !== \"proxy-request\") {\n        return;\n      }\n      try {\n        if (!message.id) {\n          throw new Error(\"Empty id\");\n        }\n        if (message.method === \"version\") {\n          throw new Error(\"Version is not function\");\n        }\n        if (message.method === \"mode\") {\n          throw new Error(\"Mode is not function\");\n        }\n        if (message.method === \"defaultOptions\") {\n          throw new Error(\"DefaultOptions is not function\");\n        }\n        if (!keplr[message.method] || typeof keplr[message.method] !== \"function\") {\n          throw new Error(`Invalid method: ${message.method}`);\n        }\n        if (message.method === \"getOfflineSigner\") {\n          throw new Error(\"GetOfflineSigner method can't be proxy request\");\n        }\n        if (message.method === \"getOfflineSignerOnlyAmino\") {\n          throw new Error(\"GetOfflineSignerOnlyAmino method can't be proxy request\");\n        }\n        if (message.method === \"getOfflineSignerAuto\") {\n          throw new Error(\"GetOfflineSignerAuto method can't be proxy request\");\n        }\n        if (message.method === \"getEnigmaUtils\") {\n          throw new Error(\"GetEnigmaUtils method can't be proxy request\");\n        }\n        const result = message.method === \"signDirect\" ? yield (() => __awaiter(this, void 0, void 0, function* () {\n          const receivedSignDoc = message.args[2];\n          const result = yield keplr.signDirect(message.args[0], message.args[1], {\n            bodyBytes: receivedSignDoc.bodyBytes,\n            authInfoBytes: receivedSignDoc.authInfoBytes,\n            chainId: receivedSignDoc.chainId,\n            accountNumber: receivedSignDoc.accountNumber ? long_1.default.fromString(receivedSignDoc.accountNumber) : null\n          }, message.args[3]);\n          return {\n            signed: {\n              bodyBytes: result.signed.bodyBytes,\n              authInfoBytes: result.signed.authInfoBytes,\n              chainId: result.signed.chainId,\n              accountNumber: result.signed.accountNumber.toString()\n            },\n            signature: result.signature\n          };\n        }))() : yield keplr[message.method](\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        ...router_1.JSONUint8Array.unwrap(message.args));\n        const proxyResponse = {\n          type: \"proxy-request-response\",\n          id: message.id,\n          result: {\n            return: router_1.JSONUint8Array.wrap(result)\n          }\n        };\n        eventListener.postMessage(proxyResponse);\n      } catch (e) {\n        const proxyResponse = {\n          type: \"proxy-request-response\",\n          id: message.id,\n          result: {\n            error: e.message || e.toString()\n          }\n        };\n        eventListener.postMessage(proxyResponse);\n      }\n    }));\n  }\n  requestMethod(method, args) {\n    const bytes = new Uint8Array(8);\n    const id = Array.from(crypto.getRandomValues(bytes)).map(value => {\n      return value.toString(16);\n    }).join(\"\");\n    const proxyMessage = {\n      type: \"proxy-request\",\n      id,\n      method,\n      args: router_1.JSONUint8Array.wrap(args)\n    };\n    return new Promise((resolve, reject) => {\n      const receiveResponse = e => {\n        const proxyResponse = this.parseMessage ? this.parseMessage(e.data) : e.data;\n        if (!proxyResponse || proxyResponse.type !== \"proxy-request-response\") {\n          return;\n        }\n        if (proxyResponse.id !== id) {\n          return;\n        }\n        this.eventListener.removeMessageListener(receiveResponse);\n        const result = router_1.JSONUint8Array.unwrap(proxyResponse.result);\n        if (!result) {\n          reject(new Error(\"Result is null\"));\n          return;\n        }\n        if (result.error) {\n          reject(new Error(result.error));\n          return;\n        }\n        resolve(result.return);\n      };\n      this.eventListener.addMessageListener(receiveResponse);\n      this.eventListener.postMessage(proxyMessage);\n    });\n  }\n  enable(chainIds) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.requestMethod(\"enable\", [chainIds]);\n    });\n  }\n  experimentalSuggestChain(chainInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.requestMethod(\"experimentalSuggestChain\", [chainInfo]);\n    });\n  }\n  getKey(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requestMethod(\"getKey\", [chainId]);\n    });\n  }\n  sendTx(chainId, tx, mode) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requestMethod(\"sendTx\", [chainId, tx, mode]);\n    });\n  }\n  signAmino(chainId, signer, signDoc) {\n    let signOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requestMethod(\"signAmino\", [chainId, signer, signDoc, deepmerge_1.default((_a = this.defaultOptions.sign) !== null && _a !== void 0 ? _a : {}, signOptions)]);\n    });\n  }\n  signDirect(chainId, signer, signDoc) {\n    let signOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = yield this.requestMethod(\"signDirect\", [chainId, signer,\n      // We can't send the `Long` with remaing the type.\n      // Receiver should change the `string` to `Long`.\n      {\n        bodyBytes: signDoc.bodyBytes,\n        authInfoBytes: signDoc.authInfoBytes,\n        chainId: signDoc.chainId,\n        accountNumber: signDoc.accountNumber ? signDoc.accountNumber.toString() : null\n      }, deepmerge_1.default((_a = this.defaultOptions.sign) !== null && _a !== void 0 ? _a : {}, signOptions)]);\n      const signed = result.signed;\n      return {\n        signed: {\n          bodyBytes: signed.bodyBytes,\n          authInfoBytes: signed.authInfoBytes,\n          chainId: signed.chainId,\n          // We can't send the `Long` with remaing the type.\n          // Sender should change the `Long` to `string`.\n          accountNumber: long_1.default.fromString(signed.accountNumber)\n        },\n        signature: result.signature\n      };\n    });\n  }\n  signArbitrary(chainId, signer, data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requestMethod(\"signArbitrary\", [chainId, signer, data]);\n    });\n  }\n  verifyArbitrary(chainId, signer, data, signature) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requestMethod(\"verifyArbitrary\", [chainId, signer, data, signature]);\n    });\n  }\n  getOfflineSigner(chainId) {\n    return new cosmjs_1.CosmJSOfflineSigner(chainId, this);\n  }\n  getOfflineSignerOnlyAmino(chainId) {\n    return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this);\n  }\n  getOfflineSignerAuto(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const key = yield this.getKey(chainId);\n      if (key.isNanoLedger) {\n        return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this);\n      }\n      return new cosmjs_1.CosmJSOfflineSigner(chainId, this);\n    });\n  }\n  suggestToken(chainId, contractAddress, viewingKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requestMethod(\"suggestToken\", [chainId, contractAddress, viewingKey]);\n    });\n  }\n  getSecret20ViewingKey(chainId, contractAddress) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requestMethod(\"getSecret20ViewingKey\", [chainId, contractAddress]);\n    });\n  }\n  getEnigmaPubKey(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requestMethod(\"getEnigmaPubKey\", [chainId]);\n    });\n  }\n  getEnigmaTxEncryptionKey(chainId, nonce) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requestMethod(\"getEnigmaTxEncryptionKey\", [chainId, nonce]);\n    });\n  }\n  enigmaEncrypt(chainId, contractCodeHash,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requestMethod(\"enigmaEncrypt\", [chainId, contractCodeHash, msg]);\n    });\n  }\n  enigmaDecrypt(chainId, ciphertext, nonce) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.requestMethod(\"enigmaDecrypt\", [chainId, ciphertext, nonce]);\n    });\n  }\n  getEnigmaUtils(chainId) {\n    if (this.enigmaUtils.has(chainId)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.enigmaUtils.get(chainId);\n    }\n    const enigmaUtils = new enigma_1.KeplrEnigmaUtils(chainId, this);\n    this.enigmaUtils.set(chainId, enigmaUtils);\n    return enigmaUtils;\n  }\n}\nexports.InjectedKeplr = InjectedKeplr;","map":{"version":3,"mappings":"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","names":["InjectedKeplr","constructor","version","mode","eventListener","addMessageListener","fn","window","addEventListener","removeMessageListener","removeEventListener","postMessage","message","location","origin","parseMessage","Map","startProxy","keplr","e","__awaiter","data","type","id","Error","method","result","receivedSignDoc","args","signDirect","bodyBytes","authInfoBytes","chainId","accountNumber","long_1","fromString","signed","toString","signature","router_1","unwrap","proxyResponse","return","wrap","error","requestMethod","bytes","Uint8Array","Array","from","crypto","getRandomValues","map","value","join","proxyMessage","Promise","resolve","reject","receiveResponse","enable","chainIds","experimentalSuggestChain","chainInfo","getKey","sendTx","tx","signAmino","signer","signDoc","signOptions","deepmerge_1","defaultOptions","sign","signArbitrary","verifyArbitrary","getOfflineSigner","cosmjs_1","getOfflineSignerOnlyAmino","getOfflineSignerAuto","key","isNanoLedger","suggestToken","contractAddress","viewingKey","getSecret20ViewingKey","getEnigmaPubKey","getEnigmaTxEncryptionKey","nonce","enigmaEncrypt","contractCodeHash","msg","enigmaDecrypt","ciphertext","getEnigmaUtils","enigmaUtils","has","get","enigma_1","set","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/provider/src/inject.ts"],"sourcesContent":["import {\n  ChainInfo,\n  Keplr,\n  Keplr as IKeplr,\n  KeplrIntereactionOptions,\n  KeplrMode,\n  KeplrSignOptions,\n  Key,\n} from \"@keplr-wallet/types\";\nimport { Result, JSONUint8Array } from \"@keplr-wallet/router\";\nimport {\n  BroadcastMode,\n  AminoSignResponse,\n  StdSignDoc,\n  StdTx,\n  OfflineSigner,\n  StdSignature,\n} from \"@cosmjs/launchpad\";\nimport { SecretUtils } from \"secretjs/types/enigmautils\";\n\nimport { KeplrEnigmaUtils } from \"./enigma\";\nimport { DirectSignResponse, OfflineDirectSigner } from \"@cosmjs/proto-signing\";\n\nimport { CosmJSOfflineSigner, CosmJSOfflineSignerOnlyAmino } from \"./cosmjs\";\nimport deepmerge from \"deepmerge\";\nimport Long from \"long\";\n\nexport interface ProxyRequest {\n  type: \"proxy-request\";\n  id: string;\n  method: keyof Keplr;\n  args: any[];\n}\n\nexport interface ProxyRequestResponse {\n  type: \"proxy-request-response\";\n  id: string;\n  result: Result | undefined;\n}\n\n/**\n * InjectedKeplr would be injected to the webpage.\n * In the webpage, it can't request any messages to the extension because it doesn't have any API related to the extension.\n * So, to request some methods of the extension, this will proxy the request to the content script that is injected to webpage on the extension level.\n * This will use `window.postMessage` to interact with the content script.\n */\nexport class InjectedKeplr implements IKeplr {\n  static startProxy(\n    keplr: IKeplr,\n    eventListener: {\n      addMessageListener: (fn: (e: any) => void) => void;\n      postMessage: (message: any) => void;\n    } = {\n      addMessageListener: (fn: (e: any) => void) =>\n        window.addEventListener(\"message\", fn),\n      postMessage: (message) =>\n        window.postMessage(message, window.location.origin),\n    },\n    parseMessage?: (message: any) => any\n  ) {\n    eventListener.addMessageListener(async (e: any) => {\n      const message: ProxyRequest = parseMessage\n        ? parseMessage(e.data)\n        : e.data;\n      if (!message || message.type !== \"proxy-request\") {\n        return;\n      }\n\n      try {\n        if (!message.id) {\n          throw new Error(\"Empty id\");\n        }\n\n        if (message.method === \"version\") {\n          throw new Error(\"Version is not function\");\n        }\n\n        if (message.method === \"mode\") {\n          throw new Error(\"Mode is not function\");\n        }\n\n        if (message.method === \"defaultOptions\") {\n          throw new Error(\"DefaultOptions is not function\");\n        }\n\n        if (\n          !keplr[message.method] ||\n          typeof keplr[message.method] !== \"function\"\n        ) {\n          throw new Error(`Invalid method: ${message.method}`);\n        }\n\n        if (message.method === \"getOfflineSigner\") {\n          throw new Error(\"GetOfflineSigner method can't be proxy request\");\n        }\n\n        if (message.method === \"getOfflineSignerOnlyAmino\") {\n          throw new Error(\n            \"GetOfflineSignerOnlyAmino method can't be proxy request\"\n          );\n        }\n\n        if (message.method === \"getOfflineSignerAuto\") {\n          throw new Error(\"GetOfflineSignerAuto method can't be proxy request\");\n        }\n\n        if (message.method === \"getEnigmaUtils\") {\n          throw new Error(\"GetEnigmaUtils method can't be proxy request\");\n        }\n\n        const result =\n          message.method === \"signDirect\"\n            ? await (async () => {\n                const receivedSignDoc: {\n                  bodyBytes?: Uint8Array | null;\n                  authInfoBytes?: Uint8Array | null;\n                  chainId?: string | null;\n                  accountNumber?: string | null;\n                } = message.args[2];\n\n                const result = await keplr.signDirect(\n                  message.args[0],\n                  message.args[1],\n                  {\n                    bodyBytes: receivedSignDoc.bodyBytes,\n                    authInfoBytes: receivedSignDoc.authInfoBytes,\n                    chainId: receivedSignDoc.chainId,\n                    accountNumber: receivedSignDoc.accountNumber\n                      ? Long.fromString(receivedSignDoc.accountNumber)\n                      : null,\n                  },\n                  message.args[3]\n                );\n\n                return {\n                  signed: {\n                    bodyBytes: result.signed.bodyBytes,\n                    authInfoBytes: result.signed.authInfoBytes,\n                    chainId: result.signed.chainId,\n                    accountNumber: result.signed.accountNumber.toString(),\n                  },\n                  signature: result.signature,\n                };\n              })()\n            : await keplr[message.method](\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                ...JSONUint8Array.unwrap(message.args)\n              );\n\n        const proxyResponse: ProxyRequestResponse = {\n          type: \"proxy-request-response\",\n          id: message.id,\n          result: {\n            return: JSONUint8Array.wrap(result),\n          },\n        };\n\n        eventListener.postMessage(proxyResponse);\n      } catch (e) {\n        const proxyResponse: ProxyRequestResponse = {\n          type: \"proxy-request-response\",\n          id: message.id,\n          result: {\n            error: e.message || e.toString(),\n          },\n        };\n\n        eventListener.postMessage(proxyResponse);\n      }\n    });\n  }\n\n  protected requestMethod(method: keyof IKeplr, args: any[]): Promise<any> {\n    const bytes = new Uint8Array(8);\n    const id: string = Array.from(crypto.getRandomValues(bytes))\n      .map((value) => {\n        return value.toString(16);\n      })\n      .join(\"\");\n\n    const proxyMessage: ProxyRequest = {\n      type: \"proxy-request\",\n      id,\n      method,\n      args: JSONUint8Array.wrap(args),\n    };\n\n    return new Promise((resolve, reject) => {\n      const receiveResponse = (e: any) => {\n        const proxyResponse: ProxyRequestResponse = this.parseMessage\n          ? this.parseMessage(e.data)\n          : e.data;\n\n        if (!proxyResponse || proxyResponse.type !== \"proxy-request-response\") {\n          return;\n        }\n\n        if (proxyResponse.id !== id) {\n          return;\n        }\n\n        this.eventListener.removeMessageListener(receiveResponse);\n\n        const result = JSONUint8Array.unwrap(proxyResponse.result);\n\n        if (!result) {\n          reject(new Error(\"Result is null\"));\n          return;\n        }\n\n        if (result.error) {\n          reject(new Error(result.error));\n          return;\n        }\n\n        resolve(result.return);\n      };\n\n      this.eventListener.addMessageListener(receiveResponse);\n\n      this.eventListener.postMessage(proxyMessage);\n    });\n  }\n\n  protected enigmaUtils: Map<string, SecretUtils> = new Map();\n\n  public defaultOptions: KeplrIntereactionOptions = {};\n\n  constructor(\n    public readonly version: string,\n    public readonly mode: KeplrMode,\n    protected readonly eventListener: {\n      addMessageListener: (fn: (e: any) => void) => void;\n      removeMessageListener: (fn: (e: any) => void) => void;\n      postMessage: (message: any) => void;\n    } = {\n      addMessageListener: (fn: (e: any) => void) =>\n        window.addEventListener(\"message\", fn),\n      removeMessageListener: (fn: (e: any) => void) =>\n        window.removeEventListener(\"message\", fn),\n      postMessage: (message) =>\n        window.postMessage(message, window.location.origin),\n    },\n    protected readonly parseMessage?: (message: any) => any\n  ) {}\n\n  async enable(chainIds: string | string[]): Promise<void> {\n    await this.requestMethod(\"enable\", [chainIds]);\n  }\n\n  async experimentalSuggestChain(chainInfo: ChainInfo): Promise<void> {\n    await this.requestMethod(\"experimentalSuggestChain\", [chainInfo]);\n  }\n\n  async getKey(chainId: string): Promise<Key> {\n    return await this.requestMethod(\"getKey\", [chainId]);\n  }\n\n  async sendTx(\n    chainId: string,\n    tx: StdTx | Uint8Array,\n    mode: BroadcastMode\n  ): Promise<Uint8Array> {\n    return await this.requestMethod(\"sendTx\", [chainId, tx, mode]);\n  }\n\n  async signAmino(\n    chainId: string,\n    signer: string,\n    signDoc: StdSignDoc,\n    signOptions: KeplrSignOptions = {}\n  ): Promise<AminoSignResponse> {\n    return await this.requestMethod(\"signAmino\", [\n      chainId,\n      signer,\n      signDoc,\n      deepmerge(this.defaultOptions.sign ?? {}, signOptions),\n    ]);\n  }\n\n  async signDirect(\n    chainId: string,\n    signer: string,\n    signDoc: {\n      bodyBytes?: Uint8Array | null;\n      authInfoBytes?: Uint8Array | null;\n      chainId?: string | null;\n      accountNumber?: Long | null;\n    },\n    signOptions: KeplrSignOptions = {}\n  ): Promise<DirectSignResponse> {\n    const result = await this.requestMethod(\"signDirect\", [\n      chainId,\n      signer,\n      // We can't send the `Long` with remaing the type.\n      // Receiver should change the `string` to `Long`.\n      {\n        bodyBytes: signDoc.bodyBytes,\n        authInfoBytes: signDoc.authInfoBytes,\n        chainId: signDoc.chainId,\n        accountNumber: signDoc.accountNumber\n          ? signDoc.accountNumber.toString()\n          : null,\n      },\n      deepmerge(this.defaultOptions.sign ?? {}, signOptions),\n    ]);\n\n    const signed: {\n      bodyBytes: Uint8Array;\n      authInfoBytes: Uint8Array;\n      chainId: string;\n      accountNumber: string;\n    } = result.signed;\n\n    return {\n      signed: {\n        bodyBytes: signed.bodyBytes,\n        authInfoBytes: signed.authInfoBytes,\n        chainId: signed.chainId,\n        // We can't send the `Long` with remaing the type.\n        // Sender should change the `Long` to `string`.\n        accountNumber: Long.fromString(signed.accountNumber),\n      },\n      signature: result.signature,\n    };\n  }\n\n  async signArbitrary(\n    chainId: string,\n    signer: string,\n    data: string | Uint8Array\n  ): Promise<StdSignature> {\n    return await this.requestMethod(\"signArbitrary\", [chainId, signer, data]);\n  }\n\n  async verifyArbitrary(\n    chainId: string,\n    signer: string,\n    data: string | Uint8Array,\n    signature: StdSignature\n  ): Promise<boolean> {\n    return await this.requestMethod(\"verifyArbitrary\", [\n      chainId,\n      signer,\n      data,\n      signature,\n    ]);\n  }\n\n  getOfflineSigner(chainId: string): OfflineSigner & OfflineDirectSigner {\n    return new CosmJSOfflineSigner(chainId, this);\n  }\n\n  getOfflineSignerOnlyAmino(chainId: string): OfflineSigner {\n    return new CosmJSOfflineSignerOnlyAmino(chainId, this);\n  }\n\n  async getOfflineSignerAuto(\n    chainId: string\n  ): Promise<OfflineSigner | OfflineDirectSigner> {\n    const key = await this.getKey(chainId);\n    if (key.isNanoLedger) {\n      return new CosmJSOfflineSignerOnlyAmino(chainId, this);\n    }\n    return new CosmJSOfflineSigner(chainId, this);\n  }\n\n  async suggestToken(\n    chainId: string,\n    contractAddress: string,\n    viewingKey?: string\n  ): Promise<void> {\n    return await this.requestMethod(\"suggestToken\", [\n      chainId,\n      contractAddress,\n      viewingKey,\n    ]);\n  }\n\n  async getSecret20ViewingKey(\n    chainId: string,\n    contractAddress: string\n  ): Promise<string> {\n    return await this.requestMethod(\"getSecret20ViewingKey\", [\n      chainId,\n      contractAddress,\n    ]);\n  }\n\n  async getEnigmaPubKey(chainId: string): Promise<Uint8Array> {\n    return await this.requestMethod(\"getEnigmaPubKey\", [chainId]);\n  }\n\n  async getEnigmaTxEncryptionKey(\n    chainId: string,\n    nonce: Uint8Array\n  ): Promise<Uint8Array> {\n    return await this.requestMethod(\"getEnigmaTxEncryptionKey\", [\n      chainId,\n      nonce,\n    ]);\n  }\n\n  async enigmaEncrypt(\n    chainId: string,\n    contractCodeHash: string,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    msg: object\n  ): Promise<Uint8Array> {\n    return await this.requestMethod(\"enigmaEncrypt\", [\n      chainId,\n      contractCodeHash,\n      msg,\n    ]);\n  }\n\n  async enigmaDecrypt(\n    chainId: string,\n    ciphertext: Uint8Array,\n    nonce: Uint8Array\n  ): Promise<Uint8Array> {\n    return await this.requestMethod(\"enigmaDecrypt\", [\n      chainId,\n      ciphertext,\n      nonce,\n    ]);\n  }\n\n  getEnigmaUtils(chainId: string): SecretUtils {\n    if (this.enigmaUtils.has(chainId)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.enigmaUtils.get(chainId)!;\n    }\n\n    const enigmaUtils = new KeplrEnigmaUtils(chainId, this);\n    this.enigmaUtils.set(chainId, enigmaUtils);\n    return enigmaUtils;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}