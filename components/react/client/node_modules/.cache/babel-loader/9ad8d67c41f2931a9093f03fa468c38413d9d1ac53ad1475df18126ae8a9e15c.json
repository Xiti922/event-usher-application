{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChainsService = void 0;\nconst types_1 = require(\"./types\");\nconst common_1 = require(\"@keplr-wallet/common\");\nconst router_1 = require(\"@keplr-wallet/router\");\nconst messages_1 = require(\"./messages\");\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nclass ChainsService {\n  constructor(kvStore, embedChainInfos) {\n    let experimentalOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.kvStore = kvStore;\n    this.embedChainInfos = embedChainInfos;\n    this.experimentalOptions = experimentalOptions;\n    this.onChainRemovedHandlers = [];\n    this.getChainInfos = common_1.Debouncer.promise(() => __awaiter(this, void 0, void 0, function* () {\n      if (this.cachedChainInfos) {\n        return this.cachedChainInfos;\n      }\n      const chainInfos = this.embedChainInfos.map(chainInfo => {\n        return Object.assign(Object.assign({}, chainInfo), {\n          embeded: true\n        });\n      });\n      const embedChainInfoIdentifierMap = new Map();\n      for (const embedChainInfo of chainInfos) {\n        embedChainInfoIdentifierMap.set(cosmos_1.ChainIdHelper.parse(embedChainInfo.chainId).identifier, true);\n      }\n      const suggestedChainInfos = (yield this.getSuggestedChainInfos()).filter(chainInfo => {\n        // Filter the overlaped chain info with the embeded chain infos.\n        return !embedChainInfoIdentifierMap.get(cosmos_1.ChainIdHelper.parse(chainInfo.chainId).identifier);\n      }).map(chainInfo => {\n        return Object.assign(Object.assign({}, chainInfo), {\n          embeded: false\n        });\n      });\n      let result = chainInfos.concat(suggestedChainInfos);\n      // Set the updated property of the chain.\n      result = yield Promise.all(result.map(chainInfo => __awaiter(this, void 0, void 0, function* () {\n        const updated = yield this.chainUpdaterKeeper.putUpdatedPropertyToChainInfo(chainInfo);\n        return Object.assign(Object.assign({}, updated), {\n          embeded: chainInfo.embeded\n        });\n      })));\n      this.cachedChainInfos = result;\n      return result;\n    }));\n    if (experimentalOptions === null || experimentalOptions === void 0 ? void 0 : experimentalOptions.useMemoryKVStoreForSuggestChain) {\n      this.kvStoreForSuggestChain = new common_1.MemoryKVStore(\"suggest-chain\");\n    } else {\n      this.kvStoreForSuggestChain = kvStore;\n    }\n  }\n  init(chainUpdaterKeeper, interactionKeeper) {\n    this.chainUpdaterKeeper = chainUpdaterKeeper;\n    this.interactionKeeper = interactionKeeper;\n  }\n  clearCachedChainInfos() {\n    this.cachedChainInfos = undefined;\n  }\n  getChainInfo(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainInfo = (yield this.getChainInfos()).find(chainInfo => {\n        return cosmos_1.ChainIdHelper.parse(chainInfo.chainId).identifier === cosmos_1.ChainIdHelper.parse(chainId).identifier;\n      });\n      if (!chainInfo) {\n        throw new router_1.KeplrError(\"chains\", 411, `There is no chain info for ${chainId}`);\n      }\n      return chainInfo;\n    });\n  }\n  getChainCoinType(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainInfo = yield this.getChainInfo(chainId);\n      if (!chainInfo) {\n        throw new router_1.KeplrError(\"chains\", 411, `There is no chain info for ${chainId}`);\n      }\n      return chainInfo.bip44.coinType;\n    });\n  }\n  hasChainInfo(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.getChainInfos()).find(chainInfo => {\n        return cosmos_1.ChainIdHelper.parse(chainInfo.chainId).identifier === cosmos_1.ChainIdHelper.parse(chainId).identifier;\n      }) != null;\n    });\n  }\n  suggestChainInfo(env, chainInfo, origin) {\n    return __awaiter(this, void 0, void 0, function* () {\n      chainInfo = yield types_1.ChainInfoSchema.validateAsync(chainInfo, {\n        stripUnknown: true\n      });\n      yield this.interactionKeeper.waitApprove(env, \"/suggest-chain\", messages_1.SuggestChainInfoMsg.type(), Object.assign(Object.assign({}, chainInfo), {\n        origin\n      }));\n      yield this.addChainInfo(chainInfo);\n    });\n  }\n  getSuggestedChainInfos() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      return (_a = yield this.kvStoreForSuggestChain.get(\"chain-infos\")) !== null && _a !== void 0 ? _a : [];\n    });\n  }\n  addChainInfo(chainInfo) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (yield this.hasChainInfo(chainInfo.chainId)) {\n        throw new router_1.KeplrError(\"chains\", 121, \"Same chain is already registered\");\n      }\n      const savedChainInfos = (_a = yield this.kvStoreForSuggestChain.get(\"chain-infos\")) !== null && _a !== void 0 ? _a : [];\n      savedChainInfos.push(chainInfo);\n      yield this.kvStoreForSuggestChain.set(\"chain-infos\", savedChainInfos);\n      this.clearCachedChainInfos();\n    });\n  }\n  removeChainInfo(chainId) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!(yield this.hasChainInfo(chainId))) {\n        throw new router_1.KeplrError(\"chains\", 120, \"Chain is not registered\");\n      }\n      if ((yield this.getChainInfo(chainId)).embeded) {\n        throw new router_1.KeplrError(\"chains\", 122, \"Can't remove the embedded chain\");\n      }\n      const savedChainInfos = (_a = yield this.kvStoreForSuggestChain.get(\"chain-infos\")) !== null && _a !== void 0 ? _a : [];\n      const resultChainInfo = savedChainInfos.filter(chainInfo => {\n        return cosmos_1.ChainIdHelper.parse(chainInfo.chainId).identifier !== cosmos_1.ChainIdHelper.parse(chainId).identifier;\n      });\n      yield this.kvStoreForSuggestChain.set(\"chain-infos\", resultChainInfo);\n      // Clear the updated chain info.\n      yield this.chainUpdaterKeeper.clearUpdatedProperty(chainId);\n      for (const chainRemovedHandler of this.onChainRemovedHandlers) {\n        chainRemovedHandler(chainId, cosmos_1.ChainIdHelper.parse(chainId).identifier);\n      }\n      this.clearCachedChainInfos();\n    });\n  }\n  getChainEthereumKeyFeatures(chainId) {\n    var _a, _b, _c, _d;\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainInfo = yield this.getChainInfo(chainId);\n      return {\n        address: (_b = (_a = chainInfo.features) === null || _a === void 0 ? void 0 : _a.includes(\"eth-address-gen\")) !== null && _b !== void 0 ? _b : false,\n        signing: (_d = (_c = chainInfo.features) === null || _c === void 0 ? void 0 : _c.includes(\"eth-key-sign\")) !== null && _d !== void 0 ? _d : false\n      };\n    });\n  }\n  addChainRemovedHandler(handler) {\n    this.onChainRemovedHandlers.push(handler);\n  }\n}\nexports.ChainsService = ChainsService;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA;AAGA;AACA;AACA;AAIA,MAAaA,aAAa;EAUxBC,YACqBC,OAAgB,EAChBC,eAA4B,EAGxC;IAAA,IAFYC,0FAEd,EAAE;IAJY,YAAO,GAAPF,OAAO;IACP,oBAAe,GAAfC,eAAe;IACf,wBAAmB,GAAnBC,mBAAmB;IAZ9B,2BAAsB,GAA0B,EAAE;IA+BnD,kBAAa,GAElBC,kBAAS,CAACC,OAAO,CAAC,MAAWC;MAC/B,IAAI,IAAI,CAACC,gBAAgB,EAAE;QACzB,OAAO,IAAI,CAACA,gBAAgB;;MAG9B,MAAMC,UAAU,GAAG,IAAI,CAACN,eAAe,CAACO,GAAG,CAAEC,SAAS,IAAI;QACxD,uCACKA,SAAS;UACZC,OAAO,EAAE;QAAI;MAEjB,CAAC,CAAC;MACF,MAAMC,2BAA2B,GAG7B,IAAIC,GAAG,EAAE;MACb,KAAK,MAAMC,cAAc,IAAIN,UAAU,EAAE;QACvCI,2BAA2B,CAACG,GAAG,CAC7BC,sBAAa,CAACC,KAAK,CAACH,cAAc,CAACI,OAAO,CAAC,CAACC,UAAU,EACtD,IAAI,CACL;;MAGH,MAAMC,mBAAmB,GAAyB,CAChD,MAAM,IAAI,CAACC,sBAAsB,EAAE,EAElCC,MAAM,CAAEZ,SAAS,IAAI;QACpB;QACA,OAAO,CAACE,2BAA2B,CAACW,GAAG,CACrCP,sBAAa,CAACC,KAAK,CAACP,SAAS,CAACQ,OAAO,CAAC,CAACC,UAAU,CAClD;MACH,CAAC,CAAC,CACDV,GAAG,CAAEC,SAAoB,IAAI;QAC5B,uCACKA,SAAS;UACZC,OAAO,EAAE;QAAK;MAElB,CAAC,CAAC;MAEJ,IAAIa,MAAM,GAAyBhB,UAAU,CAACiB,MAAM,CAACL,mBAAmB,CAAC;MAEzE;MACAI,MAAM,GAAG,MAAME,OAAO,CAACC,GAAG,CACxBH,MAAM,CAACf,GAAG,CAAQC,SAAS,IAAIJ;QAC7B,MAAMsB,OAAO,GAAc,MAAM,IAAI,CAACC,kBAAkB,CAACC,6BAA6B,CACpFpB,SAAS,CACV;QAED,uCACKkB,OAAO;UACVjB,OAAO,EAAED,SAAS,CAACC;QAAO;MAE9B,CAAC,EAAC,CACH;MAED,IAAI,CAACJ,gBAAgB,GAAGiB,MAAM;MAE9B,OAAOA,MAAM;IACf,CAAC,EAAC;IA1EA,IAAIrB,mBAAmB,aAAnBA,mBAAmB,uBAAnBA,mBAAmB,CAAE4B,+BAA+B,EAAE;MACxD,IAAI,CAACC,sBAAsB,GAAG,IAAI5B,sBAAa,CAAC,eAAe,CAAC;KACjE,MAAM;MACL,IAAI,CAAC4B,sBAAsB,GAAG/B,OAAO;;EAEzC;EAEAgC,IAAI,CACFJ,kBAAuC,EACvCK,iBAAqC;IAErC,IAAI,CAACL,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACK,iBAAiB,GAAGA,iBAAiB;EAC5C;EA+DAC,qBAAqB;IACnB,IAAI,CAAC5B,gBAAgB,GAAG6B,SAAS;EACnC;EAEMC,YAAY,CAACnB,OAAe;;MAChC,MAAMR,SAAS,GAAG,CAAC,MAAM,IAAI,CAAC4B,aAAa,EAAE,EAAEC,IAAI,CAAE7B,SAAS,IAAI;QAChE,OACEM,sBAAa,CAACC,KAAK,CAACP,SAAS,CAACQ,OAAO,CAAC,CAACC,UAAU,KACjDH,sBAAa,CAACC,KAAK,CAACC,OAAO,CAAC,CAACC,UAAU;MAE3C,CAAC,CAAC;MAEF,IAAI,CAACT,SAAS,EAAE;QACd,MAAM,IAAI8B,mBAAU,CAClB,QAAQ,EACR,GAAG,EACH,8BAA8BtB,OAAO,EAAE,CACxC;;MAEH,OAAOR,SAAS;IAClB,CAAC;;EAEK+B,gBAAgB,CAACvB,OAAe;;MACpC,MAAMR,SAAS,GAAG,MAAM,IAAI,CAAC2B,YAAY,CAACnB,OAAO,CAAC;MAElD,IAAI,CAACR,SAAS,EAAE;QACd,MAAM,IAAI8B,mBAAU,CAClB,QAAQ,EACR,GAAG,EACH,8BAA8BtB,OAAO,EAAE,CACxC;;MAGH,OAAOR,SAAS,CAACgC,KAAK,CAACC,QAAQ;IACjC,CAAC;;EAEKC,YAAY,CAAC1B,OAAe;;MAChC,OACE,CAAC,MAAM,IAAI,CAACoB,aAAa,EAAE,EAAEC,IAAI,CAAE7B,SAAS,IAAI;QAC9C,OACEM,sBAAa,CAACC,KAAK,CAACP,SAAS,CAACQ,OAAO,CAAC,CAACC,UAAU,KACjDH,sBAAa,CAACC,KAAK,CAACC,OAAO,CAAC,CAACC,UAAU;MAE3C,CAAC,CAAC,IAAI,IAAI;IAEd,CAAC;;EAEK0B,gBAAgB,CACpBC,GAAQ,EACRpC,SAAoB,EACpBqC,MAAc;;MAEdrC,SAAS,GAAG,MAAMsC,uBAAe,CAACC,aAAa,CAACvC,SAAS,EAAE;QACzDwC,YAAY,EAAE;OACf,CAAC;MAEF,MAAM,IAAI,CAAChB,iBAAiB,CAACiB,WAAW,CACtCL,GAAG,EACH,gBAAgB,EAChBM,8BAAmB,CAACC,IAAI,EAAE,kCAErB3C,SAAS;QACZqC;MAAM,GAET;MAED,MAAM,IAAI,CAACO,YAAY,CAAC5C,SAAS,CAAC;IACpC,CAAC;;EAEKW,sBAAsB;;;MAC1B,OAAO,MACJ,MAAM,IAAI,CAACW,sBAAsB,CAACT,GAAG,CAAc,aAAa,CAAE,mCAAI,EAAE;;;EAIvE+B,YAAY,CAAC5C,SAAoB;;;MACrC,IAAI,MAAM,IAAI,CAACkC,YAAY,CAAClC,SAAS,CAACQ,OAAO,CAAC,EAAE;QAC9C,MAAM,IAAIsB,mBAAU,CAAC,QAAQ,EAAE,GAAG,EAAE,kCAAkC,CAAC;;MAGzE,MAAMe,eAAe,SAClB,MAAM,IAAI,CAACvB,sBAAsB,CAACT,GAAG,CAAc,aAAa,CAAE,mCAAI,EAAE;MAE3EgC,eAAe,CAACC,IAAI,CAAC9C,SAAS,CAAC;MAE/B,MAAM,IAAI,CAACsB,sBAAsB,CAACjB,GAAG,CACnC,aAAa,EACbwC,eAAe,CAChB;MAED,IAAI,CAACpB,qBAAqB,EAAE;;;EAGxBsB,eAAe,CAACvC,OAAe;;;MACnC,IAAI,EAAE,MAAM,IAAI,CAAC0B,YAAY,CAAC1B,OAAO,CAAC,CAAC,EAAE;QACvC,MAAM,IAAIsB,mBAAU,CAAC,QAAQ,EAAE,GAAG,EAAE,yBAAyB,CAAC;;MAGhE,IAAI,CAAC,MAAM,IAAI,CAACH,YAAY,CAACnB,OAAO,CAAC,EAAEP,OAAO,EAAE;QAC9C,MAAM,IAAI6B,mBAAU,CAAC,QAAQ,EAAE,GAAG,EAAE,iCAAiC,CAAC;;MAGxE,MAAMe,eAAe,SAClB,MAAM,IAAI,CAACvB,sBAAsB,CAACT,GAAG,CAAc,aAAa,CAAE,mCAAI,EAAE;MAE3E,MAAMmC,eAAe,GAAGH,eAAe,CAACjC,MAAM,CAAEZ,SAAS,IAAI;QAC3D,OACEM,sBAAa,CAACC,KAAK,CAACP,SAAS,CAACQ,OAAO,CAAC,CAACC,UAAU,KACjDH,sBAAa,CAACC,KAAK,CAACC,OAAO,CAAC,CAACC,UAAU;MAE3C,CAAC,CAAC;MAEF,MAAM,IAAI,CAACa,sBAAsB,CAACjB,GAAG,CACnC,aAAa,EACb2C,eAAe,CAChB;MAED;MACA,MAAM,IAAI,CAAC7B,kBAAkB,CAAC8B,oBAAoB,CAACzC,OAAO,CAAC;MAE3D,KAAK,MAAM0C,mBAAmB,IAAI,IAAI,CAACC,sBAAsB,EAAE;QAC7DD,mBAAmB,CAAC1C,OAAO,EAAEF,sBAAa,CAACC,KAAK,CAACC,OAAO,CAAC,CAACC,UAAU,CAAC;;MAGvE,IAAI,CAACgB,qBAAqB,EAAE;;;EAGxB2B,2BAA2B,CAC/B5C,OAAe;;;MAEf,MAAMR,SAAS,GAAG,MAAM,IAAI,CAAC2B,YAAY,CAACnB,OAAO,CAAC;MAClD,OAAO;QACL6C,OAAO,cAAErD,SAAS,CAACsD,QAAQ,0CAAEC,QAAQ,CAAC,iBAAiB,oCAAK,KAAK;QACjEC,OAAO,cAAExD,SAAS,CAACsD,QAAQ,0CAAEC,QAAQ,CAAC,cAAc,oCAAK;OAC1D;;;EAGHE,sBAAsB,CAACC,OAA4B;IACjD,IAAI,CAACP,sBAAsB,CAACL,IAAI,CAACY,OAAO,CAAC;EAC3C;;AAxOFC","names":["ChainsService","constructor","kvStore","embedChainInfos","experimentalOptions","common_1","promise","__awaiter","cachedChainInfos","chainInfos","map","chainInfo","embeded","embedChainInfoIdentifierMap","Map","embedChainInfo","set","cosmos_1","parse","chainId","identifier","suggestedChainInfos","getSuggestedChainInfos","filter","get","result","concat","Promise","all","updated","chainUpdaterKeeper","putUpdatedPropertyToChainInfo","useMemoryKVStoreForSuggestChain","kvStoreForSuggestChain","init","interactionKeeper","clearCachedChainInfos","undefined","getChainInfo","getChainInfos","find","router_1","getChainCoinType","bip44","coinType","hasChainInfo","suggestChainInfo","env","origin","types_1","validateAsync","stripUnknown","waitApprove","messages_1","type","addChainInfo","savedChainInfos","push","removeChainInfo","resultChainInfo","clearUpdatedProperty","chainRemovedHandler","onChainRemovedHandlers","getChainEthereumKeyFeatures","address","features","includes","signing","addChainRemovedHandler","handler","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/background/src/chains/service.ts"],"sourcesContent":["import { ChainInfoSchema, ChainInfoWithEmbed } from \"./types\";\nimport { ChainInfo } from \"@keplr-wallet/types\";\nimport { KVStore, Debouncer, MemoryKVStore } from \"@keplr-wallet/common\";\nimport { ChainUpdaterService } from \"../updater\";\nimport { InteractionService } from \"../interaction\";\nimport { Env, KeplrError } from \"@keplr-wallet/router\";\nimport { SuggestChainInfoMsg } from \"./messages\";\nimport { ChainIdHelper } from \"@keplr-wallet/cosmos\";\n\ntype ChainRemovedHandler = (chainId: string, identifier: string) => void;\n\nexport class ChainsService {\n  protected onChainRemovedHandlers: ChainRemovedHandler[] = [];\n\n  protected cachedChainInfos: ChainInfoWithEmbed[] | undefined;\n\n  protected chainUpdaterKeeper!: ChainUpdaterService;\n  protected interactionKeeper!: InteractionService;\n\n  protected readonly kvStoreForSuggestChain: KVStore;\n\n  constructor(\n    protected readonly kvStore: KVStore,\n    protected readonly embedChainInfos: ChainInfo[],\n    protected readonly experimentalOptions: Partial<{\n      useMemoryKVStoreForSuggestChain: boolean;\n    }> = {}\n  ) {\n    if (experimentalOptions?.useMemoryKVStoreForSuggestChain) {\n      this.kvStoreForSuggestChain = new MemoryKVStore(\"suggest-chain\");\n    } else {\n      this.kvStoreForSuggestChain = kvStore;\n    }\n  }\n\n  init(\n    chainUpdaterKeeper: ChainUpdaterService,\n    interactionKeeper: InteractionService\n  ) {\n    this.chainUpdaterKeeper = chainUpdaterKeeper;\n    this.interactionKeeper = interactionKeeper;\n  }\n\n  readonly getChainInfos: () => Promise<\n    ChainInfoWithEmbed[]\n  > = Debouncer.promise(async () => {\n    if (this.cachedChainInfos) {\n      return this.cachedChainInfos;\n    }\n\n    const chainInfos = this.embedChainInfos.map((chainInfo) => {\n      return {\n        ...chainInfo,\n        embeded: true,\n      };\n    });\n    const embedChainInfoIdentifierMap: Map<\n      string,\n      true | undefined\n    > = new Map();\n    for (const embedChainInfo of chainInfos) {\n      embedChainInfoIdentifierMap.set(\n        ChainIdHelper.parse(embedChainInfo.chainId).identifier,\n        true\n      );\n    }\n\n    const suggestedChainInfos: ChainInfoWithEmbed[] = (\n      await this.getSuggestedChainInfos()\n    )\n      .filter((chainInfo) => {\n        // Filter the overlaped chain info with the embeded chain infos.\n        return !embedChainInfoIdentifierMap.get(\n          ChainIdHelper.parse(chainInfo.chainId).identifier\n        );\n      })\n      .map((chainInfo: ChainInfo) => {\n        return {\n          ...chainInfo,\n          embeded: false,\n        };\n      });\n\n    let result: ChainInfoWithEmbed[] = chainInfos.concat(suggestedChainInfos);\n\n    // Set the updated property of the chain.\n    result = await Promise.all(\n      result.map(async (chainInfo) => {\n        const updated: ChainInfo = await this.chainUpdaterKeeper.putUpdatedPropertyToChainInfo(\n          chainInfo\n        );\n\n        return {\n          ...updated,\n          embeded: chainInfo.embeded,\n        };\n      })\n    );\n\n    this.cachedChainInfos = result;\n\n    return result;\n  });\n\n  clearCachedChainInfos() {\n    this.cachedChainInfos = undefined;\n  }\n\n  async getChainInfo(chainId: string): Promise<ChainInfoWithEmbed> {\n    const chainInfo = (await this.getChainInfos()).find((chainInfo) => {\n      return (\n        ChainIdHelper.parse(chainInfo.chainId).identifier ===\n        ChainIdHelper.parse(chainId).identifier\n      );\n    });\n\n    if (!chainInfo) {\n      throw new KeplrError(\n        \"chains\",\n        411,\n        `There is no chain info for ${chainId}`\n      );\n    }\n    return chainInfo;\n  }\n\n  async getChainCoinType(chainId: string): Promise<number> {\n    const chainInfo = await this.getChainInfo(chainId);\n\n    if (!chainInfo) {\n      throw new KeplrError(\n        \"chains\",\n        411,\n        `There is no chain info for ${chainId}`\n      );\n    }\n\n    return chainInfo.bip44.coinType;\n  }\n\n  async hasChainInfo(chainId: string): Promise<boolean> {\n    return (\n      (await this.getChainInfos()).find((chainInfo) => {\n        return (\n          ChainIdHelper.parse(chainInfo.chainId).identifier ===\n          ChainIdHelper.parse(chainId).identifier\n        );\n      }) != null\n    );\n  }\n\n  async suggestChainInfo(\n    env: Env,\n    chainInfo: ChainInfo,\n    origin: string\n  ): Promise<void> {\n    chainInfo = await ChainInfoSchema.validateAsync(chainInfo, {\n      stripUnknown: true,\n    });\n\n    await this.interactionKeeper.waitApprove(\n      env,\n      \"/suggest-chain\",\n      SuggestChainInfoMsg.type(),\n      {\n        ...chainInfo,\n        origin,\n      }\n    );\n\n    await this.addChainInfo(chainInfo);\n  }\n\n  async getSuggestedChainInfos(): Promise<ChainInfo[]> {\n    return (\n      (await this.kvStoreForSuggestChain.get<ChainInfo[]>(\"chain-infos\")) ?? []\n    );\n  }\n\n  async addChainInfo(chainInfo: ChainInfo): Promise<void> {\n    if (await this.hasChainInfo(chainInfo.chainId)) {\n      throw new KeplrError(\"chains\", 121, \"Same chain is already registered\");\n    }\n\n    const savedChainInfos =\n      (await this.kvStoreForSuggestChain.get<ChainInfo[]>(\"chain-infos\")) ?? [];\n\n    savedChainInfos.push(chainInfo);\n\n    await this.kvStoreForSuggestChain.set<ChainInfo[]>(\n      \"chain-infos\",\n      savedChainInfos\n    );\n\n    this.clearCachedChainInfos();\n  }\n\n  async removeChainInfo(chainId: string): Promise<void> {\n    if (!(await this.hasChainInfo(chainId))) {\n      throw new KeplrError(\"chains\", 120, \"Chain is not registered\");\n    }\n\n    if ((await this.getChainInfo(chainId)).embeded) {\n      throw new KeplrError(\"chains\", 122, \"Can't remove the embedded chain\");\n    }\n\n    const savedChainInfos =\n      (await this.kvStoreForSuggestChain.get<ChainInfo[]>(\"chain-infos\")) ?? [];\n\n    const resultChainInfo = savedChainInfos.filter((chainInfo) => {\n      return (\n        ChainIdHelper.parse(chainInfo.chainId).identifier !==\n        ChainIdHelper.parse(chainId).identifier\n      );\n    });\n\n    await this.kvStoreForSuggestChain.set<ChainInfo[]>(\n      \"chain-infos\",\n      resultChainInfo\n    );\n\n    // Clear the updated chain info.\n    await this.chainUpdaterKeeper.clearUpdatedProperty(chainId);\n\n    for (const chainRemovedHandler of this.onChainRemovedHandlers) {\n      chainRemovedHandler(chainId, ChainIdHelper.parse(chainId).identifier);\n    }\n\n    this.clearCachedChainInfos();\n  }\n\n  async getChainEthereumKeyFeatures(\n    chainId: string\n  ): Promise<{ address: boolean; signing: boolean }> {\n    const chainInfo = await this.getChainInfo(chainId);\n    return {\n      address: chainInfo.features?.includes(\"eth-address-gen\") ?? false,\n      signing: chainInfo.features?.includes(\"eth-key-sign\") ?? false,\n    };\n  }\n\n  addChainRemovedHandler(handler: ChainRemovedHandler) {\n    this.onChainRemovedHandlers.push(handler);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}