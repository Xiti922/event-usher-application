{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableQueryMap = exports.ObservableQuery = exports.ObservableQueryBase = exports.DeferInitialQueryController = exports.defaultOptions = void 0;\nconst mobx_1 = require(\"mobx\");\nconst axios_1 = __importDefault(require(\"axios\"));\nconst common_1 = require(\"@keplr-wallet/common\");\nconst map_1 = require(\"../map\");\nconst eventemitter3_1 = __importDefault(require(\"eventemitter3\"));\nexports.defaultOptions = {\n  cacheMaxAge: 0,\n  fetchingInterval: 0\n};\nclass FlowCancelerError extends Error {\n  constructor(m) {\n    super(m);\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, FlowCancelerError.prototype);\n  }\n}\nclass FlowCanceler {\n  constructor() {\n    this.rejectors = [];\n  }\n  get hasCancelable() {\n    return this.rejectors.length > 0;\n  }\n  cancel(message) {\n    while (this.rejectors.length > 0) {\n      const rejector = this.rejectors.shift();\n      if (rejector) {\n        rejector.reject(new FlowCancelerError(message));\n        if (rejector.onCancel) {\n          rejector.onCancel();\n        }\n      }\n    }\n  }\n  callOrCanceledWithPromise(promise, onCancel) {\n    return new Promise((resolve, reject) => {\n      this.rejectors.push({\n        reject,\n        onCancel\n      });\n      promise.then(r => {\n        const i = this.rejectors.findIndex(r => r.reject === reject);\n        if (i >= 0) {\n          this.rejectors.splice(i, 1);\n        }\n        resolve(r);\n      }, e => {\n        const i = this.rejectors.findIndex(r => r.reject === reject);\n        if (i >= 0) {\n          this.rejectors.splice(i, 1);\n        }\n        reject(e);\n      });\n    });\n  }\n  callOrCanceled(fn, onCancel) {\n    return new Promise((resolve, reject) => {\n      this.rejectors.push({\n        reject,\n        onCancel\n      });\n      Promise.resolve().then(() => {\n        if (!this.rejectors.find(r => r.reject === reject)) {\n          return;\n        }\n        fn().then(r => {\n          const i = this.rejectors.findIndex(r => r.reject === reject);\n          if (i >= 0) {\n            this.rejectors.splice(i, 1);\n          }\n          resolve(r);\n        }, e => {\n          const i = this.rejectors.findIndex(r => r.reject === reject);\n          if (i >= 0) {\n            this.rejectors.splice(i, 1);\n          }\n          reject(e);\n        });\n      });\n    });\n  }\n}\nclass DeferInitialQueryController {\n  constructor() {\n    this._isReady = false;\n    mobx_1.makeObservable(this);\n  }\n  ready() {\n    this._isReady = true;\n  }\n  wait() {\n    if (this.isReady) {\n      return Promise.resolve();\n    }\n    return new Promise(resolve => {\n      const disposer = mobx_1.autorun(() => {\n        if (this.isReady) {\n          resolve();\n          if (disposer) {\n            disposer();\n          }\n        }\n      });\n    });\n  }\n  get isReady() {\n    return this._isReady;\n  }\n}\n__decorate([mobx_1.observable], DeferInitialQueryController.prototype, \"_isReady\", void 0);\n__decorate([mobx_1.action], DeferInitialQueryController.prototype, \"ready\", null);\nexports.DeferInitialQueryController = DeferInitialQueryController;\n/**\n * Base of the observable query classes.\n * This recommends to use the Axios to query the response.\n */\nclass ObservableQueryBase {\n  constructor(instance, options) {\n    // Just use the oberable ref because the response is immutable and not directly adjusted.\n    this._response = undefined;\n    this._isFetching = false;\n    this._error = undefined;\n    this._isStarted = false;\n    this._pendingOnStart = false;\n    this.observedCount = 0;\n    // intervalId can be number or NodeJS's Timout object according to the environment.\n    // If environment is browser, intervalId should be number.\n    // If environment is NodeJS, intervalId should be NodeJS.Timeout.\n    this.intervalId = undefined;\n    this.becomeObserved = () => {\n      if (this.observedCount === 0) {\n        this.start();\n      }\n      this.observedCount++;\n    };\n    this.becomeUnobserved = () => {\n      this.observedCount--;\n      if (this.observedCount === 0) {\n        this.stop();\n      }\n    };\n    this.intervalFetch = () => {\n      if (!this.isFetching) {\n        this.fetch();\n      }\n    };\n    this.options = Object.assign(Object.assign({}, exports.defaultOptions), options);\n    this._instance = instance;\n    this.queryCanceler = new FlowCanceler();\n    this.onStartCanceler = new FlowCanceler();\n    this.queryControllerConceler = new FlowCanceler();\n    mobx_1.makeObservable(this);\n    mobx_1.onBecomeObserved(this, \"_response\", this.becomeObserved);\n    mobx_1.onBecomeObserved(this, \"_isFetching\", this.becomeObserved);\n    mobx_1.onBecomeObserved(this, \"_error\", this.becomeObserved);\n    mobx_1.onBecomeUnobserved(this, \"_response\", this.becomeUnobserved);\n    mobx_1.onBecomeUnobserved(this, \"_isFetching\", this.becomeUnobserved);\n    mobx_1.onBecomeUnobserved(this, \"_error\", this.becomeUnobserved);\n  }\n  static guessResponseTruncated(headers, data) {\n    return headers && typeof headers[\"content-type\"] === \"string\" && headers[\"content-type\"].startsWith(\"application/json\") && data.startsWith(\"{\");\n  }\n  get isObserved() {\n    return this.observedCount > 0;\n  }\n  start() {\n    if (!this._isStarted) {\n      this._isStarted = true;\n      const promise = this.onStart();\n      if (promise) {\n        this.handleAsyncOnStart(promise);\n      } else {\n        this.postStart();\n      }\n    }\n  }\n  *handleAsyncOnStart(promise) {\n    this._pendingOnStart = true;\n    this._isFetching = true;\n    try {\n      yield this.onStartCanceler.callOrCanceledWithPromise(promise);\n      if (this._isStarted) {\n        this._pendingOnStart = false;\n        this.postStart();\n      }\n    } catch (e) {\n      if (e instanceof FlowCancelerError) {\n        return;\n      }\n      throw e;\n    }\n  }\n  stop() {\n    if (this._isStarted) {\n      if (this.onStartCanceler.hasCancelable) {\n        this.onStartCanceler.cancel();\n      }\n      if (this.isFetching && this.queryCanceler.hasCancelable) {\n        this.cancel();\n      }\n      this._pendingOnStart = false;\n      this._isFetching = false;\n      if (this.intervalId != null) {\n        clearInterval(this.intervalId);\n      }\n      this.intervalId = undefined;\n      this.onStop();\n      this._isStarted = false;\n    }\n  }\n  get isStarted() {\n    return this._isStarted;\n  }\n  postStart() {\n    this.fetch();\n    if (this.options.fetchingInterval > 0) {\n      this.intervalId = setInterval(this.intervalFetch, this.options.fetchingInterval);\n    }\n  }\n  onStart() {\n    // noop yet.\n    // Override this if you need something to do whenever starting.\n  }\n  onStop() {\n    // noop yet.\n    // Override this if you need something to do whenever starting.\n  }\n  canFetch() {\n    return true;\n  }\n  get isFetching() {\n    return this._isFetching;\n  }\n  // Return the instance.\n  // You can memorize this by using @computed if you need to override this.\n  // NOTE: If this getter returns the different instance with previous instance.\n  // It will be used in the latter fetching.\n  get instance() {\n    return this._instance;\n  }\n  *fetch() {\n    var _a, _b, _c;\n    // If not started, do nothing.\n    if (!this.isStarted || this._pendingOnStart) {\n      return;\n    }\n    if (ObservableQueryBase.experimentalDeferInitialQueryController && !ObservableQueryBase.experimentalDeferInitialQueryController.isReady) {\n      this._isFetching = true;\n      if (this.queryControllerConceler.hasCancelable) {\n        this.queryControllerConceler.cancel();\n      }\n      try {\n        yield this.queryControllerConceler.callOrCanceled(() => {\n          var _a, _b;\n          return (_b = (_a = ObservableQueryBase.experimentalDeferInitialQueryController) === null || _a === void 0 ? void 0 : _a.wait()) !== null && _b !== void 0 ? _b : Promise.resolve();\n        });\n      } catch (e) {\n        if (e instanceof FlowCancelerError) {\n          return;\n        }\n        throw e;\n      }\n      // Recheck\n      if (!this.isStarted) {\n        return;\n      }\n    }\n    if (!this.canFetch()) {\n      return;\n    }\n    // If response is fetching, cancel the previous query.\n    if (this.isFetching && this.queryCanceler.hasCancelable) {\n      // When cancel for the next fetching, it behaves differently from other explicit cancels because fetching continues. Use an error message to identify this.\n      this.cancel(\"__fetching__proceed__next__\");\n    }\n    // If there is no existing response, try to load saved reponse.\n    if (!this._response) {\n      this._isFetching = true;\n      const promise = this.loadStaledResponse();\n      const handleStaledResponse = staledResponse => {\n        if (staledResponse && !this._response) {\n          if (this.options.cacheMaxAge <= 0 || staledResponse.timestamp > Date.now() - this.options.cacheMaxAge) {\n            this.setResponse(staledResponse);\n            return true;\n          }\n        }\n        return false;\n      };\n      // When first load, try to load the last response from disk.\n      // Use the last saved response if the last saved response exists and the current response hasn't been set yet.\n      if (this.options.cacheMaxAge <= 0) {\n        // To improve performance, don't wait the loading to proceed if cache age not set.\n        promise.then(staledResponse => {\n          handleStaledResponse(staledResponse);\n        });\n      } else {\n        const staledResponse = yield* common_1.toGenerator(promise);\n        if (handleStaledResponse(staledResponse)) {\n          this._isFetching = false;\n          return;\n        }\n      }\n    } else {\n      if (this.options.cacheMaxAge > 0) {\n        if (this._response.timestamp > Date.now() - this.options.cacheMaxAge) {\n          this._isFetching = false;\n          return;\n        }\n      }\n      this._isFetching = true;\n      // Make the existing response as staled.\n      this.setResponse(Object.assign(Object.assign({}, this._response), {\n        staled: true\n      }));\n    }\n    const abortController = new AbortController();\n    let fetchingProceedNext = false;\n    let skipAxiosCancelError = false;\n    try {\n      let hasStarted = false;\n      let {\n        response,\n        headers\n      } = yield* common_1.toGenerator(this.queryCanceler.callOrCanceled(() => {\n        hasStarted = true;\n        return this.fetchResponse(abortController);\n      }, () => {\n        if (hasStarted) {\n          abortController.abort();\n        }\n      }));\n      if (response.data && typeof response.data === \"string\" && (response.data.startsWith(\"stream was reset:\") || ObservableQuery.suspectedResponseDatasWithInvalidValue.includes(response.data) || ObservableQuery.guessResponseTruncated(headers, response.data))) {\n        // In some devices, it is a http ok code, but a strange response is sometimes returned.\n        // It's not that they can't query at all, it seems that they get weird response from time to time.\n        // These causes are not clear.\n        // To solve this problem, if this problem occurs, try the query again, and if that fails, an error is raised.\n        // https://github.com/chainapsis/keplr-wallet/issues/275\n        // https://github.com/chainapsis/keplr-wallet/issues/278\n        // https://github.com/chainapsis/keplr-wallet/issues/318\n        if (abortController.signal.aborted) {\n          // In this case, it is assumed that it is caused by cancel() and do nothing.\n          return;\n        }\n        console.log(\"There is an unknown problem to the response. Request one more time.\");\n        // Try to query again.\n        let hasStarted = false;\n        const refetched = yield* common_1.toGenerator(this.queryCanceler.callOrCanceled(() => {\n          hasStarted = true;\n          return this.fetchResponse(abortController);\n        }, () => {\n          if (hasStarted) {\n            abortController.abort();\n          }\n        }));\n        response = refetched.response;\n        headers = refetched.headers;\n        if (response.data && typeof response.data === \"string\") {\n          if (response.data.startsWith(\"stream was reset:\") || ObservableQuery.suspectedResponseDatasWithInvalidValue.includes(response.data)) {\n            throw new Error(response.data);\n          }\n          if (ObservableQuery.guessResponseTruncated(headers, response.data)) {\n            throw new Error(\"The response data seems to be truncated\");\n          }\n        }\n      }\n      this.setResponse(response);\n      // Clear the error if fetching succeeds.\n      this.setError(undefined);\n      // Should not wait.\n      this.saveResponse(response);\n    } catch (e) {\n      // If axios canceled, do nothing.\n      if (axios_1.default.isCancel(e)) {\n        skipAxiosCancelError = true;\n        return;\n      }\n      if (e instanceof FlowCancelerError) {\n        // When cancel for the next fetching, it behaves differently from other explicit cancels because fetching continues.\n        if (e.message === \"__fetching__proceed__next__\") {\n          fetchingProceedNext = true;\n        }\n        return;\n      }\n      // If error is from Axios, and get response.\n      if (e.response) {\n        // Default is status text\n        let message = e.response.statusText;\n        const contentType = typeof ((_a = e.response.headers) === null || _a === void 0 ? void 0 : _a[\"content-type\"]) === \"string\" ? e.response.headers[\"content-type\"] : \"\";\n        // Try to figure out the message from the response.\n        // If the contentType in the header is specified, try to use the message from the response.\n        if (contentType.startsWith(\"text/plain\") && typeof e.response.data === \"string\") {\n          message = e.response.data;\n        }\n        // If the response is an object and \"message\" field exists, it is used as a message.\n        if (contentType.startsWith(\"application/json\") && ((_b = e.response.data) === null || _b === void 0 ? void 0 : _b.message) && typeof ((_c = e.response.data) === null || _c === void 0 ? void 0 : _c.message) === \"string\") {\n          message = e.response.data.message;\n        }\n        const error = {\n          status: e.response.status,\n          statusText: e.response.statusText,\n          message,\n          data: e.response.data\n        };\n        this.setError(error);\n      } else if (e.request) {\n        // if can't get the response.\n        const error = {\n          status: 0,\n          statusText: \"Failed to get response\",\n          message: \"Failed to get response\"\n        };\n        this.setError(error);\n      } else {\n        const error = {\n          status: 0,\n          statusText: e.message,\n          message: e.message,\n          data: e\n        };\n        this.setError(error);\n      }\n    } finally {\n      if (!skipAxiosCancelError) {\n        if (!fetchingProceedNext) {\n          this._isFetching = false;\n        }\n      }\n    }\n  }\n  get response() {\n    return this._response;\n  }\n  get error() {\n    return this._error;\n  }\n  setResponse(response) {\n    this._response = response;\n  }\n  setError(error) {\n    this._error = error;\n  }\n  cancel(message) {\n    this.queryCanceler.cancel(message);\n  }\n  /**\n   * Wait the response and return the response without considering it is staled or fresh.\n   */\n  waitResponse() {\n    if (this.response) {\n      return Promise.resolve(this.response);\n    }\n    const disposers = [];\n    let onceCoerce = false;\n    // Make sure that the fetching is tracked to force to be fetched.\n    disposers.push(mobx_1.reaction(() => this.isFetching, () => {\n      if (!onceCoerce) {\n        if (!this.isFetching) {\n          this.fetch();\n        }\n        onceCoerce = true;\n      }\n    }, {\n      fireImmediately: true\n    }));\n    return new Promise(resolve => {\n      const disposer = mobx_1.autorun(() => {\n        if (!this.isFetching) {\n          resolve(this.response);\n        }\n      });\n      disposers.push(disposer);\n    }).finally(() => {\n      for (const disposer of disposers) {\n        disposer();\n      }\n    });\n  }\n  /**\n   * Wait the response and return the response until it is fetched.\n   */\n  waitFreshResponse() {\n    const disposers = [];\n    let onceCoerce = false;\n    // Make sure that the fetching is tracked to force to be fetched.\n    disposers.push(mobx_1.reaction(() => this.isFetching, () => {\n      if (!onceCoerce) {\n        if (!this.isFetching) {\n          this.fetch();\n        }\n        onceCoerce = true;\n      }\n    }, {\n      fireImmediately: true\n    }));\n    return new Promise(resolve => {\n      const disposer = mobx_1.autorun(() => {\n        if (!this.isFetching) {\n          resolve(this.response);\n        }\n      });\n      disposers.push(disposer);\n    }).finally(() => {\n      for (const disposer of disposers) {\n        disposer();\n      }\n    });\n  }\n}\n/**\n * Allows to decide when to start the first query.\n *\n * This is a temporarily added feature to implement custom rpc/lcd feature in keplr extension or mobile.\n * Because custom rpc/lcd are handled in the background process and the front-end cannot synchronously get those values,\n * Rather than not showing the UI to the user during the delay, the UI is shown and the start of the query is delayed immediately after getting those values.\n *\n * XXX: Having a global field for this feature doesn't seem desirable in the long run.\n *      Unless it's a keplr extension or mobile, you don't need to care about this field.\n *      This field will soon be removed and can be replaced by other implementation.\n *\n */\nObservableQueryBase.experimentalDeferInitialQueryController = undefined;\nObservableQueryBase.suspectedResponseDatasWithInvalidValue = [\"The network connection was lost.\", \"The request timed out.\"];\n__decorate([mobx_1.observable.ref], ObservableQueryBase.prototype, \"_response\", void 0);\n__decorate([mobx_1.observable], ObservableQueryBase.prototype, \"_isFetching\", void 0);\n__decorate([mobx_1.observable.ref], ObservableQueryBase.prototype, \"_error\", void 0);\n__decorate([mobx_1.observable], ObservableQueryBase.prototype, \"_isStarted\", void 0);\n__decorate([mobx_1.observable.ref], ObservableQueryBase.prototype, \"_instance\", void 0);\n__decorate([mobx_1.action], ObservableQueryBase.prototype, \"start\", null);\n__decorate([mobx_1.flow], ObservableQueryBase.prototype, \"handleAsyncOnStart\", null);\n__decorate([mobx_1.action], ObservableQueryBase.prototype, \"stop\", null);\n__decorate([mobx_1.computed], ObservableQueryBase.prototype, \"instance\", null);\n__decorate([mobx_1.flow], ObservableQueryBase.prototype, \"fetch\", null);\n__decorate([mobx_1.action], ObservableQueryBase.prototype, \"setResponse\", null);\n__decorate([mobx_1.action], ObservableQueryBase.prototype, \"setError\", null);\nexports.ObservableQueryBase = ObservableQueryBase;\n/**\n * ObservableQuery defines the event class to query the result from endpoint.\n * This supports the stale state if previous query exists.\n */\nclass ObservableQuery extends ObservableQueryBase {\n  constructor(kvStore, instance, url) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(instance, options);\n    this.kvStore = kvStore;\n    this._url = \"\";\n    this.refreshHandler = data => {\n      const ifError = data === null || data === void 0 ? void 0 : data.ifError;\n      if (ifError) {\n        if (this.error) {\n          this.fetch();\n        }\n      } else {\n        this.fetch();\n      }\n    };\n    mobx_1.makeObservable(this);\n    this.setUrl(url);\n  }\n  static refreshAllObserved() {\n    ObservableQuery.eventListener.emit(\"refresh\");\n  }\n  static refreshAllObservedIfError() {\n    ObservableQuery.eventListener.emit(\"refresh\", {\n      ifError: true\n    });\n  }\n  onStart() {\n    super.onStart();\n    ObservableQuery.eventListener.addListener(\"refresh\", this.refreshHandler);\n  }\n  onStop() {\n    super.onStop();\n    ObservableQuery.eventListener.addListener(\"refresh\", this.refreshHandler);\n  }\n  get url() {\n    return this._url;\n  }\n  setUrl(url) {\n    if (this._url !== url) {\n      this._url = url;\n      this.fetch();\n    }\n  }\n  fetchResponse(abortController) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = yield this.instance.get(this.url, {\n        signal: abortController.signal\n      });\n      return {\n        headers: result.headers,\n        response: {\n          data: result.data,\n          status: result.status,\n          staled: false,\n          timestamp: Date.now()\n        }\n      };\n    });\n  }\n  getCacheKey() {\n    return `${this.instance.name}-${this.instance.defaults.baseURL}${this.instance.getUri({\n      url: this.url\n    })}`;\n  }\n  saveResponse(response) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const key = this.getCacheKey();\n      yield this.kvStore.set(key, response);\n    });\n  }\n  loadStaledResponse() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const key = this.getCacheKey();\n      const response = yield this.kvStore.get(key);\n      if (response) {\n        return Object.assign(Object.assign({}, response), {\n          staled: true\n        });\n      }\n      return undefined;\n    });\n  }\n}\nObservableQuery.eventListener = new eventemitter3_1.default();\n__decorate([mobx_1.observable], ObservableQuery.prototype, \"_url\", void 0);\n__decorate([mobx_1.action], ObservableQuery.prototype, \"setUrl\", null);\nexports.ObservableQuery = ObservableQuery;\nclass ObservableQueryMap extends map_1.HasMapStore {\n  constructor(creater) {\n    super(creater);\n  }\n}\nexports.ObservableQueryMap = ObservableQueryMap;","map":{"version":3,"mappings":"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","names":["exports","cacheMaxAge","fetchingInterval","FlowCancelerError","Error","constructor","m","Object","setPrototypeOf","prototype","FlowCanceler","hasCancelable","rejectors","length","cancel","message","rejector","shift","reject","onCancel","callOrCanceledWithPromise","promise","Promise","resolve","push","then","r","i","findIndex","splice","e","callOrCanceled","fn","find","DeferInitialQueryController","mobx_1","ready","_isReady","wait","isReady","disposer","__decorate","ObservableQueryBase","instance","options","undefined","observedCount","start","stop","isFetching","fetch","_instance","queryCanceler","onStartCanceler","queryControllerConceler","becomeObserved","becomeUnobserved","guessResponseTruncated","headers","data","startsWith","isObserved","_isStarted","onStart","handleAsyncOnStart","postStart","_pendingOnStart","_isFetching","intervalId","clearInterval","onStop","isStarted","setInterval","intervalFetch","canFetch","experimentalDeferInitialQueryController","_response","loadStaledResponse","handleStaledResponse","staledResponse","timestamp","Date","now","setResponse","common_1","staled","abortController","AbortController","fetchingProceedNext","skipAxiosCancelError","hasStarted","response","fetchResponse","abort","ObservableQuery","suspectedResponseDatasWithInvalidValue","includes","signal","aborted","console","log","refetched","setError","saveResponse","axios_1","isCancel","statusText","contentType","error","status","request","_error","waitResponse","disposers","onceCoerce","fireImmediately","finally","waitFreshResponse","ref","kvStore","url","ifError","setUrl","refreshAllObserved","eventListener","emit","refreshAllObservedIfError","addListener","refreshHandler","_url","result","get","getCacheKey","name","defaults","baseURL","getUri","key","set","eventemitter3_1","ObservableQueryMap","map_1","creater"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/common/query/query.ts"],"sourcesContent":["import {\n  action,\n  autorun,\n  computed,\n  flow,\n  makeObservable,\n  observable,\n  onBecomeObserved,\n  onBecomeUnobserved,\n  reaction,\n} from \"mobx\";\nimport Axios, { AxiosInstance } from \"axios\";\nimport { KVStore, toGenerator } from \"@keplr-wallet/common\";\nimport { DeepReadonly } from \"utility-types\";\nimport { HasMapStore } from \"../map\";\nimport EventEmitter from \"eventemitter3\";\n\nexport type QueryOptions = {\n  // millisec\n  readonly cacheMaxAge: number;\n  // millisec\n  readonly fetchingInterval: number;\n};\n\nexport const defaultOptions: QueryOptions = {\n  cacheMaxAge: 0,\n  fetchingInterval: 0,\n};\n\nexport type QueryError<E> = {\n  status: number;\n  statusText: string;\n  message: string;\n  data?: E;\n};\n\nexport type QueryResponse<T> = {\n  status: number;\n  data: T;\n  staled: boolean;\n  timestamp: number;\n};\n\nclass FlowCancelerError extends Error {\n  constructor(m?: string) {\n    super(m);\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, FlowCancelerError.prototype);\n  }\n}\n\nclass FlowCanceler {\n  protected rejectors: {\n    reject: (e: Error) => void;\n    onCancel?: () => void;\n  }[] = [];\n\n  get hasCancelable(): boolean {\n    return this.rejectors.length > 0;\n  }\n\n  cancel(message?: string) {\n    while (this.rejectors.length > 0) {\n      const rejector = this.rejectors.shift();\n      if (rejector) {\n        rejector.reject(new FlowCancelerError(message));\n        if (rejector.onCancel) {\n          rejector.onCancel();\n        }\n      }\n    }\n  }\n\n  callOrCanceledWithPromise<R>(\n    promise: PromiseLike<R>,\n    onCancel?: () => void\n  ): Promise<R> {\n    return new Promise<R>((resolve, reject) => {\n      this.rejectors.push({\n        reject,\n        onCancel,\n      });\n\n      promise.then(\n        (r) => {\n          const i = this.rejectors.findIndex((r) => r.reject === reject);\n          if (i >= 0) {\n            this.rejectors.splice(i, 1);\n          }\n\n          resolve(r);\n        },\n        (e) => {\n          const i = this.rejectors.findIndex((r) => r.reject === reject);\n          if (i >= 0) {\n            this.rejectors.splice(i, 1);\n          }\n\n          reject(e);\n        }\n      );\n    });\n  }\n\n  callOrCanceled<R>(\n    fn: () => PromiseLike<R>,\n    onCancel?: () => void\n  ): Promise<R> {\n    return new Promise<R>((resolve, reject) => {\n      this.rejectors.push({\n        reject,\n        onCancel,\n      });\n\n      Promise.resolve().then(() => {\n        if (!this.rejectors.find((r) => r.reject === reject)) {\n          return;\n        }\n\n        fn().then(\n          (r) => {\n            const i = this.rejectors.findIndex((r) => r.reject === reject);\n            if (i >= 0) {\n              this.rejectors.splice(i, 1);\n            }\n\n            resolve(r);\n          },\n          (e) => {\n            const i = this.rejectors.findIndex((r) => r.reject === reject);\n            if (i >= 0) {\n              this.rejectors.splice(i, 1);\n            }\n\n            reject(e);\n          }\n        );\n      });\n    });\n  }\n}\n\nexport class DeferInitialQueryController {\n  @observable\n  protected _isReady: boolean = false;\n\n  constructor() {\n    makeObservable(this);\n  }\n\n  @action\n  ready() {\n    this._isReady = true;\n  }\n\n  wait(): Promise<void> {\n    if (this.isReady) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve) => {\n      const disposer = autorun(() => {\n        if (this.isReady) {\n          resolve();\n          if (disposer) {\n            disposer();\n          }\n        }\n      });\n    });\n  }\n\n  get isReady(): boolean {\n    return this._isReady;\n  }\n}\n\n/**\n * Base of the observable query classes.\n * This recommends to use the Axios to query the response.\n */\nexport abstract class ObservableQueryBase<T = unknown, E = unknown> {\n  /**\n   * Allows to decide when to start the first query.\n   *\n   * This is a temporarily added feature to implement custom rpc/lcd feature in keplr extension or mobile.\n   * Because custom rpc/lcd are handled in the background process and the front-end cannot synchronously get those values,\n   * Rather than not showing the UI to the user during the delay, the UI is shown and the start of the query is delayed immediately after getting those values.\n   *\n   * XXX: Having a global field for this feature doesn't seem desirable in the long run.\n   *      Unless it's a keplr extension or mobile, you don't need to care about this field.\n   *      This field will soon be removed and can be replaced by other implementation.\n   *\n   */\n  public static experimentalDeferInitialQueryController:\n    | DeferInitialQueryController\n    | undefined = undefined;\n\n  protected static suspectedResponseDatasWithInvalidValue: string[] = [\n    \"The network connection was lost.\",\n    \"The request timed out.\",\n  ];\n\n  protected static guessResponseTruncated(headers: any, data: string): boolean {\n    return (\n      headers &&\n      typeof headers[\"content-type\"] === \"string\" &&\n      headers[\"content-type\"].startsWith(\"application/json\") &&\n      data.startsWith(\"{\")\n    );\n  }\n\n  protected readonly options: QueryOptions;\n\n  // Just use the oberable ref because the response is immutable and not directly adjusted.\n  @observable.ref\n  private _response?: Readonly<QueryResponse<T>> = undefined;\n\n  @observable\n  protected _isFetching: boolean = false;\n\n  @observable.ref\n  private _error?: Readonly<QueryError<E>> = undefined;\n\n  @observable\n  private _isStarted: boolean = false;\n\n  private _pendingOnStart: boolean = false;\n\n  private readonly queryCanceler: FlowCanceler;\n  private readonly onStartCanceler: FlowCanceler;\n  private readonly queryControllerConceler: FlowCanceler;\n\n  private observedCount: number = 0;\n\n  // intervalId can be number or NodeJS's Timout object according to the environment.\n  // If environment is browser, intervalId should be number.\n  // If environment is NodeJS, intervalId should be NodeJS.Timeout.\n  private intervalId: number | NodeJS.Timeout | undefined = undefined;\n\n  @observable.ref\n  protected _instance: AxiosInstance;\n\n  protected constructor(\n    instance: AxiosInstance,\n    options: Partial<QueryOptions>\n  ) {\n    this.options = {\n      ...defaultOptions,\n      ...options,\n    };\n\n    this._instance = instance;\n\n    this.queryCanceler = new FlowCanceler();\n    this.onStartCanceler = new FlowCanceler();\n    this.queryControllerConceler = new FlowCanceler();\n\n    makeObservable(this);\n\n    onBecomeObserved(this, \"_response\", this.becomeObserved);\n    onBecomeObserved(this, \"_isFetching\", this.becomeObserved);\n    onBecomeObserved(this, \"_error\", this.becomeObserved);\n\n    onBecomeUnobserved(this, \"_response\", this.becomeUnobserved);\n    onBecomeUnobserved(this, \"_isFetching\", this.becomeUnobserved);\n    onBecomeUnobserved(this, \"_error\", this.becomeUnobserved);\n  }\n\n  private becomeObserved = (): void => {\n    if (this.observedCount === 0) {\n      this.start();\n    }\n    this.observedCount++;\n  };\n\n  private becomeUnobserved = (): void => {\n    this.observedCount--;\n    if (this.observedCount === 0) {\n      this.stop();\n    }\n  };\n\n  public get isObserved(): boolean {\n    return this.observedCount > 0;\n  }\n\n  @action\n  private start() {\n    if (!this._isStarted) {\n      this._isStarted = true;\n      const promise = this.onStart();\n      if (promise) {\n        this.handleAsyncOnStart(promise);\n      } else {\n        this.postStart();\n      }\n    }\n  }\n\n  @flow\n  private *handleAsyncOnStart(promise: PromiseLike<void>) {\n    this._pendingOnStart = true;\n    this._isFetching = true;\n\n    try {\n      yield this.onStartCanceler.callOrCanceledWithPromise(promise);\n      if (this._isStarted) {\n        this._pendingOnStart = false;\n        this.postStart();\n      }\n    } catch (e) {\n      if (e instanceof FlowCancelerError) {\n        return;\n      }\n      throw e;\n    }\n  }\n\n  @action\n  private stop() {\n    if (this._isStarted) {\n      if (this.onStartCanceler.hasCancelable) {\n        this.onStartCanceler.cancel();\n      }\n\n      if (this.isFetching && this.queryCanceler.hasCancelable) {\n        this.cancel();\n      }\n\n      this._pendingOnStart = false;\n      this._isFetching = false;\n\n      if (this.intervalId != null) {\n        clearInterval(this.intervalId as NodeJS.Timeout);\n      }\n      this.intervalId = undefined;\n\n      this.onStop();\n      this._isStarted = false;\n    }\n  }\n\n  public get isStarted(): boolean {\n    return this._isStarted;\n  }\n\n  private readonly intervalFetch = () => {\n    if (!this.isFetching) {\n      this.fetch();\n    }\n  };\n\n  private postStart() {\n    this.fetch();\n\n    if (this.options.fetchingInterval > 0) {\n      this.intervalId = setInterval(\n        this.intervalFetch,\n        this.options.fetchingInterval\n      );\n    }\n  }\n\n  protected onStart(): void | Promise<void> {\n    // noop yet.\n    // Override this if you need something to do whenever starting.\n  }\n\n  protected onStop() {\n    // noop yet.\n    // Override this if you need something to do whenever starting.\n  }\n\n  protected canFetch(): boolean {\n    return true;\n  }\n\n  get isFetching(): boolean {\n    return this._isFetching;\n  }\n\n  // Return the instance.\n  // You can memorize this by using @computed if you need to override this.\n  // NOTE: If this getter returns the different instance with previous instance.\n  // It will be used in the latter fetching.\n  @computed\n  protected get instance(): DeepReadonly<AxiosInstance> {\n    return this._instance;\n  }\n\n  @flow\n  *fetch(): Generator<unknown, any, any> {\n    // If not started, do nothing.\n    if (!this.isStarted || this._pendingOnStart) {\n      return;\n    }\n\n    if (\n      ObservableQueryBase.experimentalDeferInitialQueryController &&\n      !ObservableQueryBase.experimentalDeferInitialQueryController.isReady\n    ) {\n      this._isFetching = true;\n\n      if (this.queryControllerConceler.hasCancelable) {\n        this.queryControllerConceler.cancel();\n      }\n\n      try {\n        yield this.queryControllerConceler.callOrCanceled(\n          () =>\n            ObservableQueryBase.experimentalDeferInitialQueryController?.wait() ??\n            Promise.resolve()\n        );\n      } catch (e) {\n        if (e instanceof FlowCancelerError) {\n          return;\n        }\n        throw e;\n      }\n\n      // Recheck\n      if (!this.isStarted) {\n        return;\n      }\n    }\n    if (!this.canFetch()) {\n      return;\n    }\n\n    // If response is fetching, cancel the previous query.\n    if (this.isFetching && this.queryCanceler.hasCancelable) {\n      // When cancel for the next fetching, it behaves differently from other explicit cancels because fetching continues. Use an error message to identify this.\n      this.cancel(\"__fetching__proceed__next__\");\n    }\n\n    // If there is no existing response, try to load saved reponse.\n    if (!this._response) {\n      this._isFetching = true;\n\n      const promise = this.loadStaledResponse();\n\n      const handleStaledResponse = (\n        staledResponse: QueryResponse<T> | undefined\n      ) => {\n        if (staledResponse && !this._response) {\n          if (\n            this.options.cacheMaxAge <= 0 ||\n            staledResponse.timestamp > Date.now() - this.options.cacheMaxAge\n          ) {\n            this.setResponse(staledResponse);\n            return true;\n          }\n        }\n        return false;\n      };\n\n      // When first load, try to load the last response from disk.\n      // Use the last saved response if the last saved response exists and the current response hasn't been set yet.\n      if (this.options.cacheMaxAge <= 0) {\n        // To improve performance, don't wait the loading to proceed if cache age not set.\n        promise.then((staledResponse) => {\n          handleStaledResponse(staledResponse);\n        });\n      } else {\n        const staledResponse = yield* toGenerator(promise);\n        if (handleStaledResponse(staledResponse)) {\n          this._isFetching = false;\n          return;\n        }\n      }\n    } else {\n      if (this.options.cacheMaxAge > 0) {\n        if (this._response.timestamp > Date.now() - this.options.cacheMaxAge) {\n          this._isFetching = false;\n          return;\n        }\n      }\n\n      this._isFetching = true;\n\n      // Make the existing response as staled.\n      this.setResponse({\n        ...this._response,\n        staled: true,\n      });\n    }\n\n    const abortController = new AbortController();\n\n    let fetchingProceedNext = false;\n    let skipAxiosCancelError = false;\n\n    try {\n      let hasStarted = false;\n      let { response, headers } = yield* toGenerator(\n        this.queryCanceler.callOrCanceled(\n          () => {\n            hasStarted = true;\n            return this.fetchResponse(abortController);\n          },\n          () => {\n            if (hasStarted) {\n              abortController.abort();\n            }\n          }\n        )\n      );\n      if (\n        response.data &&\n        typeof response.data === \"string\" &&\n        (response.data.startsWith(\"stream was reset:\") ||\n          ObservableQuery.suspectedResponseDatasWithInvalidValue.includes(\n            response.data\n          ) ||\n          ObservableQuery.guessResponseTruncated(headers, response.data))\n      ) {\n        // In some devices, it is a http ok code, but a strange response is sometimes returned.\n        // It's not that they can't query at all, it seems that they get weird response from time to time.\n        // These causes are not clear.\n        // To solve this problem, if this problem occurs, try the query again, and if that fails, an error is raised.\n        // https://github.com/chainapsis/keplr-wallet/issues/275\n        // https://github.com/chainapsis/keplr-wallet/issues/278\n        // https://github.com/chainapsis/keplr-wallet/issues/318\n        if (abortController.signal.aborted) {\n          // In this case, it is assumed that it is caused by cancel() and do nothing.\n          return;\n        }\n\n        console.log(\n          \"There is an unknown problem to the response. Request one more time.\"\n        );\n\n        // Try to query again.\n        let hasStarted = false;\n        const refetched = yield* toGenerator(\n          this.queryCanceler.callOrCanceled(\n            () => {\n              hasStarted = true;\n              return this.fetchResponse(abortController);\n            },\n            () => {\n              if (hasStarted) {\n                abortController.abort();\n              }\n            }\n          )\n        );\n        response = refetched.response;\n        headers = refetched.headers;\n\n        if (response.data && typeof response.data === \"string\") {\n          if (\n            response.data.startsWith(\"stream was reset:\") ||\n            ObservableQuery.suspectedResponseDatasWithInvalidValue.includes(\n              response.data\n            )\n          ) {\n            throw new Error(response.data);\n          }\n\n          if (ObservableQuery.guessResponseTruncated(headers, response.data)) {\n            throw new Error(\"The response data seems to be truncated\");\n          }\n        }\n      }\n      this.setResponse(response);\n      // Clear the error if fetching succeeds.\n      this.setError(undefined);\n\n      // Should not wait.\n      this.saveResponse(response);\n    } catch (e) {\n      // If axios canceled, do nothing.\n      if (Axios.isCancel(e)) {\n        skipAxiosCancelError = true;\n        return;\n      }\n\n      if (e instanceof FlowCancelerError) {\n        // When cancel for the next fetching, it behaves differently from other explicit cancels because fetching continues.\n        if (e.message === \"__fetching__proceed__next__\") {\n          fetchingProceedNext = true;\n        }\n        return;\n      }\n\n      // If error is from Axios, and get response.\n      if (e.response) {\n        // Default is status text\n        let message: string = e.response.statusText;\n        const contentType: string =\n          typeof e.response.headers?.[\"content-type\"] === \"string\"\n            ? e.response.headers[\"content-type\"]\n            : \"\";\n        // Try to figure out the message from the response.\n        // If the contentType in the header is specified, try to use the message from the response.\n        if (\n          contentType.startsWith(\"text/plain\") &&\n          typeof e.response.data === \"string\"\n        ) {\n          message = e.response.data;\n        }\n        // If the response is an object and \"message\" field exists, it is used as a message.\n        if (\n          contentType.startsWith(\"application/json\") &&\n          e.response.data?.message &&\n          typeof e.response.data?.message === \"string\"\n        ) {\n          message = e.response.data.message;\n        }\n\n        const error: QueryError<E> = {\n          status: e.response.status,\n          statusText: e.response.statusText,\n          message,\n          data: e.response.data,\n        };\n\n        this.setError(error);\n      } else if (e.request) {\n        // if can't get the response.\n        const error: QueryError<E> = {\n          status: 0,\n          statusText: \"Failed to get response\",\n          message: \"Failed to get response\",\n        };\n\n        this.setError(error);\n      } else {\n        const error: QueryError<E> = {\n          status: 0,\n          statusText: e.message,\n          message: e.message,\n          data: e,\n        };\n\n        this.setError(error);\n      }\n    } finally {\n      if (!skipAxiosCancelError) {\n        if (!fetchingProceedNext) {\n          this._isFetching = false;\n        }\n      }\n    }\n  }\n\n  public get response() {\n    return this._response;\n  }\n\n  public get error() {\n    return this._error;\n  }\n\n  @action\n  protected setResponse(response: Readonly<QueryResponse<T>>) {\n    this._response = response;\n  }\n\n  @action\n  protected setError(error: QueryError<E> | undefined) {\n    this._error = error;\n  }\n\n  private cancel(message?: string): void {\n    this.queryCanceler.cancel(message);\n  }\n\n  /**\n   * Wait the response and return the response without considering it is staled or fresh.\n   */\n  waitResponse(): Promise<Readonly<QueryResponse<T>> | undefined> {\n    if (this.response) {\n      return Promise.resolve(this.response);\n    }\n\n    const disposers: (() => void)[] = [];\n    let onceCoerce = false;\n    // Make sure that the fetching is tracked to force to be fetched.\n    disposers.push(\n      reaction(\n        () => this.isFetching,\n        () => {\n          if (!onceCoerce) {\n            if (!this.isFetching) {\n              this.fetch();\n            }\n            onceCoerce = true;\n          }\n        },\n        {\n          fireImmediately: true,\n        }\n      )\n    );\n\n    return new Promise<Readonly<QueryResponse<T>> | undefined>((resolve) => {\n      const disposer = autorun(() => {\n        if (!this.isFetching) {\n          resolve(this.response);\n        }\n      });\n      disposers.push(disposer);\n    }).finally(() => {\n      for (const disposer of disposers) {\n        disposer();\n      }\n    });\n  }\n\n  /**\n   * Wait the response and return the response until it is fetched.\n   */\n  waitFreshResponse(): Promise<Readonly<QueryResponse<T>> | undefined> {\n    const disposers: (() => void)[] = [];\n    let onceCoerce = false;\n    // Make sure that the fetching is tracked to force to be fetched.\n    disposers.push(\n      reaction(\n        () => this.isFetching,\n        () => {\n          if (!onceCoerce) {\n            if (!this.isFetching) {\n              this.fetch();\n            }\n            onceCoerce = true;\n          }\n        },\n        {\n          fireImmediately: true,\n        }\n      )\n    );\n\n    return new Promise<Readonly<QueryResponse<T>> | undefined>((resolve) => {\n      const disposer = autorun(() => {\n        if (!this.isFetching) {\n          resolve(this.response);\n        }\n      });\n      disposers.push(disposer);\n    }).finally(() => {\n      for (const disposer of disposers) {\n        disposer();\n      }\n    });\n  }\n\n  protected abstract fetchResponse(\n    abortController: AbortController\n  ): Promise<{ response: QueryResponse<T>; headers: any }>;\n\n  /**\n   * Used for saving the last response to disk.\n   * This should not make observable state changes.\n   * @param response\n   * @protected\n   */\n  protected abstract saveResponse(\n    response: Readonly<QueryResponse<T>>\n  ): Promise<void>;\n\n  /**\n   * Used for loading the last response from disk.\n   * @protected\n   */\n  protected abstract loadStaledResponse(): Promise<\n    QueryResponse<T> | undefined\n  >;\n}\n\n/**\n * ObservableQuery defines the event class to query the result from endpoint.\n * This supports the stale state if previous query exists.\n */\nexport class ObservableQuery<\n  T = unknown,\n  E = unknown\n> extends ObservableQueryBase<T, E> {\n  protected static eventListener: EventEmitter = new EventEmitter();\n\n  public static refreshAllObserved() {\n    ObservableQuery.eventListener.emit(\"refresh\");\n  }\n\n  public static refreshAllObservedIfError() {\n    ObservableQuery.eventListener.emit(\"refresh\", {\n      ifError: true,\n    });\n  }\n\n  @observable\n  protected _url: string = \"\";\n\n  constructor(\n    protected readonly kvStore: KVStore,\n    instance: AxiosInstance,\n    url: string,\n    options: Partial<QueryOptions> = {}\n  ) {\n    super(instance, options);\n    makeObservable(this);\n\n    this.setUrl(url);\n  }\n\n  protected onStart() {\n    super.onStart();\n\n    ObservableQuery.eventListener.addListener(\"refresh\", this.refreshHandler);\n  }\n\n  protected onStop() {\n    super.onStop();\n\n    ObservableQuery.eventListener.addListener(\"refresh\", this.refreshHandler);\n  }\n\n  protected readonly refreshHandler = (data: any) => {\n    const ifError = data?.ifError;\n    if (ifError) {\n      if (this.error) {\n        this.fetch();\n      }\n    } else {\n      this.fetch();\n    }\n  };\n\n  get url(): string {\n    return this._url;\n  }\n\n  @action\n  protected setUrl(url: string) {\n    if (this._url !== url) {\n      this._url = url;\n      this.fetch();\n    }\n  }\n\n  protected async fetchResponse(\n    abortController: AbortController\n  ): Promise<{ response: QueryResponse<T>; headers: any }> {\n    const result = await this.instance.get<T>(this.url, {\n      signal: abortController.signal,\n    });\n    return {\n      headers: result.headers,\n      response: {\n        data: result.data,\n        status: result.status,\n        staled: false,\n        timestamp: Date.now(),\n      },\n    };\n  }\n\n  protected getCacheKey(): string {\n    return `${this.instance.name}-${\n      this.instance.defaults.baseURL\n    }${this.instance.getUri({\n      url: this.url,\n    })}`;\n  }\n\n  protected async saveResponse(\n    response: Readonly<QueryResponse<T>>\n  ): Promise<void> {\n    const key = this.getCacheKey();\n    await this.kvStore.set(key, response);\n  }\n\n  protected async loadStaledResponse(): Promise<QueryResponse<T> | undefined> {\n    const key = this.getCacheKey();\n    const response = await this.kvStore.get<QueryResponse<T>>(key);\n    if (response) {\n      return {\n        ...response,\n        staled: true,\n      };\n    }\n    return undefined;\n  }\n}\n\nexport class ObservableQueryMap<T = unknown, E = unknown> extends HasMapStore<\n  ObservableQuery<T, E>\n> {\n  constructor(creater: (key: string) => ObservableQuery<T, E>) {\n    super(creater);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}