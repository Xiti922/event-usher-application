{"ast":null,"code":"\"use strict\";\n\n// Copyright (C) 2017 Tony Arcieri\n// MIT License. See LICENSE file for details.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst block_1 = require(\"../../internals/block\");\n/**\n * WebCrypto-based implementation of the AES block cipher.\n *\n * This implementation (ab)uses AES-CBC mode to implement AES-ECB. This is\n * likely to be rather slow, as it requires an async call per block, and\n * discards half the buffer.\n *\n * In theory it should be constant time due to the use of WebCrypto (provided\n * the browser's implementation is constant time), but it could probably benefit\n * from some clever optimization work, or improvements to the WebCrypto API.\n *\n * Some WebCrypto implementations (e.g. node-webcrypto-ossl) support ECB mode\n * natively, so we could take advantage of that to potentially encrypt multiple\n * blocks in a single invocation.\n *\n * Key size: 16 or 32 bytes, block size: 16 bytes.\n */\nclass WebCryptoAes {\n  constructor(_crypto, _key) {\n    this._crypto = _crypto;\n    this._key = _key;\n    // An initialization vector of all zeros, exposing the raw AES function\n    this._iv = new block_1.default();\n    this._emptyPromise = Promise.resolve(this);\n  }\n  /**\n   * Create a new WebCryptoAes instance\n   *\n   * @param {Crypto} crypto - the Web Cryptography provider\n   * @param {Uint8Array} keyData - the AES secret key\n   * @returns {Promise<WebCryptoAes}\n   */\n  static importKey(crypto, keyData) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Only AES-128 and AES-256 supported. AES-192 is not.\n      if (keyData.length !== 16 && keyData.length !== 32) {\n        throw new Error(`Miscreant: invalid key length: ${keyData.length} (expected 16 or 32 bytes)`);\n      }\n      const key = yield crypto.subtle.importKey(\"raw\", keyData, \"AES-CBC\", false, [\"encrypt\"]);\n      return new WebCryptoAes(crypto, key);\n    });\n  }\n  /**\n   * Cleans expanded keys from memory, setting them to zeros.\n   */\n  clear() {\n    // TODO: perhaps we should clear something, but what, and how?\n    return this;\n  }\n  /**\n   * Encrypt a single AES block. While ordinarily this might let us see penguins, we're using it safely\n   *\n   * @param {Block} block - block to be encrypted in-place\n   * @returns {Promise<this>}\n   */\n  encryptBlock(block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const params = {\n        name: \"AES-CBC\",\n        iv: this._iv.data\n      };\n      const ctBlock = yield this._crypto.subtle.encrypt(params, this._key, block.data);\n      // TODO: a more efficient way to do in-place encryption?\n      block.data.set(new Uint8Array(ctBlock, 0, block_1.default.SIZE));\n      return this._emptyPromise;\n    });\n  }\n}\nexports.default = WebCryptoAes;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","block_1","require","WebCryptoAes","constructor","_crypto","_key","_iv","default","_emptyPromise","importKey","crypto","keyData","length","Error","key","subtle","clear","encryptBlock","block","params","name","iv","data","ctBlock","encrypt","set","Uint8Array","SIZE"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/miscreant/release/providers/webcrypto/aes.js"],"sourcesContent":["\"use strict\";\n// Copyright (C) 2017 Tony Arcieri\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst block_1 = require(\"../../internals/block\");\n/**\n * WebCrypto-based implementation of the AES block cipher.\n *\n * This implementation (ab)uses AES-CBC mode to implement AES-ECB. This is\n * likely to be rather slow, as it requires an async call per block, and\n * discards half the buffer.\n *\n * In theory it should be constant time due to the use of WebCrypto (provided\n * the browser's implementation is constant time), but it could probably benefit\n * from some clever optimization work, or improvements to the WebCrypto API.\n *\n * Some WebCrypto implementations (e.g. node-webcrypto-ossl) support ECB mode\n * natively, so we could take advantage of that to potentially encrypt multiple\n * blocks in a single invocation.\n *\n * Key size: 16 or 32 bytes, block size: 16 bytes.\n */\nclass WebCryptoAes {\n    constructor(_crypto, _key) {\n        this._crypto = _crypto;\n        this._key = _key;\n        // An initialization vector of all zeros, exposing the raw AES function\n        this._iv = new block_1.default();\n        this._emptyPromise = Promise.resolve(this);\n    }\n    /**\n     * Create a new WebCryptoAes instance\n     *\n     * @param {Crypto} crypto - the Web Cryptography provider\n     * @param {Uint8Array} keyData - the AES secret key\n     * @returns {Promise<WebCryptoAes}\n     */\n    static importKey(crypto, keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Only AES-128 and AES-256 supported. AES-192 is not.\n            if (keyData.length !== 16 && keyData.length !== 32) {\n                throw new Error(`Miscreant: invalid key length: ${keyData.length} (expected 16 or 32 bytes)`);\n            }\n            const key = yield crypto.subtle.importKey(\"raw\", keyData, \"AES-CBC\", false, [\"encrypt\"]);\n            return new WebCryptoAes(crypto, key);\n        });\n    }\n    /**\n     * Cleans expanded keys from memory, setting them to zeros.\n     */\n    clear() {\n        // TODO: perhaps we should clear something, but what, and how?\n        return this;\n    }\n    /**\n     * Encrypt a single AES block. While ordinarily this might let us see penguins, we're using it safely\n     *\n     * @param {Block} block - block to be encrypted in-place\n     * @returns {Promise<this>}\n     */\n    encryptBlock(block) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const params = { name: \"AES-CBC\", iv: this._iv.data };\n            const ctBlock = yield this._crypto.subtle.encrypt(params, this._key, block.data);\n            // TODO: a more efficient way to do in-place encryption?\n            block.data.set(new Uint8Array(ctBlock, 0, block_1.default.SIZE));\n            return this._emptyPromise;\n        });\n    }\n}\nexports.default = WebCryptoAes;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}