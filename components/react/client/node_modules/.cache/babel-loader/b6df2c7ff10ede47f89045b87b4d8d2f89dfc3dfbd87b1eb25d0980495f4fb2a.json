{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bech32Address = void 0;\nconst bech32_1 = __importStar(require(\"bech32\"));\nconst buffer_1 = require(\"buffer/\");\nconst address_1 = require(\"@ethersproject/address\");\nclass Bech32Address {\n  constructor(address) {\n    this.address = address;\n  }\n  static shortenAddress(bech32, maxCharacters) {\n    if (maxCharacters >= bech32.length) {\n      return bech32;\n    }\n    const i = bech32.indexOf(\"1\");\n    const prefix = bech32.slice(0, i);\n    const address = bech32.slice(i + 1);\n    maxCharacters -= prefix.length;\n    maxCharacters -= 3; // For \"...\"\n    maxCharacters -= 1; // For \"1\"\n    if (maxCharacters <= 0) {\n      return \"\";\n    }\n    const mid = Math.floor(address.length / 2);\n    let former = address.slice(0, mid);\n    let latter = address.slice(mid);\n    while (maxCharacters < former.length + latter.length) {\n      if ((former.length + latter.length) % 2 === 1 && former.length > 0) {\n        former = former.slice(0, former.length - 1);\n      } else {\n        latter = latter.slice(1);\n      }\n    }\n    return prefix + \"1\" + former + \"...\" + latter;\n  }\n  static fromBech32(bech32Address, prefix) {\n    const decoded = bech32_1.default.decode(bech32Address);\n    if (prefix && decoded.prefix !== prefix) {\n      throw new Error(\"Unmatched prefix\");\n    }\n    return new Bech32Address(new Uint8Array(bech32_1.fromWords(decoded.words)));\n  }\n  static validate(bech32Address, prefix) {\n    const {\n      prefix: decodedPrefix\n    } = bech32_1.default.decode(bech32Address);\n    if (prefix && prefix !== decodedPrefix) {\n      throw new Error(`Unexpected prefix (expected: ${prefix}, actual: ${decodedPrefix})`);\n    }\n  }\n  static defaultBech32Config(mainPrefix) {\n    let validatorPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"val\";\n    let consensusPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"cons\";\n    let publicPrefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"pub\";\n    let operatorPrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"oper\";\n    return {\n      bech32PrefixAccAddr: mainPrefix,\n      bech32PrefixAccPub: mainPrefix + publicPrefix,\n      bech32PrefixValAddr: mainPrefix + validatorPrefix + operatorPrefix,\n      bech32PrefixValPub: mainPrefix + validatorPrefix + operatorPrefix + publicPrefix,\n      bech32PrefixConsAddr: mainPrefix + validatorPrefix + consensusPrefix,\n      bech32PrefixConsPub: mainPrefix + validatorPrefix + consensusPrefix + publicPrefix\n    };\n  }\n  toBech32(prefix) {\n    const words = bech32_1.default.toWords(this.address);\n    return bech32_1.default.encode(prefix, words);\n  }\n  toHex() {\n    let mixedCaseChecksum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const hex = buffer_1.Buffer.from(this.address).toString(\"hex\");\n    if (hex.length === 0) {\n      throw new Error(\"Empty address\");\n    }\n    if (mixedCaseChecksum) {\n      return address_1.getAddress(\"0x\" + hex);\n    } else {\n      return \"0x\" + hex;\n    }\n  }\n}\nexports.Bech32Address = Bech32Address;","map":{"version":3,"mappings":"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","names":["Bech32Address","constructor","address","shortenAddress","bech32","maxCharacters","length","i","indexOf","prefix","slice","mid","Math","floor","former","latter","fromBech32","bech32Address","decoded","bech32_1","decode","Error","Uint8Array","words","validate","decodedPrefix","defaultBech32Config","mainPrefix","validatorPrefix","consensusPrefix","publicPrefix","operatorPrefix","bech32PrefixAccAddr","bech32PrefixAccPub","bech32PrefixValAddr","bech32PrefixValPub","bech32PrefixConsAddr","bech32PrefixConsPub","toBech32","toWords","encode","toHex","mixedCaseChecksum","hex","buffer_1","from","toString","address_1","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/node_modules/@keplr-wallet/cosmos/src/bech32/index.ts"],"sourcesContent":["import bech32, { fromWords } from \"bech32\";\nimport { Bech32Config } from \"@keplr-wallet/types\";\nimport { Buffer } from \"buffer/\";\nimport { getAddress as getEthAddress } from \"@ethersproject/address\";\n\nexport class Bech32Address {\n  static shortenAddress(bech32: string, maxCharacters: number): string {\n    if (maxCharacters >= bech32.length) {\n      return bech32;\n    }\n\n    const i = bech32.indexOf(\"1\");\n    const prefix = bech32.slice(0, i);\n    const address = bech32.slice(i + 1);\n\n    maxCharacters -= prefix.length;\n    maxCharacters -= 3; // For \"...\"\n    maxCharacters -= 1; // For \"1\"\n\n    if (maxCharacters <= 0) {\n      return \"\";\n    }\n\n    const mid = Math.floor(address.length / 2);\n    let former = address.slice(0, mid);\n    let latter = address.slice(mid);\n\n    while (maxCharacters < former.length + latter.length) {\n      if ((former.length + latter.length) % 2 === 1 && former.length > 0) {\n        former = former.slice(0, former.length - 1);\n      } else {\n        latter = latter.slice(1);\n      }\n    }\n\n    return prefix + \"1\" + former + \"...\" + latter;\n  }\n\n  static fromBech32(bech32Address: string, prefix?: string): Bech32Address {\n    const decoded = bech32.decode(bech32Address);\n    if (prefix && decoded.prefix !== prefix) {\n      throw new Error(\"Unmatched prefix\");\n    }\n\n    return new Bech32Address(new Uint8Array(fromWords(decoded.words)));\n  }\n\n  static validate(bech32Address: string, prefix?: string) {\n    const { prefix: decodedPrefix } = bech32.decode(bech32Address);\n    if (prefix && prefix !== decodedPrefix) {\n      throw new Error(\n        `Unexpected prefix (expected: ${prefix}, actual: ${decodedPrefix})`\n      );\n    }\n  }\n\n  static defaultBech32Config(\n    mainPrefix: string,\n    validatorPrefix: string = \"val\",\n    consensusPrefix: string = \"cons\",\n    publicPrefix: string = \"pub\",\n    operatorPrefix: string = \"oper\"\n  ): Bech32Config {\n    return {\n      bech32PrefixAccAddr: mainPrefix,\n      bech32PrefixAccPub: mainPrefix + publicPrefix,\n      bech32PrefixValAddr: mainPrefix + validatorPrefix + operatorPrefix,\n      bech32PrefixValPub:\n        mainPrefix + validatorPrefix + operatorPrefix + publicPrefix,\n      bech32PrefixConsAddr: mainPrefix + validatorPrefix + consensusPrefix,\n      bech32PrefixConsPub:\n        mainPrefix + validatorPrefix + consensusPrefix + publicPrefix,\n    };\n  }\n\n  constructor(public readonly address: Uint8Array) {}\n\n  toBech32(prefix: string): string {\n    const words = bech32.toWords(this.address);\n    return bech32.encode(prefix, words);\n  }\n\n  toHex(mixedCaseChecksum: boolean = true): string {\n    const hex = Buffer.from(this.address).toString(\"hex\");\n\n    if (hex.length === 0) {\n      throw new Error(\"Empty address\");\n    }\n\n    if (mixedCaseChecksum) {\n      return getEthAddress(\"0x\" + hex);\n    } else {\n      return \"0x\" + hex;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}