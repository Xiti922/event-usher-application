{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KeyRingService = void 0;\nconst keyring_1 = require(\"./keyring\");\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nconst common_1 = require(\"@keplr-wallet/common\");\nconst router_1 = require(\"@keplr-wallet/router\");\nconst launchpad_1 = require(\"@cosmjs/launchpad\");\nconst proto_signing_1 = require(\"@cosmjs/proto-signing\");\nconst tx_1 = require(\"@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx\");\nconst long_1 = __importDefault(require(\"long\"));\nconst buffer_1 = require(\"buffer/\");\nclass KeyRingService {\n  constructor(kvStore, embedChainInfos, crypto) {\n    this.kvStore = kvStore;\n    this.embedChainInfos = embedChainInfos;\n    this.crypto = crypto;\n    this.onChainRemoved = chainId => {\n      this.keyRing.removeAllKeyStoreCoinType(chainId);\n    };\n  }\n  init(interactionService, chainsService, permissionService, ledgerService) {\n    this.interactionService = interactionService;\n    this.chainsService = chainsService;\n    this.permissionService = permissionService;\n    this.keyRing = new keyring_1.KeyRing(this.embedChainInfos, this.kvStore, ledgerService, this.crypto);\n    this.chainsService.addChainRemovedHandler(this.onChainRemoved);\n  }\n  restore() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.keyRing.restore();\n      return {\n        status: this.keyRing.status,\n        multiKeyStoreInfo: this.keyRing.getMultiKeyStoreInfo()\n      };\n    });\n  }\n  enable(env) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.keyRing.status === keyring_1.KeyRingStatus.EMPTY) {\n        throw new router_1.KeplrError(\"keyring\", 261, \"key doesn't exist\");\n      }\n      if (this.keyRing.status === keyring_1.KeyRingStatus.NOTLOADED) {\n        yield this.keyRing.restore();\n      }\n      if (this.keyRing.status === keyring_1.KeyRingStatus.LOCKED) {\n        yield this.interactionService.waitApprove(env, \"/unlock\", \"unlock\", {});\n        return this.keyRing.status;\n      }\n      return this.keyRing.status;\n    });\n  }\n  get keyRingStatus() {\n    return this.keyRing.status;\n  }\n  deleteKeyRing(index, password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let keyStoreChanged = false;\n      try {\n        const result = yield this.keyRing.deleteKeyRing(index, password);\n        keyStoreChanged = result.keyStoreChanged;\n        return {\n          multiKeyStoreInfo: result.multiKeyStoreInfo,\n          status: this.keyRing.status\n        };\n      } finally {\n        if (keyStoreChanged) {\n          this.interactionService.dispatchEvent(router_1.WEBPAGE_PORT, \"keystore-changed\", {});\n        }\n      }\n    });\n  }\n  updateNameKeyRing(index, name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const multiKeyStoreInfo = yield this.keyRing.updateNameKeyRing(index, name);\n      return {\n        multiKeyStoreInfo\n      };\n    });\n  }\n  showKeyRing(index, password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.keyRing.showKeyRing(index, password);\n    });\n  }\n  createMnemonicKey(kdf, mnemonic, password, meta, bip44HDPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO: Check mnemonic checksum.\n      return yield this.keyRing.createMnemonicKey(kdf, mnemonic, password, meta, bip44HDPath);\n    });\n  }\n  createPrivateKey(kdf, privateKey, password, meta) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.keyRing.createPrivateKey(kdf, privateKey, password, meta);\n    });\n  }\n  createLedgerKey(env, kdf, password, meta, bip44HDPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.keyRing.createLedgerKey(env, kdf, password, meta, bip44HDPath);\n    });\n  }\n  lock() {\n    this.keyRing.lock();\n    return this.keyRing.status;\n  }\n  unlock(password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.keyRing.unlock(password);\n      return this.keyRing.status;\n    });\n  }\n  getKey(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.keyRing.getKey(chainId, yield this.chainsService.getChainCoinType(chainId), (yield this.chainsService.getChainEthereumKeyFeatures(chainId)).address);\n    });\n  }\n  getKeyStoreMeta(key) {\n    return this.keyRing.getKeyStoreMeta(key);\n  }\n  getKeyRingType() {\n    return this.keyRing.type;\n  }\n  requestSignAmino(env, msgOrigin, chainId, signer, signDoc, signOptions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      signDoc = Object.assign(Object.assign({}, signDoc), {\n        memo: common_1.escapeHTML(signDoc.memo)\n      });\n      const coinType = yield this.chainsService.getChainCoinType(chainId);\n      const ethereumKeyFeatures = yield this.chainsService.getChainEthereumKeyFeatures(chainId);\n      const key = yield this.keyRing.getKey(chainId, coinType, ethereumKeyFeatures.address);\n      const bech32Prefix = (yield this.chainsService.getChainInfo(chainId)).bech32Config.bech32PrefixAccAddr;\n      const bech32Address = new cosmos_1.Bech32Address(key.address).toBech32(bech32Prefix);\n      if (signer !== bech32Address) {\n        throw new router_1.KeplrError(\"keyring\", 231, \"Signer mismatched\");\n      }\n      const isADR36SignDoc = cosmos_1.checkAndValidateADR36AminoSignDoc(signDoc, bech32Prefix);\n      if (isADR36SignDoc) {\n        if (signDoc.msgs[0].value.signer !== signer) {\n          throw new router_1.KeplrError(\"keyring\", 233, \"Unmatched signer in sign doc\");\n        }\n      }\n      if (signOptions.isADR36WithString != null && !isADR36SignDoc) {\n        throw new router_1.KeplrError(\"keyring\", 236, 'Sign doc is not for ADR-36. But, \"isADR36WithString\" option is defined');\n      }\n      if (signOptions.ethSignType && !isADR36SignDoc) {\n        throw new Error(\"Eth sign type can be requested with only ADR-36 amino sign doc\");\n      }\n      let newSignDoc = yield this.interactionService.waitApprove(env, \"/sign\", \"request-sign\", {\n        msgOrigin,\n        chainId,\n        mode: \"amino\",\n        signDoc,\n        signer,\n        signOptions,\n        isADR36SignDoc,\n        isADR36WithString: signOptions.isADR36WithString,\n        ethSignType: signOptions.ethSignType\n      });\n      newSignDoc = Object.assign(Object.assign({}, newSignDoc), {\n        memo: common_1.escapeHTML(newSignDoc.memo)\n      });\n      if (isADR36SignDoc) {\n        // Validate the new sign doc, if it was for ADR-36.\n        if (cosmos_1.checkAndValidateADR36AminoSignDoc(signDoc, bech32Prefix)) {\n          if (signDoc.msgs[0].value.signer !== signer) {\n            throw new router_1.KeplrError(\"keyring\", 232, \"Unmatched signer in new sign doc\");\n          }\n        } else {\n          throw new router_1.KeplrError(\"keyring\", 237, \"Signing request was for ADR-36. But, accidentally, new sign doc is not for ADR-36\");\n        }\n      }\n      // Handle Ethereum signing\n      if (signOptions.ethSignType) {\n        if (newSignDoc.msgs.length !== 1) {\n          // Validate number of messages\n          throw new Error(\"Invalid number of messages for Ethereum sign request\");\n        }\n        const signBytes = buffer_1.Buffer.from(newSignDoc.msgs[0].value.data, \"base64\");\n        try {\n          const signatureBytes = yield this.keyRing.signEthereum(chainId, coinType, signBytes, signOptions.ethSignType);\n          return {\n            signed: newSignDoc,\n            signature: {\n              pub_key: launchpad_1.encodeSecp256k1Pubkey(key.pubKey),\n              signature: buffer_1.Buffer.from(signatureBytes).toString(\"base64\")\n            }\n          };\n        } finally {\n          this.interactionService.dispatchEvent(router_1.APP_PORT, \"request-sign-end\", {});\n        }\n      }\n      try {\n        const signature = yield this.keyRing.sign(env, chainId, coinType, launchpad_1.serializeSignDoc(newSignDoc), ethereumKeyFeatures.signing);\n        return {\n          signed: newSignDoc,\n          signature: launchpad_1.encodeSecp256k1Signature(key.pubKey, signature)\n        };\n      } finally {\n        this.interactionService.dispatchEvent(router_1.APP_PORT, \"request-sign-end\", {});\n      }\n    });\n  }\n  requestSignDirect(env, msgOrigin, chainId, signer, signDoc, signOptions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const coinType = yield this.chainsService.getChainCoinType(chainId);\n      const ethereumKeyFeatures = yield this.chainsService.getChainEthereumKeyFeatures(chainId);\n      const key = yield this.keyRing.getKey(chainId, coinType, ethereumKeyFeatures.address);\n      const bech32Address = new cosmos_1.Bech32Address(key.address).toBech32((yield this.chainsService.getChainInfo(chainId)).bech32Config.bech32PrefixAccAddr);\n      if (signer !== bech32Address) {\n        throw new router_1.KeplrError(\"keyring\", 231, \"Signer mismatched\");\n      }\n      const newSignDocBytes = yield this.interactionService.waitApprove(env, \"/sign\", \"request-sign\", {\n        msgOrigin,\n        chainId,\n        mode: \"direct\",\n        signDocBytes: tx_1.SignDoc.encode(signDoc).finish(),\n        signer,\n        signOptions\n      });\n      const newSignDoc = tx_1.SignDoc.decode(newSignDocBytes);\n      const {\n          accountNumber: newSignDocAccountNumber\n        } = newSignDoc,\n        newSignDocRest = __rest(newSignDoc, [\"accountNumber\"]);\n      const cosmJSSignDoc = Object.assign(Object.assign({}, newSignDocRest), {\n        accountNumber: long_1.default.fromString(newSignDocAccountNumber)\n      });\n      try {\n        const signature = yield this.keyRing.sign(env, chainId, coinType, proto_signing_1.makeSignBytes(cosmJSSignDoc), ethereumKeyFeatures.signing);\n        return {\n          signed: cosmJSSignDoc,\n          signature: launchpad_1.encodeSecp256k1Signature(key.pubKey, signature)\n        };\n      } finally {\n        this.interactionService.dispatchEvent(router_1.APP_PORT, \"request-sign-end\", {});\n      }\n    });\n  }\n  verifyADR36AminoSignDoc(chainId, signer, data, signature) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const coinType = yield this.chainsService.getChainCoinType(chainId);\n      const ethereumKeyFeatures = yield this.chainsService.getChainEthereumKeyFeatures(chainId);\n      const key = yield this.keyRing.getKey(chainId, coinType, ethereumKeyFeatures.address);\n      const bech32Prefix = (yield this.chainsService.getChainInfo(chainId)).bech32Config.bech32PrefixAccAddr;\n      const bech32Address = new cosmos_1.Bech32Address(key.address).toBech32(bech32Prefix);\n      if (signer !== bech32Address) {\n        throw new router_1.KeplrError(\"keyring\", 231, \"Signer mismatched\");\n      }\n      if (signature.pub_key.type !== \"tendermint/PubKeySecp256k1\") {\n        throw new router_1.KeplrError(\"keyring\", 211, `Unsupported type of pub key: ${signature.pub_key.type}`);\n      }\n      if (buffer_1.Buffer.from(key.pubKey).toString(\"base64\") !== signature.pub_key.value) {\n        throw new router_1.KeplrError(\"keyring\", 210, \"Pub key unmatched\");\n      }\n      const signDoc = cosmos_1.makeADR36AminoSignDoc(signer, data);\n      return cosmos_1.verifyADR36AminoSignDoc(bech32Prefix, signDoc, buffer_1.Buffer.from(signature.pub_key.value, \"base64\"), buffer_1.Buffer.from(signature.signature, \"base64\"));\n    });\n  }\n  sign(env, chainId, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.keyRing.sign(env, chainId, yield this.chainsService.getChainCoinType(chainId), message, (yield this.chainsService.getChainEthereumKeyFeatures(chainId)).signing);\n    });\n  }\n  addMnemonicKey(kdf, mnemonic, meta, bip44HDPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.keyRing.addMnemonicKey(kdf, mnemonic, meta, bip44HDPath);\n    });\n  }\n  addPrivateKey(kdf, privateKey, meta) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.keyRing.addPrivateKey(kdf, privateKey, meta);\n    });\n  }\n  addLedgerKey(env, kdf, meta, bip44HDPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.keyRing.addLedgerKey(env, kdf, meta, bip44HDPath);\n    });\n  }\n  changeKeyStoreFromMultiKeyStore(index) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield this.keyRing.changeKeyStoreFromMultiKeyStore(index);\n      } finally {\n        this.interactionService.dispatchEvent(router_1.WEBPAGE_PORT, \"keystore-changed\", {});\n      }\n    });\n  }\n  checkPassword(password) {\n    return this.keyRing.checkPassword(password);\n  }\n  getMultiKeyStoreInfo() {\n    return this.keyRing.getMultiKeyStoreInfo();\n  }\n  isKeyStoreCoinTypeSet(chainId) {\n    return this.keyRing.isKeyStoreCoinTypeSet(chainId);\n  }\n  setKeyStoreCoinType(chainId, coinType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const prevCoinType = this.keyRing.computeKeyStoreCoinType(chainId, yield this.chainsService.getChainCoinType(chainId));\n      yield this.keyRing.setKeyStoreCoinType(chainId, coinType);\n      if (prevCoinType !== coinType) {\n        this.interactionService.dispatchEvent(router_1.WEBPAGE_PORT, \"keystore-changed\", {});\n      }\n    });\n  }\n  getKeyStoreBIP44Selectables(chainId, paths) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isKeyStoreCoinTypeSet(chainId)) {\n        return [];\n      }\n      const result = [];\n      const chainInfo = yield this.chainsService.getChainInfo(chainId);\n      for (const path of paths) {\n        const key = yield this.keyRing.getKeyFromCoinType(path.coinType, (yield this.chainsService.getChainEthereumKeyFeatures(chainId)).address);\n        const bech32Address = new cosmos_1.Bech32Address(key.address).toBech32(chainInfo.bech32Config.bech32PrefixAccAddr);\n        result.push({\n          path,\n          bech32Address\n        });\n      }\n      return result;\n    });\n  }\n  exportKeyRingDatas(password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.keyRing.exportKeyRingDatas(password);\n    });\n  }\n}\nexports.KeyRingService = KeyRingService;","map":{"version":3,"mappings":"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","names":["KeyRingService","constructor","kvStore","embedChainInfos","crypto","chainId","keyRing","removeAllKeyStoreCoinType","init","interactionService","chainsService","permissionService","ledgerService","keyring_1","addChainRemovedHandler","onChainRemoved","restore","status","multiKeyStoreInfo","getMultiKeyStoreInfo","enable","env","EMPTY","router_1","NOTLOADED","LOCKED","waitApprove","keyRingStatus","deleteKeyRing","index","password","keyStoreChanged","result","dispatchEvent","updateNameKeyRing","name","showKeyRing","createMnemonicKey","kdf","mnemonic","meta","bip44HDPath","createPrivateKey","privateKey","createLedgerKey","lock","unlock","getKey","getChainCoinType","getChainEthereumKeyFeatures","address","getKeyStoreMeta","key","getKeyRingType","type","requestSignAmino","msgOrigin","signer","signDoc","signOptions","memo","common_1","coinType","ethereumKeyFeatures","bech32Prefix","getChainInfo","bech32Config","bech32PrefixAccAddr","bech32Address","cosmos_1","toBech32","isADR36SignDoc","msgs","value","isADR36WithString","ethSignType","Error","newSignDoc","mode","length","signBytes","buffer_1","from","data","signatureBytes","signEthereum","signed","signature","pub_key","launchpad_1","pubKey","toString","sign","signing","requestSignDirect","newSignDocBytes","signDocBytes","tx_1","encode","finish","decode","accountNumber","newSignDocAccountNumber","newSignDocRest","cosmJSSignDoc","long_1","fromString","proto_signing_1","verifyADR36AminoSignDoc","message","addMnemonicKey","addPrivateKey","addLedgerKey","changeKeyStoreFromMultiKeyStore","checkPassword","isKeyStoreCoinTypeSet","setKeyStoreCoinType","prevCoinType","computeKeyStoreCoinType","getKeyStoreBIP44Selectables","paths","chainInfo","path","getKeyFromCoinType","push","exportKeyRingDatas","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/background/src/keyring/service.ts"],"sourcesContent":["import {\n  Key,\n  KeyRing,\n  KeyRingStatus,\n  MultiKeyStoreInfoWithSelected,\n} from \"./keyring\";\n\nimport {\n  Bech32Address,\n  checkAndValidateADR36AminoSignDoc,\n  makeADR36AminoSignDoc,\n  verifyADR36AminoSignDoc,\n} from \"@keplr-wallet/cosmos\";\nimport { BIP44HDPath, CommonCrypto, ExportKeyRingData } from \"./types\";\n\nimport { escapeHTML, KVStore } from \"@keplr-wallet/common\";\n\nimport { ChainsService } from \"../chains\";\nimport { LedgerService } from \"../ledger\";\nimport {\n  BIP44,\n  ChainInfo,\n  EthSignType,\n  KeplrSignOptions,\n} from \"@keplr-wallet/types\";\nimport { APP_PORT, Env, KeplrError, WEBPAGE_PORT } from \"@keplr-wallet/router\";\nimport { InteractionService } from \"../interaction\";\nimport { PermissionService } from \"../permission\";\n\nimport {\n  encodeSecp256k1Signature,\n  serializeSignDoc,\n  AminoSignResponse,\n  StdSignDoc,\n  StdSignature,\n  encodeSecp256k1Pubkey,\n} from \"@cosmjs/launchpad\";\nimport { DirectSignResponse, makeSignBytes } from \"@cosmjs/proto-signing\";\n\nimport { SignDoc } from \"@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx\";\nimport Long from \"long\";\nimport { Buffer } from \"buffer/\";\n\nexport class KeyRingService {\n  private keyRing!: KeyRing;\n\n  protected interactionService!: InteractionService;\n  public chainsService!: ChainsService;\n  public permissionService!: PermissionService;\n\n  constructor(\n    protected readonly kvStore: KVStore,\n    protected readonly embedChainInfos: ChainInfo[],\n    protected readonly crypto: CommonCrypto\n  ) {}\n\n  init(\n    interactionService: InteractionService,\n    chainsService: ChainsService,\n    permissionService: PermissionService,\n    ledgerService: LedgerService\n  ) {\n    this.interactionService = interactionService;\n    this.chainsService = chainsService;\n    this.permissionService = permissionService;\n\n    this.keyRing = new KeyRing(\n      this.embedChainInfos,\n      this.kvStore,\n      ledgerService,\n      this.crypto\n    );\n\n    this.chainsService.addChainRemovedHandler(this.onChainRemoved);\n  }\n\n  protected readonly onChainRemoved = (chainId: string) => {\n    this.keyRing.removeAllKeyStoreCoinType(chainId);\n  };\n\n  async restore(): Promise<{\n    status: KeyRingStatus;\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    await this.keyRing.restore();\n    return {\n      status: this.keyRing.status,\n      multiKeyStoreInfo: this.keyRing.getMultiKeyStoreInfo(),\n    };\n  }\n\n  async enable(env: Env): Promise<KeyRingStatus> {\n    if (this.keyRing.status === KeyRingStatus.EMPTY) {\n      throw new KeplrError(\"keyring\", 261, \"key doesn't exist\");\n    }\n\n    if (this.keyRing.status === KeyRingStatus.NOTLOADED) {\n      await this.keyRing.restore();\n    }\n\n    if (this.keyRing.status === KeyRingStatus.LOCKED) {\n      await this.interactionService.waitApprove(env, \"/unlock\", \"unlock\", {});\n      return this.keyRing.status;\n    }\n\n    return this.keyRing.status;\n  }\n\n  get keyRingStatus(): KeyRingStatus {\n    return this.keyRing.status;\n  }\n\n  async deleteKeyRing(\n    index: number,\n    password: string\n  ): Promise<{\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n    status: KeyRingStatus;\n  }> {\n    let keyStoreChanged = false;\n\n    try {\n      const result = await this.keyRing.deleteKeyRing(index, password);\n      keyStoreChanged = result.keyStoreChanged;\n      return {\n        multiKeyStoreInfo: result.multiKeyStoreInfo,\n        status: this.keyRing.status,\n      };\n    } finally {\n      if (keyStoreChanged) {\n        this.interactionService.dispatchEvent(\n          WEBPAGE_PORT,\n          \"keystore-changed\",\n          {}\n        );\n      }\n    }\n  }\n\n  async updateNameKeyRing(\n    index: number,\n    name: string\n  ): Promise<{\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    const multiKeyStoreInfo = await this.keyRing.updateNameKeyRing(index, name);\n    return {\n      multiKeyStoreInfo,\n    };\n  }\n\n  async showKeyRing(index: number, password: string): Promise<string> {\n    return await this.keyRing.showKeyRing(index, password);\n  }\n\n  async createMnemonicKey(\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    mnemonic: string,\n    password: string,\n    meta: Record<string, string>,\n    bip44HDPath: BIP44HDPath\n  ): Promise<{\n    status: KeyRingStatus;\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    // TODO: Check mnemonic checksum.\n    return await this.keyRing.createMnemonicKey(\n      kdf,\n      mnemonic,\n      password,\n      meta,\n      bip44HDPath\n    );\n  }\n\n  async createPrivateKey(\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    privateKey: Uint8Array,\n    password: string,\n    meta: Record<string, string>\n  ): Promise<{\n    status: KeyRingStatus;\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    return await this.keyRing.createPrivateKey(kdf, privateKey, password, meta);\n  }\n\n  async createLedgerKey(\n    env: Env,\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    password: string,\n    meta: Record<string, string>,\n    bip44HDPath: BIP44HDPath\n  ): Promise<{\n    status: KeyRingStatus;\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    return await this.keyRing.createLedgerKey(\n      env,\n      kdf,\n      password,\n      meta,\n      bip44HDPath\n    );\n  }\n\n  lock(): KeyRingStatus {\n    this.keyRing.lock();\n    return this.keyRing.status;\n  }\n\n  async unlock(password: string): Promise<KeyRingStatus> {\n    await this.keyRing.unlock(password);\n\n    return this.keyRing.status;\n  }\n\n  async getKey(chainId: string): Promise<Key> {\n    return this.keyRing.getKey(\n      chainId,\n      await this.chainsService.getChainCoinType(chainId),\n      (await this.chainsService.getChainEthereumKeyFeatures(chainId)).address\n    );\n  }\n\n  getKeyStoreMeta(key: string): string {\n    return this.keyRing.getKeyStoreMeta(key);\n  }\n\n  getKeyRingType(): string {\n    return this.keyRing.type;\n  }\n\n  async requestSignAmino(\n    env: Env,\n    msgOrigin: string,\n    chainId: string,\n    signer: string,\n    signDoc: StdSignDoc,\n    signOptions: KeplrSignOptions & {\n      // Hack option field to detect the sign arbitrary for string\n      isADR36WithString?: boolean;\n      ethSignType?: EthSignType;\n    }\n  ): Promise<AminoSignResponse> {\n    signDoc = {\n      ...signDoc,\n      memo: escapeHTML(signDoc.memo),\n    };\n\n    const coinType = await this.chainsService.getChainCoinType(chainId);\n    const ethereumKeyFeatures = await this.chainsService.getChainEthereumKeyFeatures(\n      chainId\n    );\n\n    const key = await this.keyRing.getKey(\n      chainId,\n      coinType,\n      ethereumKeyFeatures.address\n    );\n    const bech32Prefix = (await this.chainsService.getChainInfo(chainId))\n      .bech32Config.bech32PrefixAccAddr;\n    const bech32Address = new Bech32Address(key.address).toBech32(bech32Prefix);\n    if (signer !== bech32Address) {\n      throw new KeplrError(\"keyring\", 231, \"Signer mismatched\");\n    }\n\n    const isADR36SignDoc = checkAndValidateADR36AminoSignDoc(\n      signDoc,\n      bech32Prefix\n    );\n    if (isADR36SignDoc) {\n      if (signDoc.msgs[0].value.signer !== signer) {\n        throw new KeplrError(\"keyring\", 233, \"Unmatched signer in sign doc\");\n      }\n    }\n\n    if (signOptions.isADR36WithString != null && !isADR36SignDoc) {\n      throw new KeplrError(\n        \"keyring\",\n        236,\n        'Sign doc is not for ADR-36. But, \"isADR36WithString\" option is defined'\n      );\n    }\n\n    if (signOptions.ethSignType && !isADR36SignDoc) {\n      throw new Error(\n        \"Eth sign type can be requested with only ADR-36 amino sign doc\"\n      );\n    }\n\n    let newSignDoc = (await this.interactionService.waitApprove(\n      env,\n      \"/sign\",\n      \"request-sign\",\n      {\n        msgOrigin,\n        chainId,\n        mode: \"amino\",\n        signDoc,\n        signer,\n        signOptions,\n        isADR36SignDoc,\n        isADR36WithString: signOptions.isADR36WithString,\n        ethSignType: signOptions.ethSignType,\n      }\n    )) as StdSignDoc;\n\n    newSignDoc = {\n      ...newSignDoc,\n      memo: escapeHTML(newSignDoc.memo),\n    };\n\n    if (isADR36SignDoc) {\n      // Validate the new sign doc, if it was for ADR-36.\n      if (checkAndValidateADR36AminoSignDoc(signDoc, bech32Prefix)) {\n        if (signDoc.msgs[0].value.signer !== signer) {\n          throw new KeplrError(\n            \"keyring\",\n            232,\n            \"Unmatched signer in new sign doc\"\n          );\n        }\n      } else {\n        throw new KeplrError(\n          \"keyring\",\n          237,\n          \"Signing request was for ADR-36. But, accidentally, new sign doc is not for ADR-36\"\n        );\n      }\n    }\n\n    // Handle Ethereum signing\n    if (signOptions.ethSignType) {\n      if (newSignDoc.msgs.length !== 1) {\n        // Validate number of messages\n        throw new Error(\"Invalid number of messages for Ethereum sign request\");\n      }\n\n      const signBytes = Buffer.from(newSignDoc.msgs[0].value.data, \"base64\");\n\n      try {\n        const signatureBytes = await this.keyRing.signEthereum(\n          chainId,\n          coinType,\n          signBytes,\n          signOptions.ethSignType\n        );\n\n        return {\n          signed: newSignDoc, // Included to match return type\n          signature: {\n            pub_key: encodeSecp256k1Pubkey(key.pubKey), // Included to match return type\n            signature: Buffer.from(signatureBytes).toString(\"base64\"), // No byte limit\n          },\n        };\n      } finally {\n        this.interactionService.dispatchEvent(APP_PORT, \"request-sign-end\", {});\n      }\n    }\n\n    try {\n      const signature = await this.keyRing.sign(\n        env,\n        chainId,\n        coinType,\n        serializeSignDoc(newSignDoc),\n        ethereumKeyFeatures.signing\n      );\n\n      return {\n        signed: newSignDoc,\n        signature: encodeSecp256k1Signature(key.pubKey, signature),\n      };\n    } finally {\n      this.interactionService.dispatchEvent(APP_PORT, \"request-sign-end\", {});\n    }\n  }\n\n  async requestSignDirect(\n    env: Env,\n    msgOrigin: string,\n    chainId: string,\n    signer: string,\n    signDoc: SignDoc,\n    signOptions: KeplrSignOptions\n  ): Promise<DirectSignResponse> {\n    const coinType = await this.chainsService.getChainCoinType(chainId);\n    const ethereumKeyFeatures = await this.chainsService.getChainEthereumKeyFeatures(\n      chainId\n    );\n\n    const key = await this.keyRing.getKey(\n      chainId,\n      coinType,\n      ethereumKeyFeatures.address\n    );\n    const bech32Address = new Bech32Address(key.address).toBech32(\n      (await this.chainsService.getChainInfo(chainId)).bech32Config\n        .bech32PrefixAccAddr\n    );\n    if (signer !== bech32Address) {\n      throw new KeplrError(\"keyring\", 231, \"Signer mismatched\");\n    }\n\n    const newSignDocBytes = (await this.interactionService.waitApprove(\n      env,\n      \"/sign\",\n      \"request-sign\",\n      {\n        msgOrigin,\n        chainId,\n        mode: \"direct\",\n        signDocBytes: SignDoc.encode(signDoc).finish(),\n        signer,\n        signOptions,\n      }\n    )) as Uint8Array;\n\n    const newSignDoc = SignDoc.decode(newSignDocBytes);\n    const {\n      accountNumber: newSignDocAccountNumber,\n      ...newSignDocRest\n    } = newSignDoc;\n    const cosmJSSignDoc = {\n      ...newSignDocRest,\n      accountNumber: Long.fromString(newSignDocAccountNumber),\n    };\n\n    try {\n      const signature = await this.keyRing.sign(\n        env,\n        chainId,\n        coinType,\n        makeSignBytes(cosmJSSignDoc),\n        ethereumKeyFeatures.signing\n      );\n\n      return {\n        signed: cosmJSSignDoc,\n        signature: encodeSecp256k1Signature(key.pubKey, signature),\n      };\n    } finally {\n      this.interactionService.dispatchEvent(APP_PORT, \"request-sign-end\", {});\n    }\n  }\n\n  async verifyADR36AminoSignDoc(\n    chainId: string,\n    signer: string,\n    data: Uint8Array,\n    signature: StdSignature\n  ): Promise<boolean> {\n    const coinType = await this.chainsService.getChainCoinType(chainId);\n    const ethereumKeyFeatures = await this.chainsService.getChainEthereumKeyFeatures(\n      chainId\n    );\n\n    const key = await this.keyRing.getKey(\n      chainId,\n      coinType,\n      ethereumKeyFeatures.address\n    );\n    const bech32Prefix = (await this.chainsService.getChainInfo(chainId))\n      .bech32Config.bech32PrefixAccAddr;\n    const bech32Address = new Bech32Address(key.address).toBech32(bech32Prefix);\n    if (signer !== bech32Address) {\n      throw new KeplrError(\"keyring\", 231, \"Signer mismatched\");\n    }\n    if (signature.pub_key.type !== \"tendermint/PubKeySecp256k1\") {\n      throw new KeplrError(\n        \"keyring\",\n        211,\n        `Unsupported type of pub key: ${signature.pub_key.type}`\n      );\n    }\n    if (\n      Buffer.from(key.pubKey).toString(\"base64\") !== signature.pub_key.value\n    ) {\n      throw new KeplrError(\"keyring\", 210, \"Pub key unmatched\");\n    }\n\n    const signDoc = makeADR36AminoSignDoc(signer, data);\n\n    return verifyADR36AminoSignDoc(\n      bech32Prefix,\n      signDoc,\n      Buffer.from(signature.pub_key.value, \"base64\"),\n      Buffer.from(signature.signature, \"base64\")\n    );\n  }\n\n  async sign(\n    env: Env,\n    chainId: string,\n    message: Uint8Array\n  ): Promise<Uint8Array> {\n    return this.keyRing.sign(\n      env,\n      chainId,\n      await this.chainsService.getChainCoinType(chainId),\n      message,\n      (await this.chainsService.getChainEthereumKeyFeatures(chainId)).signing\n    );\n  }\n\n  async addMnemonicKey(\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    mnemonic: string,\n    meta: Record<string, string>,\n    bip44HDPath: BIP44HDPath\n  ): Promise<{\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    return this.keyRing.addMnemonicKey(kdf, mnemonic, meta, bip44HDPath);\n  }\n\n  async addPrivateKey(\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    privateKey: Uint8Array,\n    meta: Record<string, string>\n  ): Promise<{\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    return this.keyRing.addPrivateKey(kdf, privateKey, meta);\n  }\n\n  async addLedgerKey(\n    env: Env,\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    meta: Record<string, string>,\n    bip44HDPath: BIP44HDPath\n  ): Promise<{\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    return this.keyRing.addLedgerKey(env, kdf, meta, bip44HDPath);\n  }\n\n  public async changeKeyStoreFromMultiKeyStore(\n    index: number\n  ): Promise<{\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    try {\n      return await this.keyRing.changeKeyStoreFromMultiKeyStore(index);\n    } finally {\n      this.interactionService.dispatchEvent(\n        WEBPAGE_PORT,\n        \"keystore-changed\",\n        {}\n      );\n    }\n  }\n\n  public checkPassword(password: string): boolean {\n    return this.keyRing.checkPassword(password);\n  }\n\n  getMultiKeyStoreInfo(): MultiKeyStoreInfoWithSelected {\n    return this.keyRing.getMultiKeyStoreInfo();\n  }\n\n  isKeyStoreCoinTypeSet(chainId: string): boolean {\n    return this.keyRing.isKeyStoreCoinTypeSet(chainId);\n  }\n\n  async setKeyStoreCoinType(chainId: string, coinType: number): Promise<void> {\n    const prevCoinType = this.keyRing.computeKeyStoreCoinType(\n      chainId,\n      await this.chainsService.getChainCoinType(chainId)\n    );\n\n    await this.keyRing.setKeyStoreCoinType(chainId, coinType);\n\n    if (prevCoinType !== coinType) {\n      this.interactionService.dispatchEvent(\n        WEBPAGE_PORT,\n        \"keystore-changed\",\n        {}\n      );\n    }\n  }\n\n  async getKeyStoreBIP44Selectables(\n    chainId: string,\n    paths: BIP44[]\n  ): Promise<{ readonly path: BIP44; readonly bech32Address: string }[]> {\n    if (this.isKeyStoreCoinTypeSet(chainId)) {\n      return [];\n    }\n\n    const result = [];\n    const chainInfo = await this.chainsService.getChainInfo(chainId);\n\n    for (const path of paths) {\n      const key = await this.keyRing.getKeyFromCoinType(\n        path.coinType,\n        (await this.chainsService.getChainEthereumKeyFeatures(chainId)).address\n      );\n      const bech32Address = new Bech32Address(key.address).toBech32(\n        chainInfo.bech32Config.bech32PrefixAccAddr\n      );\n\n      result.push({\n        path,\n        bech32Address,\n      });\n    }\n\n    return result;\n  }\n\n  async exportKeyRingDatas(password: string): Promise<ExportKeyRingData[]> {\n    return await this.keyRing.exportKeyRingDatas(password);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}