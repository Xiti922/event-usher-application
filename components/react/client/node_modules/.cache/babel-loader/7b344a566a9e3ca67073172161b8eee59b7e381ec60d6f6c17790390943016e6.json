{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LedgerService = void 0;\nconst ledger_1 = require(\"./ledger\");\nconst delay_1 = __importDefault(require(\"delay\"));\nconst router_1 = require(\"@keplr-wallet/router\");\nconst buffer_1 = require(\"buffer/\");\nclass LedgerService {\n  constructor(kvStore, options) {\n    var _a;\n    this.kvStore = kvStore;\n    this.options = {\n      defaultMode: options.defaultMode || \"webusb\",\n      transportIniters: (_a = options.transportIniters) !== null && _a !== void 0 ? _a : {}\n    };\n    if (!this.options.transportIniters[\"webusb\"]) {\n      this.options.transportIniters[\"webusb\"] = ledger_1.LedgerWebUSBIniter;\n    }\n    if (!this.options.transportIniters[\"webhid\"]) {\n      this.options.transportIniters[\"webhid\"] = ledger_1.LedgerWebHIDIniter;\n    }\n  }\n  init(interactionService) {\n    this.interactionService = interactionService;\n  }\n  getPublicKey(env, bip44HDPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.useLedger(env, (ledger, retryCount) => __awaiter(this, void 0, void 0, function* () {\n        try {\n          // Cosmos App on Ledger doesn't support the coin type other than 118.\n          return yield ledger.getPublicKey([44, 118, bip44HDPath.account, bip44HDPath.change, bip44HDPath.addressIndex]);\n        } finally {\n          // Notify UI Ledger pubkey derivation succeeded only when Ledger initialization is tried again.\n          if (retryCount > 0) {\n            this.interactionService.dispatchEvent(router_1.APP_PORT, \"ledger-init\", {\n              event: \"get-pubkey\",\n              success: true\n            });\n          }\n        }\n      }));\n    });\n  }\n  sign(env, bip44HDPath, expectedPubKey, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.useLedger(env, (ledger, retryCount) => __awaiter(this, void 0, void 0, function* () {\n        try {\n          const pubKey = yield ledger.getPublicKey([44, 118, bip44HDPath.account, bip44HDPath.change, bip44HDPath.addressIndex]);\n          if (buffer_1.Buffer.from(expectedPubKey).toString(\"hex\") !== buffer_1.Buffer.from(pubKey).toString(\"hex\")) {\n            throw new router_1.KeplrError(\"ledger\", 110, \"Unmatched public key\");\n          }\n          // Cosmos App on Ledger doesn't support the coin type other than 118.\n          const signature = yield ledger.sign([44, 118, bip44HDPath.account, bip44HDPath.change, bip44HDPath.addressIndex], message);\n          // Notify UI Ledger signing succeeded only when Ledger initialization is tried again.\n          if (retryCount > 0) {\n            this.interactionService.dispatchEvent(router_1.APP_PORT, \"ledger-init\", {\n              event: \"sign\",\n              success: true\n            });\n          }\n          return signature;\n        } catch (e) {\n          // Notify UI Ledger signing failed only when Ledger initialization is tried again.\n          if (retryCount > 0) {\n            this.interactionService.dispatchEvent(router_1.APP_PORT, \"ledger-init\", {\n              event: \"sign\",\n              success: false\n            });\n          }\n          throw e;\n        }\n      }));\n    });\n  }\n  useLedger(env, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let ledger;\n      try {\n        ledger = yield this.initLedger(env);\n        return yield fn(ledger.ledger, ledger.retryCount);\n      } finally {\n        if (ledger) {\n          yield ledger.ledger.close();\n        }\n      }\n    });\n  }\n  initLedger(env) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.previousInitAborter) {\n        this.previousInitAborter(new Error(\"New ledger request occurred before the ledger was initialized\"));\n      }\n      const aborter = (() => {\n        let _reject;\n        return {\n          wait: () => {\n            return new Promise((_, reject) => {\n              _reject = reject;\n            });\n          },\n          abort: e => {\n            if (_reject) {\n              _reject(e);\n            }\n          }\n        };\n      })();\n      // This ensures that the ledger connection is not executed concurrently.\n      // Without this, the prior signing request can be delivered to the ledger and possibly make a user take a mistake.\n      this.previousInitAborter = aborter.abort;\n      let retryCount = 0;\n      let initArgs = [];\n      while (true) {\n        const mode = yield this.getMode();\n        try {\n          const transportIniter = this.options.transportIniters[mode];\n          if (!transportIniter) {\n            throw new router_1.KeplrError(\"ledger\", 112, `Unknown mode: ${mode}`);\n          }\n          const ledger = yield ledger_1.Ledger.init(transportIniter, initArgs);\n          this.previousInitAborter = undefined;\n          return {\n            ledger,\n            retryCount\n          };\n        } catch (e) {\n          console.log(e);\n          const timeoutAbortController = new AbortController();\n          try {\n            const promises = [(() => __awaiter(this, void 0, void 0, function* () {\n              const response = yield this.interactionService.waitApprove(env, \"/ledger-grant\", \"ledger-init\", {\n                event: \"init-failed\",\n                mode\n              }, {\n                forceOpenWindow: true,\n                channel: \"ledger\"\n              });\n              if (response === null || response === void 0 ? void 0 : response.abort) {\n                throw new router_1.KeplrError(\"ledger\", 120, \"Ledger init aborted\");\n              }\n              if (response === null || response === void 0 ? void 0 : response.initArgs) {\n                initArgs = response.initArgs;\n              }\n            }))()];\n            promises.push((() => __awaiter(this, void 0, void 0, function* () {\n              let timeoutAborted = false;\n              // If ledger is not inited in 5 minutes, abort it.\n              try {\n                yield delay_1.default(5 * 60 * 1000, {\n                  signal: timeoutAbortController.signal\n                });\n              } catch (e) {\n                if (e.name === \"AbortError\") {\n                  timeoutAborted = true;\n                } else {\n                  throw e;\n                }\n              }\n              if (!timeoutAborted) {\n                this.interactionService.dispatchEvent(router_1.APP_PORT, \"ledger-init\", {\n                  event: \"init-aborted\",\n                  mode\n                });\n                throw new router_1.KeplrError(\"ledger\", 121, \"Ledger init timeout\");\n              }\n            }))());\n            promises.push(aborter.wait());\n            // Check that the Ledger Popup is opened only if the environment is extension.\n            if (typeof browser !== \"undefined\") {\n              promises.push(this.testLedgerGrantUIOpened());\n            }\n            yield Promise.race(promises);\n          } finally {\n            timeoutAbortController.abort();\n          }\n        }\n        retryCount++;\n      }\n    });\n  }\n  // Test that the exntesion's granting ledger page is opened.\n  testLedgerGrantUIOpened() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield delay_1.default(1000);\n      while (true) {\n        const views = browser.extension.getViews();\n        let find = false;\n        for (const view of views) {\n          if (view.location.href.includes(browser.runtime.getURL(\"popup.html#/ledger-grant\"))) {\n            find = true;\n            break;\n          }\n        }\n        if (!find) {\n          throw new router_1.KeplrError(\"ledger\", 120, \"Ledger init aborted\");\n        }\n        yield delay_1.default(1000);\n      }\n    });\n  }\n  /**\n   * Mode means that which transport should be used.\n   * \"webusb\" and \"webhid\" are used in the extension environment (web).\n   * Alternatively, custom mode can be supported by delivering the custom transport initer on the constructor.\n   * Maybe, the \"ble\" (bluetooth) mode would be supported in the mobile environment (only with Ledger Nano X).\n   */\n  getMode() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Backward compatibilty for the extension.\n      if (yield this.getWebHIDFlag()) {\n        return \"webhid\";\n      }\n      return this.options.defaultMode;\n    });\n  }\n  getWebHIDFlag() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const webHIDFlag = yield this.kvStore.get(\"webhid\");\n      return !!webHIDFlag;\n    });\n  }\n  setWebHIDFlag(flag) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.kvStore.set(\"webhid\", flag);\n    });\n  }\n}\nexports.LedgerService = LedgerService;","map":{"version":3,"mappings":"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","names":["LedgerService","constructor","kvStore","options","defaultMode","transportIniters","ledger_1","init","interactionService","getPublicKey","env","bip44HDPath","useLedger","ledger","retryCount","__awaiter","account","change","addressIndex","dispatchEvent","router_1","event","success","sign","expectedPubKey","message","pubKey","buffer_1","from","toString","signature","e","fn","initLedger","close","previousInitAborter","Error","aborter","_reject","wait","Promise","_","reject","abort","initArgs","mode","getMode","transportIniter","undefined","console","log","timeoutAbortController","AbortController","promises","response","waitApprove","forceOpenWindow","channel","push","timeoutAborted","delay_1","signal","name","browser","testLedgerGrantUIOpened","race","views","extension","getViews","find","view","location","href","includes","runtime","getURL","getWebHIDFlag","webHIDFlag","get","setWebHIDFlag","flag","set","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/background/src/ledger/service.ts"],"sourcesContent":["import { Ledger, LedgerWebHIDIniter, LedgerWebUSBIniter } from \"./ledger\";\n\nimport delay from \"delay\";\n\nimport { APP_PORT, Env, KeplrError } from \"@keplr-wallet/router\";\nimport { BIP44HDPath } from \"../keyring\";\nimport { KVStore } from \"@keplr-wallet/common\";\nimport { InteractionService } from \"../interaction\";\nimport { LedgerOptions } from \"./options\";\nimport { Buffer } from \"buffer/\";\n\nexport class LedgerService {\n  private previousInitAborter: ((e: Error) => void) | undefined;\n\n  protected options: LedgerOptions;\n\n  protected interactionService!: InteractionService;\n\n  constructor(\n    protected readonly kvStore: KVStore,\n    options: Partial<LedgerOptions>\n  ) {\n    this.options = {\n      defaultMode: options.defaultMode || \"webusb\",\n      transportIniters: options.transportIniters ?? {},\n    };\n\n    if (!this.options.transportIniters[\"webusb\"]) {\n      this.options.transportIniters[\"webusb\"] = LedgerWebUSBIniter;\n    }\n    if (!this.options.transportIniters[\"webhid\"]) {\n      this.options.transportIniters[\"webhid\"] = LedgerWebHIDIniter;\n    }\n  }\n\n  init(interactionService: InteractionService) {\n    this.interactionService = interactionService;\n  }\n\n  async getPublicKey(env: Env, bip44HDPath: BIP44HDPath): Promise<Uint8Array> {\n    return await this.useLedger(env, async (ledger, retryCount) => {\n      try {\n        // Cosmos App on Ledger doesn't support the coin type other than 118.\n        return await ledger.getPublicKey([\n          44,\n          118,\n          bip44HDPath.account,\n          bip44HDPath.change,\n          bip44HDPath.addressIndex,\n        ]);\n      } finally {\n        // Notify UI Ledger pubkey derivation succeeded only when Ledger initialization is tried again.\n        if (retryCount > 0) {\n          this.interactionService.dispatchEvent(APP_PORT, \"ledger-init\", {\n            event: \"get-pubkey\",\n            success: true,\n          });\n        }\n      }\n    });\n  }\n\n  async sign(\n    env: Env,\n    bip44HDPath: BIP44HDPath,\n    expectedPubKey: Uint8Array,\n    message: Uint8Array\n  ): Promise<Uint8Array> {\n    return await this.useLedger(env, async (ledger, retryCount: number) => {\n      try {\n        const pubKey = await ledger.getPublicKey([\n          44,\n          118,\n          bip44HDPath.account,\n          bip44HDPath.change,\n          bip44HDPath.addressIndex,\n        ]);\n        if (\n          Buffer.from(expectedPubKey).toString(\"hex\") !==\n          Buffer.from(pubKey).toString(\"hex\")\n        ) {\n          throw new KeplrError(\"ledger\", 110, \"Unmatched public key\");\n        }\n        // Cosmos App on Ledger doesn't support the coin type other than 118.\n        const signature = await ledger.sign(\n          [\n            44,\n            118,\n            bip44HDPath.account,\n            bip44HDPath.change,\n            bip44HDPath.addressIndex,\n          ],\n          message\n        );\n        // Notify UI Ledger signing succeeded only when Ledger initialization is tried again.\n        if (retryCount > 0) {\n          this.interactionService.dispatchEvent(APP_PORT, \"ledger-init\", {\n            event: \"sign\",\n            success: true,\n          });\n        }\n        return signature;\n      } catch (e) {\n        // Notify UI Ledger signing failed only when Ledger initialization is tried again.\n        if (retryCount > 0) {\n          this.interactionService.dispatchEvent(APP_PORT, \"ledger-init\", {\n            event: \"sign\",\n            success: false,\n          });\n        }\n        throw e;\n      }\n    });\n  }\n\n  async useLedger<T>(\n    env: Env,\n    fn: (ledger: Ledger, retryCount: number) => Promise<T>\n  ): Promise<T> {\n    let ledger: { ledger: Ledger; retryCount: number } | undefined;\n    try {\n      ledger = await this.initLedger(env);\n      return await fn(ledger.ledger, ledger.retryCount);\n    } finally {\n      if (ledger) {\n        await ledger.ledger.close();\n      }\n    }\n  }\n\n  async initLedger(env: Env): Promise<{ ledger: Ledger; retryCount: number }> {\n    if (this.previousInitAborter) {\n      this.previousInitAborter(\n        new Error(\n          \"New ledger request occurred before the ledger was initialized\"\n        )\n      );\n    }\n\n    const aborter = (() => {\n      let _reject: (reason?: any) => void | undefined;\n\n      return {\n        wait: () => {\n          return new Promise((_, reject) => {\n            _reject = reject;\n          });\n        },\n        abort: (e: Error) => {\n          if (_reject) {\n            _reject(e);\n          }\n        },\n      };\n    })();\n\n    // This ensures that the ledger connection is not executed concurrently.\n    // Without this, the prior signing request can be delivered to the ledger and possibly make a user take a mistake.\n    this.previousInitAborter = aborter.abort;\n\n    let retryCount = 0;\n    let initArgs: any[] = [];\n    while (true) {\n      const mode = await this.getMode();\n      try {\n        const transportIniter = this.options.transportIniters[mode];\n        if (!transportIniter) {\n          throw new KeplrError(\"ledger\", 112, `Unknown mode: ${mode}`);\n        }\n\n        const ledger = await Ledger.init(transportIniter, initArgs);\n        this.previousInitAborter = undefined;\n        return {\n          ledger,\n          retryCount,\n        };\n      } catch (e) {\n        console.log(e);\n\n        const timeoutAbortController = new AbortController();\n\n        try {\n          const promises: Promise<unknown>[] = [\n            (async () => {\n              const response = (await this.interactionService.waitApprove(\n                env,\n                \"/ledger-grant\",\n                \"ledger-init\",\n                {\n                  event: \"init-failed\",\n                  mode,\n                },\n                {\n                  forceOpenWindow: true,\n                  channel: \"ledger\",\n                }\n              )) as\n                | {\n                    abort?: boolean;\n                    initArgs?: any[];\n                  }\n                | undefined;\n\n              if (response?.abort) {\n                throw new KeplrError(\"ledger\", 120, \"Ledger init aborted\");\n              }\n\n              if (response?.initArgs) {\n                initArgs = response.initArgs;\n              }\n            })(),\n          ];\n\n          promises.push(\n            (async () => {\n              let timeoutAborted = false;\n              // If ledger is not inited in 5 minutes, abort it.\n              try {\n                await delay(5 * 60 * 1000, {\n                  signal: timeoutAbortController.signal,\n                });\n              } catch (e) {\n                if (e.name === \"AbortError\") {\n                  timeoutAborted = true;\n                } else {\n                  throw e;\n                }\n              }\n              if (!timeoutAborted) {\n                this.interactionService.dispatchEvent(APP_PORT, \"ledger-init\", {\n                  event: \"init-aborted\",\n                  mode,\n                });\n                throw new KeplrError(\"ledger\", 121, \"Ledger init timeout\");\n              }\n            })()\n          );\n\n          promises.push(aborter.wait());\n\n          // Check that the Ledger Popup is opened only if the environment is extension.\n          if (typeof browser !== \"undefined\") {\n            promises.push(this.testLedgerGrantUIOpened());\n          }\n\n          await Promise.race(promises);\n        } finally {\n          timeoutAbortController.abort();\n        }\n      }\n\n      retryCount++;\n    }\n  }\n\n  // Test that the exntesion's granting ledger page is opened.\n  async testLedgerGrantUIOpened() {\n    await delay(1000);\n\n    while (true) {\n      const views = browser.extension.getViews();\n      let find = false;\n      for (const view of views) {\n        if (\n          view.location.href.includes(\n            browser.runtime.getURL(\"popup.html#/ledger-grant\")\n          )\n        ) {\n          find = true;\n          break;\n        }\n      }\n\n      if (!find) {\n        throw new KeplrError(\"ledger\", 120, \"Ledger init aborted\");\n      }\n\n      await delay(1000);\n    }\n  }\n\n  /**\n   * Mode means that which transport should be used.\n   * \"webusb\" and \"webhid\" are used in the extension environment (web).\n   * Alternatively, custom mode can be supported by delivering the custom transport initer on the constructor.\n   * Maybe, the \"ble\" (bluetooth) mode would be supported in the mobile environment (only with Ledger Nano X).\n   */\n  async getMode(): Promise<string> {\n    // Backward compatibilty for the extension.\n    if (await this.getWebHIDFlag()) {\n      return \"webhid\";\n    }\n\n    return this.options.defaultMode;\n  }\n\n  async getWebHIDFlag(): Promise<boolean> {\n    const webHIDFlag = await this.kvStore.get<boolean>(\"webhid\");\n    return !!webHIDFlag;\n  }\n\n  async setWebHIDFlag(flag: boolean): Promise<void> {\n    await this.kvStore.set<boolean>(\"webhid\", flag);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}