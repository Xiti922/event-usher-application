{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ensureLeftNeighbor = exports.ensureSpec = exports.calculateExistenceRoot = exports.verifyNonExistence = exports.verifyExistence = exports.smtSpec = exports.tendermintSpec = exports.iavlSpec = void 0;\nconst codecimpl_1 = require(\"./generated/codecimpl\");\nconst ops_1 = require(\"./ops\");\nconst specs_1 = require(\"./specs\");\nexports.iavlSpec = {\n  leafSpec: {\n    prefix: Uint8Array.from([0]),\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    length: codecimpl_1.ics23.LengthOp.VAR_PROTO\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    minPrefixLength: 4,\n    maxPrefixLength: 12,\n    childSize: 33,\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  }\n};\nexports.tendermintSpec = {\n  leafSpec: {\n    prefix: Uint8Array.from([0]),\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    length: codecimpl_1.ics23.LengthOp.VAR_PROTO\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    minPrefixLength: 1,\n    maxPrefixLength: 1,\n    childSize: 32,\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  }\n};\nexports.smtSpec = {\n  leafSpec: {\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    length: codecimpl_1.ics23.LengthOp.NO_PREFIX,\n    prefix: Uint8Array.from([0])\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    childSize: 32,\n    minPrefixLength: 1,\n    maxPrefixLength: 1,\n    emptyChild: new Uint8Array(32),\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  },\n  maxDepth: 256\n};\n// verifyExistence will throw an error if the proof doesn't link key, value -> root\n// or if it doesn't fulfill the spec\nfunction verifyExistence(proof, spec, root, key, value) {\n  ensureSpec(proof, spec);\n  const calc = calculateExistenceRoot(proof);\n  (0, specs_1.ensureBytesEqual)(calc, root);\n  (0, specs_1.ensureBytesEqual)(key, proof.key);\n  (0, specs_1.ensureBytesEqual)(value, proof.value);\n}\nexports.verifyExistence = verifyExistence;\n// Verify does all checks to ensure the proof has valid non-existence proofs,\n// and they ensure the given key is not in the CommitmentState,\n// throwing an error if there is an issue\nfunction verifyNonExistence(proof, spec, root, key) {\n  let leftKey;\n  let rightKey;\n  if (proof.left) {\n    verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);\n    leftKey = proof.left.key;\n  }\n  if (proof.right) {\n    verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);\n    rightKey = proof.right.key;\n  }\n  if (!leftKey && !rightKey) {\n    throw new Error(\"neither left nor right proof defined\");\n  }\n  if (leftKey) {\n    (0, specs_1.ensureBytesBefore)(leftKey, key);\n  }\n  if (rightKey) {\n    (0, specs_1.ensureBytesBefore)(key, rightKey);\n  }\n  if (!spec.innerSpec) {\n    throw new Error(\"no inner spec\");\n  }\n  if (!leftKey) {\n    ensureLeftMost(spec.innerSpec, proof.right.path);\n  } else if (!rightKey) {\n    ensureRightMost(spec.innerSpec, proof.left.path);\n  } else {\n    ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);\n  }\n  return;\n}\nexports.verifyNonExistence = verifyNonExistence;\n// Calculate determines the root hash that matches the given proof.\n// You must validate the result is what you have in a header.\n// Returns error if the calculations cannot be performed.\nfunction calculateExistenceRoot(proof) {\n  if (!proof.key || !proof.value) {\n    throw new Error(\"Existence proof needs key and value set\");\n  }\n  if (!proof.leaf) {\n    throw new Error(\"Existence proof must start with a leaf operation\");\n  }\n  const path = proof.path || [];\n  let res = (0, ops_1.applyLeaf)(proof.leaf, proof.key, proof.value);\n  for (const inner of path) {\n    res = (0, ops_1.applyInner)(inner, res);\n  }\n  return res;\n}\nexports.calculateExistenceRoot = calculateExistenceRoot;\n// ensureSpec throws an Error if proof doesn't fulfill spec\nfunction ensureSpec(proof, spec) {\n  if (!proof.leaf) {\n    throw new Error(\"Existence proof must start with a leaf operation\");\n  }\n  if (!spec.leafSpec) {\n    throw new Error(\"Spec must include leafSpec\");\n  }\n  if (!spec.innerSpec) {\n    throw new Error(\"Spec must include innerSpec\");\n  }\n  (0, specs_1.ensureLeaf)(proof.leaf, spec.leafSpec);\n  const path = proof.path || [];\n  if (spec.minDepth && path.length < spec.minDepth) {\n    throw new Error(`Too few inner nodes ${path.length}`);\n  }\n  if (spec.maxDepth && path.length > spec.maxDepth) {\n    throw new Error(`Too many inner nodes ${path.length}`);\n  }\n  for (const inner of path) {\n    (0, specs_1.ensureInner)(inner, spec.leafSpec.prefix, spec.innerSpec);\n  }\n}\nexports.ensureSpec = ensureSpec;\nfunction ensureLeftMost(spec, path) {\n  const {\n    minPrefix,\n    maxPrefix,\n    suffix\n  } = getPadding(spec, 0);\n  // ensure every step has a prefix and suffix defined to be leftmost\n  for (const step of path) {\n    if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n      throw new Error(\"Step not leftmost\");\n    }\n  }\n}\nfunction ensureRightMost(spec, path) {\n  const len = spec.childOrder.length - 1;\n  const {\n    minPrefix,\n    maxPrefix,\n    suffix\n  } = getPadding(spec, len);\n  // ensure every step has a prefix and suffix defined to be leftmost\n  for (const step of path) {\n    if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n      throw new Error(\"Step not leftmost\");\n    }\n  }\n}\nfunction ensureLeftNeighbor(spec, left, right) {\n  const mutleft = [...left];\n  const mutright = [...right];\n  let topleft = mutleft.pop();\n  let topright = mutright.pop();\n  while ((0, specs_1.bytesEqual)(topleft.prefix, topright.prefix) && (0, specs_1.bytesEqual)(topleft.suffix, topright.suffix)) {\n    topleft = mutleft.pop();\n    topright = mutright.pop();\n  }\n  // now topleft and topright are the first divergent nodes\n  // make sure they are left and right of each other\n  if (!isLeftStep(spec, topleft, topright)) {\n    throw new Error(`Not left neightbor at first divergent step`);\n  }\n  // make sure the paths are left and right most possibilities respectively\n  ensureRightMost(spec, mutleft);\n  ensureLeftMost(spec, mutright);\n}\nexports.ensureLeftNeighbor = ensureLeftNeighbor;\n// isLeftStep assumes left and right have common parents\n// checks if left is exactly one slot to the left of right\nfunction isLeftStep(spec, left, right) {\n  const leftidx = orderFromPadding(spec, left);\n  const rightidx = orderFromPadding(spec, right);\n  return rightidx === leftidx + 1;\n}\nfunction orderFromPadding(spec, inner) {\n  for (let branch = 0; branch < spec.childOrder.length; branch++) {\n    const {\n      minPrefix,\n      maxPrefix,\n      suffix\n    } = getPadding(spec, branch);\n    if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {\n      return branch;\n    }\n  }\n  throw new Error(`Cannot find any valid spacing for this node`);\n}\nfunction hasPadding(op, minPrefix, maxPrefix, suffix) {\n  if ((op.prefix || []).length < minPrefix) {\n    return false;\n  }\n  if ((op.prefix || []).length > maxPrefix) {\n    return false;\n  }\n  return (op.suffix || []).length === suffix;\n}\nfunction getPadding(spec, branch) {\n  const idx = getPosition(spec.childOrder, branch);\n  // count how many children are in the prefix\n  const prefix = idx * spec.childSize;\n  const minPrefix = prefix + spec.minPrefixLength;\n  const maxPrefix = prefix + spec.maxPrefixLength;\n  // count how many children are in the suffix\n  const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;\n  return {\n    minPrefix,\n    maxPrefix,\n    suffix\n  };\n}\nfunction getPosition(order, branch) {\n  if (branch < 0 || branch >= order.length) {\n    throw new Error(`Invalid branch: ${branch}`);\n  }\n  return order.findIndex(val => val === branch);\n}","map":{"version":3,"mappings":"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","names":["exports","leafSpec","prefix","Uint8Array","from","hash","codecimpl_1","HashOp","SHA256","prehashValue","prehashKey","NO_HASH","length","LengthOp","VAR_PROTO","innerSpec","childOrder","minPrefixLength","maxPrefixLength","childSize","NO_PREFIX","emptyChild","maxDepth","verifyExistence","proof","spec","root","key","value","ensureSpec","calc","calculateExistenceRoot","verifyNonExistence","leftKey","rightKey","left","right","Error","ensureLeftMost","path","ensureRightMost","ensureLeftNeighbor","leaf","res","inner","minDepth","minPrefix","maxPrefix","suffix","getPadding","step","hasPadding","len","mutleft","mutright","topleft","pop","topright","isLeftStep","leftidx","orderFromPadding","rightidx","branch","op","idx","getPosition","order","findIndex","val"],"sources":["../src/proofs.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}