{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableQueryProposalVote = exports.ObservableQueryProposalVoteInner = void 0;\nconst chain_query_1 = require(\"../../chain-query\");\nclass ObservableQueryProposalVoteInner extends chain_query_1.ObservableChainQuery {\n  constructor(kvStore, chainId, chainGetter, proposalsId, bech32Address) {\n    super(kvStore, chainId, chainGetter, `/cosmos/gov/v1beta1/proposals/${proposalsId}/votes/${bech32Address}`);\n    this.proposalId = proposalsId;\n    this.bech32Address = bech32Address;\n  }\n  get vote() {\n    if (!this.response) {\n      return \"Unspecified\";\n    }\n    switch (this.response.data.vote.option) {\n      case \"VOTE_OPTION_YES\":\n        return \"Yes\";\n      case \"VOTE_OPTION_ABSTAIN\":\n        return \"Abstain\";\n      case \"VOTE_OPTION_NO\":\n        return \"No\";\n      case \"VOTE_OPTION_NO_WITH_VETO\":\n        return \"NoWithVeto\";\n      default:\n        return \"Unspecified\";\n    }\n  }\n  canFetch() {\n    // If bech32 address is empty, it will always fail, so don't need to fetch it.\n    return this.bech32Address.length > 0;\n  }\n}\nexports.ObservableQueryProposalVoteInner = ObservableQueryProposalVoteInner;\nclass ObservableQueryProposalVote extends chain_query_1.ObservableChainQueryMap {\n  constructor(kvStore, chainId, chainGetter) {\n    super(kvStore, chainId, chainGetter, param => {\n      const {\n        proposalId,\n        voter\n      } = JSON.parse(param);\n      return new ObservableQueryProposalVoteInner(this.kvStore, this.chainId, this.chainGetter, proposalId, voter);\n    });\n    this.kvStore = kvStore;\n    this.chainId = chainId;\n    this.chainGetter = chainGetter;\n  }\n  getVote(proposalId, voter) {\n    const param = JSON.stringify({\n      proposalId,\n      voter\n    });\n    return this.get(param);\n  }\n}\nexports.ObservableQueryProposalVote = ObservableQueryProposalVote;","map":{"version":3,"mappings":";;;;;;AAAA;AAQA,MAAaA,gCAAiC,SAAQC,kCAAmC;EAIvFC,YACEC,OAAgB,EAChBC,OAAe,EACfC,WAAwB,EACxBC,WAAmB,EACnBC,aAAqB;IAErB,KAAK,CACHJ,OAAO,EACPC,OAAO,EACPC,WAAW,EACX,iCAAiCC,WAAW,UAAUC,aAAa,EAAE,CACtE;IAED,IAAI,CAACC,UAAU,GAAGF,WAAW;IAC7B,IAAI,CAACC,aAAa,GAAGA,aAAa;EACpC;EAEA,IAAIE,IAAI;IACN,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE;MAClB,OAAO,aAAa;;IAGtB,QAAQ,IAAI,CAACA,QAAQ,CAACC,IAAI,CAACF,IAAI,CAACG,MAAM;MACpC,KAAK,iBAAiB;QACpB,OAAO,KAAK;MACd,KAAK,qBAAqB;QACxB,OAAO,SAAS;MAClB,KAAK,gBAAgB;QACnB,OAAO,IAAI;MACb,KAAK,0BAA0B;QAC7B,OAAO,YAAY;MACrB;QACE,OAAO,aAAa;IAAC;EAE3B;EAEUC,QAAQ;IAChB;IACA,OAAO,IAAI,CAACN,aAAa,CAACO,MAAM,GAAG,CAAC;EACtC;;AA5CFC;AA+CA,MAAaC,2BAA4B,SAAQf,qCAAsC;EACrFC,YACqBC,OAAgB,EAChBC,OAAe,EACfC,WAAwB;IAE3C,KAAK,CAACF,OAAO,EAAEC,OAAO,EAAEC,WAAW,EAAGY,KAAa,IAAI;MACrD,MAAM;QAAET,UAAU;QAAEU;MAAK,CAAE,GAAGC,IAAI,CAACC,KAAK,CAACH,KAAK,CAAC;MAE/C,OAAO,IAAIjB,gCAAgC,CACzC,IAAI,CAACG,OAAO,EACZ,IAAI,CAACC,OAAO,EACZ,IAAI,CAACC,WAAW,EAChBG,UAAU,EACVU,KAAK,CACN;IACH,CAAC,CAAC;IAdiB,YAAO,GAAPf,OAAO;IACP,YAAO,GAAPC,OAAO;IACP,gBAAW,GAAXC,WAAW;EAahC;EAEAgB,OAAO,CAACb,UAAkB,EAAEU,KAAa;IACvC,MAAMD,KAAK,GAAGE,IAAI,CAACG,SAAS,CAAC;MAC3Bd,UAAU;MACVU;KACD,CAAC;IACF,OAAO,IAAI,CAACK,GAAG,CAACN,KAAK,CAAqC;EAC5D;;AAzBFF","names":["ObservableQueryProposalVoteInner","chain_query_1","constructor","kvStore","chainId","chainGetter","proposalsId","bech32Address","proposalId","vote","response","data","option","canFetch","length","exports","ObservableQueryProposalVote","param","voter","JSON","parse","getVote","stringify","get"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/query/cosmos/governance/vote.ts"],"sourcesContent":["import {\n  ObservableChainQuery,\n  ObservableChainQueryMap,\n} from \"../../chain-query\";\nimport { ProposalVoter } from \"./types\";\nimport { KVStore } from \"@keplr-wallet/common\";\nimport { ChainGetter } from \"../../../common\";\n\nexport class ObservableQueryProposalVoteInner extends ObservableChainQuery<ProposalVoter> {\n  protected proposalId: string;\n  protected bech32Address: string;\n\n  constructor(\n    kvStore: KVStore,\n    chainId: string,\n    chainGetter: ChainGetter,\n    proposalsId: string,\n    bech32Address: string\n  ) {\n    super(\n      kvStore,\n      chainId,\n      chainGetter,\n      `/cosmos/gov/v1beta1/proposals/${proposalsId}/votes/${bech32Address}`\n    );\n\n    this.proposalId = proposalsId;\n    this.bech32Address = bech32Address;\n  }\n\n  get vote(): \"Yes\" | \"Abstain\" | \"No\" | \"NoWithVeto\" | \"Unspecified\" {\n    if (!this.response) {\n      return \"Unspecified\";\n    }\n\n    switch (this.response.data.vote.option) {\n      case \"VOTE_OPTION_YES\":\n        return \"Yes\";\n      case \"VOTE_OPTION_ABSTAIN\":\n        return \"Abstain\";\n      case \"VOTE_OPTION_NO\":\n        return \"No\";\n      case \"VOTE_OPTION_NO_WITH_VETO\":\n        return \"NoWithVeto\";\n      default:\n        return \"Unspecified\";\n    }\n  }\n\n  protected canFetch(): boolean {\n    // If bech32 address is empty, it will always fail, so don't need to fetch it.\n    return this.bech32Address.length > 0;\n  }\n}\n\nexport class ObservableQueryProposalVote extends ObservableChainQueryMap<ProposalVoter> {\n  constructor(\n    protected readonly kvStore: KVStore,\n    protected readonly chainId: string,\n    protected readonly chainGetter: ChainGetter\n  ) {\n    super(kvStore, chainId, chainGetter, (param: string) => {\n      const { proposalId, voter } = JSON.parse(param);\n\n      return new ObservableQueryProposalVoteInner(\n        this.kvStore,\n        this.chainId,\n        this.chainGetter,\n        proposalId,\n        voter\n      );\n    });\n  }\n\n  getVote(proposalId: string, voter: string): ObservableQueryProposalVoteInner {\n    const param = JSON.stringify({\n      proposalId,\n      voter,\n    });\n    return this.get(param) as ObservableQueryProposalVoteInner;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}