{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CoinGeckoPriceStore = void 0;\nconst common_1 = require(\"../common\");\nconst axios_1 = __importDefault(require(\"axios\"));\nconst common_2 = require(\"@keplr-wallet/common\");\nconst unit_1 = require(\"@keplr-wallet/unit\");\nconst deepmerge_1 = __importDefault(require(\"deepmerge\"));\nconst mobx_1 = require(\"mobx\");\nclass Throttler {\n  constructor(duration) {\n    this.duration = duration;\n    this.fns = [];\n    this.callback = () => {\n      if (this.timeoutId != null) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = undefined;\n      }\n      if (this.fns.length > 0) {\n        const fn = this.fns[this.fns.length - 1];\n        fn();\n        this.fns = [];\n      }\n    };\n  }\n  call(fn) {\n    if (this.duration <= 0) {\n      fn();\n      return;\n    }\n    this.fns.push(fn);\n    if (this.timeoutId != null) {\n      clearTimeout(this.timeoutId);\n    }\n    this.timeoutId = setTimeout(this.callback, this.duration);\n  }\n}\nclass SortedSetStorage {\n  constructor(kvStore, storeKey) {\n    let throttleDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this.array = [];\n    this.map = {};\n    this.restored = {};\n    this.isRestored = false;\n    this.storeKey = \"\";\n    if (!storeKey) {\n      throw new Error(\"Empty store key\");\n    }\n    this.kvStore = kvStore;\n    this.storeKey = storeKey;\n    this.throttler = new Throttler(throttleDuration);\n  }\n  has(value) {\n    return this.map[value] === true;\n  }\n  add() {\n    let forceSave = false;\n    let unknowns = [];\n    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n      values[_key] = arguments[_key];\n    }\n    for (const value of values) {\n      if (this.isRestored) {\n        if (this.restored[value]) {\n          forceSave = true;\n          delete this.restored[value];\n        }\n      }\n      if (!this.has(value)) {\n        unknowns.push(value);\n      }\n    }\n    if (unknowns.length === 0) {\n      if (this.isRestored && forceSave) {\n        // No need to wait\n        this.throttler.call(() => this.save());\n      }\n      return false;\n    }\n    // Remove duplicated.\n    unknowns = [...new Set(unknowns)];\n    for (const unknown of unknowns) {\n      this.map[unknown] = true;\n    }\n    let newArray = this.array.slice().concat(unknowns);\n    newArray = newArray.sort((id1, id2) => {\n      return id1 < id2 ? -1 : 1;\n    });\n    this.array = newArray;\n    if (this.isRestored) {\n      // No need to wait\n      this.throttler.call(() => this.save());\n    }\n    return true;\n  }\n  get values() {\n    return this.array.slice();\n  }\n  save() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.kvStore.set(this.storeKey, this.array.filter(value => !this.restored[value]));\n    });\n  }\n  restore() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const saved = yield this.kvStore.get(this.storeKey);\n      if (saved) {\n        for (const value of saved) {\n          this.restored[value] = true;\n        }\n        for (const value of this.array) {\n          if (this.restored[value]) {\n            delete this.restored[value];\n          }\n        }\n        this.add(...saved);\n      }\n      this.isRestored = true;\n    });\n  }\n}\nclass CoinGeckoPriceStore extends common_1.ObservableQuery {\n  constructor(kvStore, supportedVsCurrencies, defaultVsCurrency) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var _a;\n    const instance = axios_1.default.create({\n      baseURL: options.baseURL || \"https://api.coingecko.com/api/v3\"\n    });\n    super(kvStore, instance, \"/simple/price\");\n    this.isInitialized = false;\n    const throttleDuration = (_a = options.throttleDuration) !== null && _a !== void 0 ? _a : 250;\n    this._coinIds = new SortedSetStorage(kvStore, \"__coin_ids\", throttleDuration);\n    this._vsCurrencies = new SortedSetStorage(kvStore, \"__vs_currencies\", throttleDuration);\n    this._defaultVsCurrency = defaultVsCurrency;\n    this._supportedVsCurrencies = supportedVsCurrencies;\n    this._throttler = new Throttler(throttleDuration);\n    mobx_1.makeObservable(this);\n    this.restoreDefaultVsCurrency();\n  }\n  onStart() {\n    super.onStart();\n    return this.init();\n  }\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isInitialized) {\n        return;\n      }\n      yield Promise.all([this._coinIds.restore(), this._vsCurrencies.restore()]);\n      // No need to wait\n      this._coinIds.save();\n      this._vsCurrencies.save();\n      this.updateURL([], [], true);\n      this.isInitialized = true;\n    });\n  }\n  get defaultVsCurrency() {\n    return this._defaultVsCurrency;\n  }\n  setDefaultVsCurrency(defaultVsCurrency) {\n    this._defaultVsCurrency = defaultVsCurrency;\n    this.saveDefaultVsCurrency();\n  }\n  *restoreDefaultVsCurrency() {\n    const saved = yield* common_2.toGenerator(this.kvStore.get(\"__default_vs_currency\"));\n    if (saved) {\n      this._defaultVsCurrency = saved;\n    }\n  }\n  saveDefaultVsCurrency() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.kvStore.set(\"__default_vs_currency\", this.defaultVsCurrency);\n    });\n  }\n  get supportedVsCurrencies() {\n    return this._supportedVsCurrencies;\n  }\n  getFiatCurrency(currency) {\n    return this._supportedVsCurrencies[currency];\n  }\n  canFetch() {\n    return this._coinIds.values.length > 0 && this._vsCurrencies.values.length > 0;\n  }\n  fetchResponse(abortController) {\n    const _super = Object.create(null, {\n      fetchResponse: {\n        get: () => super.fetchResponse\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        response,\n        headers\n      } = yield _super.fetchResponse.call(this, abortController);\n      // Because this store only queries the price of the tokens that have been requested from start,\n      // it will remove the prior prices that have not been requested to just return the fetching result.\n      // So, to prevent this problem, merge the prior response and current response with retaining the prior response's price.\n      return {\n        headers,\n        response: Object.assign(Object.assign({}, response), {\n          data: deepmerge_1.default(this.response ? this.response.data : {}, response.data)\n        })\n      };\n    });\n  }\n  updateURL(coinIds, vsCurrencies) {\n    let forceSetUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const coinIdsUpdated = this._coinIds.add(...coinIds);\n    const vsCurrenciesUpdated = this._vsCurrencies.add(...vsCurrencies);\n    if (coinIdsUpdated || vsCurrenciesUpdated || forceSetUrl) {\n      const url = `/simple/price?ids=${this._coinIds.values.join(\",\")}&vs_currencies=${this._vsCurrencies.values.join(\",\")}`;\n      if (!this.isInitialized) {\n        this.setUrl(url);\n      } else {\n        this._throttler.call(() => this.setUrl(url));\n      }\n    }\n  }\n  getCacheKey() {\n    // Because the uri of the coingecko would be changed according to the coin ids and vsCurrencies.\n    // Therefore, just using the uri as the cache key is not useful.\n    return `${this.instance.name}-${this.instance.defaults.baseURL}${this.instance.getUri({\n      url: \"/simple/price\"\n    })}`;\n  }\n  getPrice(coinId, vsCurrency) {\n    if (!vsCurrency) {\n      vsCurrency = this.defaultVsCurrency;\n    }\n    if (!this.supportedVsCurrencies[vsCurrency]) {\n      return undefined;\n    }\n    this.updateURL([coinId], [vsCurrency]);\n    if (!this.response) {\n      return undefined;\n    }\n    const coinPrices = this.response.data[coinId];\n    if (!coinPrices) {\n      return undefined;\n    }\n    return coinPrices[vsCurrency];\n  }\n  calculatePrice(coin, vsCurrrency) {\n    if (!coin.currency.coinGeckoId) {\n      return undefined;\n    }\n    if (!vsCurrrency) {\n      vsCurrrency = this.defaultVsCurrency;\n    }\n    const fiatCurrency = this.supportedVsCurrencies[vsCurrrency];\n    if (!fiatCurrency) {\n      return undefined;\n    }\n    const price = this.getPrice(coin.currency.coinGeckoId, vsCurrrency);\n    if (price === undefined) {\n      return new unit_1.PricePretty(fiatCurrency, new unit_1.Int(0)).ready(false);\n    }\n    const dec = coin.toDec();\n    const priceDec = new unit_1.Dec(price.toString());\n    return new unit_1.PricePretty(fiatCurrency, dec.mul(priceDec));\n  }\n}\n__decorate([mobx_1.observable], CoinGeckoPriceStore.prototype, \"_defaultVsCurrency\", void 0);\n__decorate([mobx_1.action], CoinGeckoPriceStore.prototype, \"setDefaultVsCurrency\", null);\n__decorate([mobx_1.flow], CoinGeckoPriceStore.prototype, \"restoreDefaultVsCurrency\", null);\nexports.CoinGeckoPriceStore = CoinGeckoPriceStore;","map":{"version":3,"mappings":"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","names":["Throttler","constructor","duration","timeoutId","clearTimeout","undefined","fns","length","fn","call","push","setTimeout","callback","SortedSetStorage","kvStore","storeKey","throttleDuration","Error","throttler","has","value","map","add","forceSave","unknowns","values","isRestored","restored","save","Set","unknown","newArray","array","slice","concat","sort","id1","id2","set","filter","restore","saved","get","CoinGeckoPriceStore","common_1","supportedVsCurrencies","defaultVsCurrency","options","instance","axios_1","create","baseURL","isInitialized","_coinIds","_vsCurrencies","_defaultVsCurrency","_supportedVsCurrencies","_throttler","mobx_1","restoreDefaultVsCurrency","onStart","init","Promise","all","updateURL","setDefaultVsCurrency","saveDefaultVsCurrency","common_2","getFiatCurrency","currency","canFetch","fetchResponse","abortController","response","headers","_super","data","deepmerge_1","coinIds","vsCurrencies","forceSetUrl","coinIdsUpdated","vsCurrenciesUpdated","url","join","setUrl","getCacheKey","name","defaults","getUri","getPrice","coinId","vsCurrency","coinPrices","calculatePrice","coin","vsCurrrency","coinGeckoId","fiatCurrency","price","unit_1","ready","dec","toDec","priceDec","toString","mul","__decorate","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/price/index.ts"],"sourcesContent":["import { ObservableQuery, QueryResponse } from \"../common\";\nimport { CoinGeckoSimplePrice } from \"./types\";\nimport Axios from \"axios\";\nimport { KVStore, toGenerator } from \"@keplr-wallet/common\";\nimport { Dec, CoinPretty, Int, PricePretty } from \"@keplr-wallet/unit\";\nimport { FiatCurrency } from \"@keplr-wallet/types\";\nimport { DeepReadonly } from \"utility-types\";\nimport deepmerge from \"deepmerge\";\nimport { action, flow, makeObservable, observable } from \"mobx\";\n\nclass Throttler {\n  protected fns: (() => void)[] = [];\n\n  private timeoutId?: NodeJS.Timeout;\n\n  constructor(public readonly duration: number) {}\n\n  call(fn: () => void) {\n    if (this.duration <= 0) {\n      fn();\n      return;\n    }\n\n    this.fns.push(fn);\n\n    if (this.timeoutId != null) {\n      clearTimeout(this.timeoutId);\n    }\n\n    this.timeoutId = setTimeout(this.callback, this.duration);\n  }\n\n  protected callback = () => {\n    if (this.timeoutId != null) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = undefined;\n    }\n\n    if (this.fns.length > 0) {\n      const fn = this.fns[this.fns.length - 1];\n      fn();\n\n      this.fns = [];\n    }\n  };\n}\n\nclass SortedSetStorage {\n  protected array: string[] = [];\n  protected map: Record<string, boolean | undefined> = {};\n\n  protected restored: Record<string, boolean | undefined> = {};\n  protected isRestored: boolean = false;\n\n  protected kvStore: KVStore;\n  protected storeKey: string = \"\";\n\n  protected throttler: Throttler;\n\n  constructor(\n    kvStore: KVStore,\n    storeKey: string,\n    throttleDuration: number = 0\n  ) {\n    if (!storeKey) {\n      throw new Error(\"Empty store key\");\n    }\n\n    this.kvStore = kvStore;\n    this.storeKey = storeKey;\n\n    this.throttler = new Throttler(throttleDuration);\n  }\n\n  has(value: string): boolean {\n    return this.map[value] === true;\n  }\n\n  add(...values: string[]): boolean {\n    let forceSave = false;\n    let unknowns: string[] = [];\n    for (const value of values) {\n      if (this.isRestored) {\n        if (this.restored[value]) {\n          forceSave = true;\n          delete this.restored[value];\n        }\n      }\n\n      if (!this.has(value)) {\n        unknowns.push(value);\n      }\n    }\n    if (unknowns.length === 0) {\n      if (this.isRestored && forceSave) {\n        // No need to wait\n        this.throttler.call(() => this.save());\n      }\n\n      return false;\n    }\n    // Remove duplicated.\n    unknowns = [...new Set(unknowns)];\n\n    for (const unknown of unknowns) {\n      this.map[unknown] = true;\n    }\n\n    let newArray = this.array.slice().concat(unknowns);\n    newArray = newArray.sort((id1, id2) => {\n      return id1 < id2 ? -1 : 1;\n    });\n\n    this.array = newArray;\n\n    if (this.isRestored) {\n      // No need to wait\n      this.throttler.call(() => this.save());\n    }\n\n    return true;\n  }\n\n  get values(): string[] {\n    return this.array.slice();\n  }\n\n  async save(): Promise<void> {\n    await this.kvStore.set(\n      this.storeKey,\n      this.array.filter((value) => !this.restored[value])\n    );\n  }\n\n  async restore(): Promise<void> {\n    const saved = await this.kvStore.get<string[]>(this.storeKey);\n    if (saved) {\n      for (const value of saved) {\n        this.restored[value] = true;\n      }\n      for (const value of this.array) {\n        if (this.restored[value]) {\n          delete this.restored[value];\n        }\n      }\n\n      this.add(...saved);\n    }\n\n    this.isRestored = true;\n  }\n}\n\nexport class CoinGeckoPriceStore extends ObservableQuery<CoinGeckoSimplePrice> {\n  protected isInitialized: boolean;\n\n  private _coinIds: SortedSetStorage;\n  private _vsCurrencies: SortedSetStorage;\n\n  @observable\n  protected _defaultVsCurrency: string;\n\n  protected _supportedVsCurrencies: {\n    [vsCurrency: string]: FiatCurrency | undefined;\n  };\n\n  protected _throttler: Throttler;\n\n  constructor(\n    kvStore: KVStore,\n    supportedVsCurrencies: {\n      [vsCurrency: string]: FiatCurrency;\n    },\n    defaultVsCurrency: string,\n    options: {\n      readonly baseURL?: string;\n\n      // Default is 250ms\n      readonly throttleDuration?: number;\n    } = {}\n  ) {\n    const instance = Axios.create({\n      baseURL: options.baseURL || \"https://api.coingecko.com/api/v3\",\n    });\n\n    super(kvStore, instance, \"/simple/price\");\n\n    this.isInitialized = false;\n\n    const throttleDuration = options.throttleDuration ?? 250;\n\n    this._coinIds = new SortedSetStorage(\n      kvStore,\n      \"__coin_ids\",\n      throttleDuration\n    );\n    this._vsCurrencies = new SortedSetStorage(\n      kvStore,\n      \"__vs_currencies\",\n      throttleDuration\n    );\n    this._defaultVsCurrency = defaultVsCurrency;\n\n    this._supportedVsCurrencies = supportedVsCurrencies;\n\n    this._throttler = new Throttler(throttleDuration);\n\n    makeObservable(this);\n\n    this.restoreDefaultVsCurrency();\n  }\n\n  protected onStart() {\n    super.onStart();\n\n    return this.init();\n  }\n\n  async init() {\n    if (this.isInitialized) {\n      return;\n    }\n\n    await Promise.all([this._coinIds.restore(), this._vsCurrencies.restore()]);\n\n    // No need to wait\n    this._coinIds.save();\n    this._vsCurrencies.save();\n\n    this.updateURL([], [], true);\n\n    this.isInitialized = true;\n  }\n\n  get defaultVsCurrency(): string {\n    return this._defaultVsCurrency;\n  }\n\n  @action\n  setDefaultVsCurrency(defaultVsCurrency: string) {\n    this._defaultVsCurrency = defaultVsCurrency;\n    this.saveDefaultVsCurrency();\n  }\n\n  @flow\n  *restoreDefaultVsCurrency() {\n    const saved = yield* toGenerator(\n      this.kvStore.get<string>(\"__default_vs_currency\")\n    );\n    if (saved) {\n      this._defaultVsCurrency = saved;\n    }\n  }\n\n  async saveDefaultVsCurrency() {\n    await this.kvStore.set(\"__default_vs_currency\", this.defaultVsCurrency);\n  }\n\n  get supportedVsCurrencies(): DeepReadonly<{\n    [vsCurrency: string]: FiatCurrency | undefined;\n  }> {\n    return this._supportedVsCurrencies;\n  }\n\n  getFiatCurrency(currency: string): FiatCurrency | undefined {\n    return this._supportedVsCurrencies[currency];\n  }\n\n  protected canFetch(): boolean {\n    return (\n      this._coinIds.values.length > 0 && this._vsCurrencies.values.length > 0\n    );\n  }\n\n  protected async fetchResponse(\n    abortController: AbortController\n  ): Promise<{ response: QueryResponse<CoinGeckoSimplePrice>; headers: any }> {\n    const { response, headers } = await super.fetchResponse(abortController);\n    // Because this store only queries the price of the tokens that have been requested from start,\n    // it will remove the prior prices that have not been requested to just return the fetching result.\n    // So, to prevent this problem, merge the prior response and current response with retaining the prior response's price.\n    return {\n      headers,\n      response: {\n        ...response,\n        ...{\n          data: deepmerge(\n            this.response ? this.response.data : {},\n            response.data\n          ),\n        },\n      },\n    };\n  }\n\n  protected updateURL(\n    coinIds: string[],\n    vsCurrencies: string[],\n    forceSetUrl: boolean = false\n  ) {\n    const coinIdsUpdated = this._coinIds.add(...coinIds);\n    const vsCurrenciesUpdated = this._vsCurrencies.add(...vsCurrencies);\n\n    if (coinIdsUpdated || vsCurrenciesUpdated || forceSetUrl) {\n      const url = `/simple/price?ids=${this._coinIds.values.join(\n        \",\"\n      )}&vs_currencies=${this._vsCurrencies.values.join(\",\")}`;\n\n      if (!this.isInitialized) {\n        this.setUrl(url);\n      } else {\n        this._throttler.call(() => this.setUrl(url));\n      }\n    }\n  }\n\n  protected getCacheKey(): string {\n    // Because the uri of the coingecko would be changed according to the coin ids and vsCurrencies.\n    // Therefore, just using the uri as the cache key is not useful.\n    return `${this.instance.name}-${\n      this.instance.defaults.baseURL\n    }${this.instance.getUri({\n      url: \"/simple/price\",\n    })}`;\n  }\n\n  getPrice(coinId: string, vsCurrency?: string): number | undefined {\n    if (!vsCurrency) {\n      vsCurrency = this.defaultVsCurrency;\n    }\n\n    if (!this.supportedVsCurrencies[vsCurrency]) {\n      return undefined;\n    }\n\n    this.updateURL([coinId], [vsCurrency]);\n\n    if (!this.response) {\n      return undefined;\n    }\n\n    const coinPrices = this.response.data[coinId];\n    if (!coinPrices) {\n      return undefined;\n    }\n    return coinPrices[vsCurrency];\n  }\n\n  calculatePrice(\n    coin: CoinPretty,\n    vsCurrrency?: string\n  ): PricePretty | undefined {\n    if (!coin.currency.coinGeckoId) {\n      return undefined;\n    }\n\n    if (!vsCurrrency) {\n      vsCurrrency = this.defaultVsCurrency;\n    }\n\n    const fiatCurrency = this.supportedVsCurrencies[vsCurrrency];\n    if (!fiatCurrency) {\n      return undefined;\n    }\n\n    const price = this.getPrice(coin.currency.coinGeckoId, vsCurrrency);\n    if (price === undefined) {\n      return new PricePretty(fiatCurrency, new Int(0)).ready(false);\n    }\n\n    const dec = coin.toDec();\n    const priceDec = new Dec(price.toString());\n\n    return new PricePretty(fiatCurrency, dec.mul(priceDec));\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}