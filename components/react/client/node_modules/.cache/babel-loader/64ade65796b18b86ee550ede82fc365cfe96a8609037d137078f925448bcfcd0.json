{"ast":null,"code":"\"use strict\";\n\n/** Type which represents AES blocks */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst constant_time_1 = require(\"./constant-time\");\nconst wipe_1 = require(\"./wipe\");\n/** An AES block (128-bits) */\nclass Block {\n  constructor() {\n    this.data = new Uint8Array(Block.SIZE);\n  }\n  /**\n   * Clear the given array by setting its values to zero.\n   *\n   * WARNING: The fact that it sets bytes to zero can be relied on.\n   *\n   * There is no guarantee that this function makes data disappear from memory,\n   * as runtime implementation can, for example, have copying garbage collector\n   * that will make copies of sensitive data before we wipe it. Or that an\n   * operating system will write our data to swap or sleep image. Another thing\n   * is that an optimizing compiler can remove calls to this function or make it\n   * no-op. There's nothing we can do with it, so we just do our best and hope\n   * that everything will be okay and good will triumph over evil.\n   */\n  clear() {\n    wipe_1.wipe(this.data);\n  }\n  /**\n   * Make a copy of this block, returning a new block\n   */\n  clone() {\n    const ret = new Block();\n    ret.copy(this);\n    return ret;\n  }\n  /** Copy the contents of another block into this one */\n  copy(other) {\n    this.data.set(other.data);\n  }\n  /**\n   * Double a value over GF(2^128):\n   *\n   *     a<<1 if firstbit(a)=0\n   *     (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n   */\n  dbl() {\n    let carry = 0;\n    for (let i = Block.SIZE - 1; i >= 0; i--) {\n      const b = this.data[i] >>> 7 & 0xff;\n      this.data[i] = this.data[i] << 1 | carry;\n      carry = b;\n    }\n    this.data[Block.SIZE - 1] ^= constant_time_1.select(carry, Block.R, 0);\n    carry = 0;\n  }\n}\n/** Size of a block as used by the AES cipher */\nBlock.SIZE = 16;\n/** Minimal irreducible polynomial for a 128-bit block size */\nBlock.R = 0x87;\nexports.default = Block;","map":{"version":3,"names":["Object","defineProperty","exports","value","constant_time_1","require","wipe_1","Block","constructor","data","Uint8Array","SIZE","clear","wipe","clone","ret","copy","other","set","dbl","carry","i","b","select","R","default"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/miscreant/release/internals/block.js"],"sourcesContent":["\"use strict\";\n/** Type which represents AES blocks */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constant_time_1 = require(\"./constant-time\");\nconst wipe_1 = require(\"./wipe\");\n/** An AES block (128-bits) */\nclass Block {\n    constructor() {\n        this.data = new Uint8Array(Block.SIZE);\n    }\n    /**\n     * Clear the given array by setting its values to zero.\n     *\n     * WARNING: The fact that it sets bytes to zero can be relied on.\n     *\n     * There is no guarantee that this function makes data disappear from memory,\n     * as runtime implementation can, for example, have copying garbage collector\n     * that will make copies of sensitive data before we wipe it. Or that an\n     * operating system will write our data to swap or sleep image. Another thing\n     * is that an optimizing compiler can remove calls to this function or make it\n     * no-op. There's nothing we can do with it, so we just do our best and hope\n     * that everything will be okay and good will triumph over evil.\n     */\n    clear() {\n        wipe_1.wipe(this.data);\n    }\n    /**\n     * Make a copy of this block, returning a new block\n     */\n    clone() {\n        const ret = new Block();\n        ret.copy(this);\n        return ret;\n    }\n    /** Copy the contents of another block into this one */\n    copy(other) {\n        this.data.set(other.data);\n    }\n    /**\n     * Double a value over GF(2^128):\n     *\n     *     a<<1 if firstbit(a)=0\n     *     (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n     */\n    dbl() {\n        let carry = 0;\n        for (let i = Block.SIZE - 1; i >= 0; i--) {\n            const b = (this.data[i] >>> 7) & 0xff;\n            this.data[i] = (this.data[i] << 1) | carry;\n            carry = b;\n        }\n        this.data[Block.SIZE - 1] ^= constant_time_1.select(carry, Block.R, 0);\n        carry = 0;\n    }\n}\n/** Size of a block as used by the AES cipher */\nBlock.SIZE = 16;\n/** Minimal irreducible polynomial for a 128-bit block size */\nBlock.R = 0x87;\nexports.default = Block;\n"],"mappings":"AAAA,YAAY;;AACZ;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,MAAMC,eAAe,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAClD,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAChC;AACA,MAAME,KAAK,CAAC;EACRC,WAAW,GAAG;IACV,IAAI,CAACC,IAAI,GAAG,IAAIC,UAAU,CAACH,KAAK,CAACI,IAAI,CAAC;EAC1C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,KAAK,GAAG;IACJN,MAAM,CAACO,IAAI,CAAC,IAAI,CAACJ,IAAI,CAAC;EAC1B;EACA;AACJ;AACA;EACIK,KAAK,GAAG;IACJ,MAAMC,GAAG,GAAG,IAAIR,KAAK,EAAE;IACvBQ,GAAG,CAACC,IAAI,CAAC,IAAI,CAAC;IACd,OAAOD,GAAG;EACd;EACA;EACAC,IAAI,CAACC,KAAK,EAAE;IACR,IAAI,CAACR,IAAI,CAACS,GAAG,CAACD,KAAK,CAACR,IAAI,CAAC;EAC7B;EACA;AACJ;AACA;AACA;AACA;AACA;EACIU,GAAG,GAAG;IACF,IAAIC,KAAK,GAAG,CAAC;IACb,KAAK,IAAIC,CAAC,GAAGd,KAAK,CAACI,IAAI,GAAG,CAAC,EAAEU,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACtC,MAAMC,CAAC,GAAI,IAAI,CAACb,IAAI,CAACY,CAAC,CAAC,KAAK,CAAC,GAAI,IAAI;MACrC,IAAI,CAACZ,IAAI,CAACY,CAAC,CAAC,GAAI,IAAI,CAACZ,IAAI,CAACY,CAAC,CAAC,IAAI,CAAC,GAAID,KAAK;MAC1CA,KAAK,GAAGE,CAAC;IACb;IACA,IAAI,CAACb,IAAI,CAACF,KAAK,CAACI,IAAI,GAAG,CAAC,CAAC,IAAIP,eAAe,CAACmB,MAAM,CAACH,KAAK,EAAEb,KAAK,CAACiB,CAAC,EAAE,CAAC,CAAC;IACtEJ,KAAK,GAAG,CAAC;EACb;AACJ;AACA;AACAb,KAAK,CAACI,IAAI,GAAG,EAAE;AACf;AACAJ,KAAK,CAACiB,CAAC,GAAG,IAAI;AACdtB,OAAO,CAACuB,OAAO,GAAGlB,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}