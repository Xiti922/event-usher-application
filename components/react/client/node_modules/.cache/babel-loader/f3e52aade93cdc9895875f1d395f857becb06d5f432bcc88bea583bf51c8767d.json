{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KeyRing = exports.KeyRingStatus = void 0;\nconst crypto_1 = require(\"./crypto\");\nconst crypto_2 = require(\"@keplr-wallet/crypto\");\nconst types_1 = require(\"@keplr-wallet/types\");\nconst router_1 = require(\"@keplr-wallet/router\");\nconst buffer_1 = require(\"buffer/\");\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nconst wallet_1 = require(\"@ethersproject/wallet\");\nconst BytesUtils = __importStar(require(\"@ethersproject/bytes\"));\nconst keccak256_1 = require(\"@ethersproject/keccak256\");\nvar KeyRingStatus;\n(function (KeyRingStatus) {\n  KeyRingStatus[KeyRingStatus[\"NOTLOADED\"] = 0] = \"NOTLOADED\";\n  KeyRingStatus[KeyRingStatus[\"EMPTY\"] = 1] = \"EMPTY\";\n  KeyRingStatus[KeyRingStatus[\"LOCKED\"] = 2] = \"LOCKED\";\n  KeyRingStatus[KeyRingStatus[\"UNLOCKED\"] = 3] = \"UNLOCKED\";\n})(KeyRingStatus = exports.KeyRingStatus || (exports.KeyRingStatus = {}));\nconst KeyStoreKey = \"key-store\";\nconst KeyMultiStoreKey = \"key-multi-store\";\n/*\n Keyring stores keys in persistent backround.\n And, this manages the state, crypto, address, signing and so on...\n */\nclass KeyRing {\n  constructor(embedChainInfos, kvStore, ledgerKeeper, crypto) {\n    this.embedChainInfos = embedChainInfos;\n    this.kvStore = kvStore;\n    this.ledgerKeeper = ledgerKeeper;\n    this.crypto = crypto;\n    this.cached = new Map();\n    this.password = \"\";\n    this.loaded = false;\n    this.keyStore = null;\n    this.multiKeyStore = [];\n  }\n  static getTypeOfKeyStore(keyStore) {\n    const type = keyStore.type;\n    if (type == null) {\n      return \"mnemonic\";\n    }\n    if (type !== \"mnemonic\" && type !== \"privateKey\" && type !== \"ledger\") {\n      throw new router_1.KeplrError(\"keyring\", 132, \"Invalid type of key store\");\n    }\n    return type;\n  }\n  get type() {\n    if (!this.keyStore) {\n      return \"none\";\n    } else {\n      return KeyRing.getTypeOfKeyStore(this.keyStore);\n    }\n  }\n  isLocked() {\n    return this.privateKey == null && this.mnemonicMasterSeed == null && this.ledgerPublicKey == null;\n  }\n  get privateKey() {\n    return this._privateKey;\n  }\n  set privateKey(privateKey) {\n    this._privateKey = privateKey;\n    this._mnemonicMasterSeed = undefined;\n    this._ledgerPublicKey = undefined;\n    this.cached = new Map();\n  }\n  get mnemonicMasterSeed() {\n    return this._mnemonicMasterSeed;\n  }\n  set mnemonicMasterSeed(masterSeed) {\n    this._mnemonicMasterSeed = masterSeed;\n    this._privateKey = undefined;\n    this._ledgerPublicKey = undefined;\n    this.cached = new Map();\n  }\n  get ledgerPublicKey() {\n    return this._ledgerPublicKey;\n  }\n  set ledgerPublicKey(publicKey) {\n    this._mnemonicMasterSeed = undefined;\n    this._privateKey = undefined;\n    this._ledgerPublicKey = publicKey;\n    this.cached = new Map();\n  }\n  get status() {\n    if (!this.loaded) {\n      return KeyRingStatus.NOTLOADED;\n    }\n    if (!this.keyStore) {\n      return KeyRingStatus.EMPTY;\n    } else if (!this.isLocked()) {\n      return KeyRingStatus.UNLOCKED;\n    } else {\n      return KeyRingStatus.LOCKED;\n    }\n  }\n  getKeyStoreCoinType(chainId) {\n    if (!this.keyStore) {\n      return undefined;\n    }\n    if (!this.keyStore.coinTypeForChain) {\n      return undefined;\n    }\n    return this.keyStore.coinTypeForChain[cosmos_1.ChainIdHelper.parse(chainId).identifier];\n  }\n  getKey(chainId, defaultCoinType, useEthereumAddress) {\n    return this.loadKey(this.computeKeyStoreCoinType(chainId, defaultCoinType), useEthereumAddress);\n  }\n  getKeyStoreMeta(key) {\n    var _a;\n    if (!this.keyStore || this.keyStore.meta == null) {\n      return \"\";\n    }\n    return (_a = this.keyStore.meta[key]) !== null && _a !== void 0 ? _a : \"\";\n  }\n  computeKeyStoreCoinType(chainId, defaultCoinType) {\n    var _a;\n    if (!this.keyStore) {\n      throw new router_1.KeplrError(\"keyring\", 130, \"Key store is empty\");\n    }\n    return this.keyStore.coinTypeForChain ? (_a = this.keyStore.coinTypeForChain[cosmos_1.ChainIdHelper.parse(chainId).identifier]) !== null && _a !== void 0 ? _a : defaultCoinType : defaultCoinType;\n  }\n  getKeyFromCoinType(coinType, useEthereumAddress) {\n    return this.loadKey(coinType, useEthereumAddress);\n  }\n  createMnemonicKey(kdf, mnemonic, password, meta, bip44HDPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== KeyRingStatus.EMPTY) {\n        throw new router_1.KeplrError(\"keyring\", 142, \"Key ring is not loaded or not empty\");\n      }\n      this.mnemonicMasterSeed = crypto_2.Mnemonic.generateMasterSeedFromMnemonic(mnemonic);\n      this.keyStore = yield KeyRing.CreateMnemonicKeyStore(this.crypto, kdf, mnemonic, password, yield this.assignKeyStoreIdMeta(meta), bip44HDPath);\n      this.password = password;\n      this.multiKeyStore.push(this.keyStore);\n      yield this.save();\n      return {\n        status: this.status,\n        multiKeyStoreInfo: yield this.getMultiKeyStoreInfo()\n      };\n    });\n  }\n  createPrivateKey(kdf, privateKey, password, meta) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== KeyRingStatus.EMPTY) {\n        throw new router_1.KeplrError(\"keyring\", 142, \"Key ring is not loaded or not empty\");\n      }\n      this.privateKey = privateKey;\n      this.keyStore = yield KeyRing.CreatePrivateKeyStore(this.crypto, kdf, privateKey, password, yield this.assignKeyStoreIdMeta(meta));\n      this.password = password;\n      this.multiKeyStore.push(this.keyStore);\n      yield this.save();\n      return {\n        status: this.status,\n        multiKeyStoreInfo: yield this.getMultiKeyStoreInfo()\n      };\n    });\n  }\n  createLedgerKey(env, kdf, password, meta, bip44HDPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== KeyRingStatus.EMPTY) {\n        throw new router_1.KeplrError(\"keyring\", 142, \"Key ring is not loaded or not empty\");\n      }\n      // Get public key first\n      this.ledgerPublicKey = yield this.ledgerKeeper.getPublicKey(env, bip44HDPath);\n      const keyStore = yield KeyRing.CreateLedgerKeyStore(this.crypto, kdf, this.ledgerPublicKey, password, yield this.assignKeyStoreIdMeta(meta), bip44HDPath);\n      this.password = password;\n      this.keyStore = keyStore;\n      this.multiKeyStore.push(this.keyStore);\n      yield this.save();\n      return {\n        status: this.status,\n        multiKeyStoreInfo: yield this.getMultiKeyStoreInfo()\n      };\n    });\n  }\n  lock() {\n    if (this.status !== KeyRingStatus.UNLOCKED) {\n      throw new router_1.KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n    }\n    this.mnemonicMasterSeed = undefined;\n    this.privateKey = undefined;\n    this.ledgerPublicKey = undefined;\n    this.password = \"\";\n  }\n  unlock(password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.keyStore || this.type === \"none\") {\n        throw new router_1.KeplrError(\"keyring\", 144, \"Key ring not initialized\");\n      }\n      if (this.type === \"mnemonic\") {\n        // If password is invalid, error will be thrown.\n        this.mnemonicMasterSeed = crypto_2.Mnemonic.generateMasterSeedFromMnemonic(buffer_1.Buffer.from(yield crypto_1.Crypto.decrypt(this.crypto, this.keyStore, password)).toString());\n      } else if (this.type === \"privateKey\") {\n        // If password is invalid, error will be thrown.\n        this.privateKey = buffer_1.Buffer.from(buffer_1.Buffer.from(yield crypto_1.Crypto.decrypt(this.crypto, this.keyStore, password)).toString(), \"hex\");\n      } else if (this.type === \"ledger\") {\n        this.ledgerPublicKey = buffer_1.Buffer.from(buffer_1.Buffer.from(yield crypto_1.Crypto.decrypt(this.crypto, this.keyStore, password)).toString(), \"hex\");\n      } else {\n        throw new router_1.KeplrError(\"keyring\", 145, \"Unexpected type of keyring\");\n      }\n      this.password = password;\n    });\n  }\n  save() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.kvStore.set(KeyStoreKey, this.keyStore);\n      yield this.kvStore.set(KeyMultiStoreKey, this.multiKeyStore);\n    });\n  }\n  restore() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keyStore = yield this.kvStore.get(KeyStoreKey);\n      if (!keyStore) {\n        this.keyStore = null;\n      } else {\n        this.keyStore = keyStore;\n      }\n      const multiKeyStore = yield this.kvStore.get(KeyMultiStoreKey);\n      if (!multiKeyStore) {\n        // Restore the multi keystore if key store exist 13t multi Key store is empty.\n        // This case will occur if extension is updated from the prior version that doesn't support the multi key store.\n        // This line ensures the backward compatibility.\n        if (keyStore) {\n          keyStore.meta = yield this.assignKeyStoreIdMeta({});\n          this.multiKeyStore = [keyStore];\n        } else {\n          this.multiKeyStore = [];\n        }\n        yield this.save();\n      } else {\n        this.multiKeyStore = multiKeyStore;\n      }\n      let hasLegacyKeyStore = false;\n      // In prior of version 1.2, bip44 path didn't tie with the keystore, and bip44 exists on the chain info.\n      // But, after some chain matures, they decided the bip44 path's coin type.\n      // So, some chain can have the multiple bip44 coin type (one is the standard coin type and other is the legacy coin type).\n      // We should support the legacy coin type, so we determined that the coin type ties with the keystore.\n      // To decrease the barrier of existing users, set the alternative coin type by force if the keystore version is prior than 1.2.\n      if (this.keyStore) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        if (this.keyStore.version === \"1\" || this.keyStore.version === \"1.1\") {\n          hasLegacyKeyStore = true;\n          this.updateLegacyKeyStore(this.keyStore);\n        }\n      }\n      for (const keyStore of this.multiKeyStore) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        if (keyStore.version === \"1\" || keyStore.version === \"1.1\") {\n          hasLegacyKeyStore = true;\n          this.updateLegacyKeyStore(keyStore);\n        }\n      }\n      if (hasLegacyKeyStore) {\n        yield this.save();\n      }\n      this.loaded = true;\n    });\n  }\n  updateLegacyKeyStore(keyStore) {\n    keyStore.version = \"1.2\";\n    for (const chainInfo of this.embedChainInfos) {\n      const coinType = (() => {\n        if (chainInfo.alternativeBIP44s && chainInfo.alternativeBIP44s.length > 0) {\n          return chainInfo.alternativeBIP44s[0].coinType;\n        } else {\n          return chainInfo.bip44.coinType;\n        }\n      })();\n      keyStore.coinTypeForChain = Object.assign(Object.assign({}, keyStore.coinTypeForChain), {\n        [cosmos_1.ChainIdHelper.parse(chainInfo.chainId).identifier]: coinType\n      });\n    }\n  }\n  isKeyStoreCoinTypeSet(chainId) {\n    if (!this.keyStore) {\n      throw new router_1.KeplrError(\"keyring\", 130, \"Key store is empty\");\n    }\n    return this.keyStore.coinTypeForChain && this.keyStore.coinTypeForChain[cosmos_1.ChainIdHelper.parse(chainId).identifier] !== undefined;\n  }\n  setKeyStoreCoinType(chainId, coinType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.keyStore) {\n        throw new router_1.KeplrError(\"keyring\", 130, \"Key store is empty\");\n      }\n      if (this.keyStore.coinTypeForChain && this.keyStore.coinTypeForChain[cosmos_1.ChainIdHelper.parse(chainId).identifier] !== undefined) {\n        throw new router_1.KeplrError(\"keyring\", 110, \"Coin type already set\");\n      }\n      this.keyStore.coinTypeForChain = Object.assign(Object.assign({}, this.keyStore.coinTypeForChain), {\n        [cosmos_1.ChainIdHelper.parse(chainId).identifier]: coinType\n      });\n      const keyStoreInMulti = this.multiKeyStore.find(keyStore => {\n        return KeyRing.getKeyStoreId(keyStore) ===\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        KeyRing.getKeyStoreId(this.keyStore);\n      });\n      if (keyStoreInMulti) {\n        keyStoreInMulti.coinTypeForChain = Object.assign({}, this.keyStore.coinTypeForChain);\n      }\n      yield this.save();\n    });\n  }\n  removeAllKeyStoreCoinType(chainId) {\n    var _a, _b;\n    const identifier = cosmos_1.ChainIdHelper.parse(chainId).identifier;\n    if (this.keyStore) {\n      const coinTypeForChain = (_a = this.keyStore.coinTypeForChain) !== null && _a !== void 0 ? _a : {};\n      delete coinTypeForChain[identifier];\n      this.keyStore.coinTypeForChain = coinTypeForChain;\n    }\n    for (const keyStore of this.multiKeyStore) {\n      const coinTypeForChain = (_b = keyStore.coinTypeForChain) !== null && _b !== void 0 ? _b : {};\n      delete coinTypeForChain[identifier];\n      keyStore.coinTypeForChain = coinTypeForChain;\n    }\n    this.save();\n  }\n  deleteKeyRing(index, password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== KeyRingStatus.UNLOCKED) {\n        throw new router_1.KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n      }\n      if (this.password !== password) {\n        throw new router_1.KeplrError(\"keyring\", 121, \"Invalid password\");\n      }\n      const keyStore = this.multiKeyStore[index];\n      if (!keyStore) {\n        throw new router_1.KeplrError(\"keyring\", 130, \"Key store is empty\");\n      }\n      const multiKeyStore = this.multiKeyStore.slice(0, index).concat(this.multiKeyStore.slice(index + 1));\n      // Make sure that password is valid.\n      yield crypto_1.Crypto.decrypt(this.crypto, keyStore, password);\n      let keyStoreChanged = false;\n      if (this.keyStore) {\n        // If key store is currently selected key store\n        if (KeyRing.getKeyStoreId(keyStore) === KeyRing.getKeyStoreId(this.keyStore)) {\n          // If there is a key store left\n          if (multiKeyStore.length > 0) {\n            // Lock key store at first\n            yield this.lock();\n            // Select first key store\n            this.keyStore = multiKeyStore[0];\n            // And unlock it\n            yield this.unlock(password);\n          } else {\n            // Else clear keyring.\n            this.keyStore = null;\n            this.mnemonicMasterSeed = undefined;\n            this.privateKey = undefined;\n            this.ledgerPublicKey = undefined;\n          }\n          keyStoreChanged = true;\n        }\n      }\n      this.multiKeyStore = multiKeyStore;\n      yield this.save();\n      return {\n        multiKeyStoreInfo: this.getMultiKeyStoreInfo(),\n        keyStoreChanged\n      };\n    });\n  }\n  updateNameKeyRing(index, name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== KeyRingStatus.UNLOCKED) {\n        throw new router_1.KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n      }\n      const keyStore = this.multiKeyStore[index];\n      if (!keyStore) {\n        throw new router_1.KeplrError(\"keyring\", 130, \"Key store is empty\");\n      }\n      keyStore.meta = Object.assign(Object.assign({}, keyStore.meta), {\n        name: name\n      });\n      // If select key store and changed store are same, sync keystore\n      if (this.keyStore && KeyRing.getKeyStoreId(this.keyStore) === KeyRing.getKeyStoreId(keyStore)) {\n        this.keyStore = keyStore;\n      }\n      yield this.save();\n      return this.getMultiKeyStoreInfo();\n    });\n  }\n  loadKey(coinType) {\n    let useEthereumAddress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this.status !== KeyRingStatus.UNLOCKED) {\n      throw new router_1.KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n    }\n    if (!this.keyStore) {\n      throw new router_1.KeplrError(\"keyring\", 130, \"Key store is empty\");\n    }\n    if (this.keyStore.type === \"ledger\") {\n      if (!this.ledgerPublicKey) {\n        throw new router_1.KeplrError(\"keyring\", 150, \"Ledger public key not set\");\n      }\n      if (useEthereumAddress) {\n        throw new router_1.KeplrError(\"keyring\", 152, \"Ledger is not compatible with this coinType right now\");\n      }\n      const pubKey = new crypto_2.PubKeySecp256k1(this.ledgerPublicKey);\n      return {\n        algo: \"secp256k1\",\n        pubKey: pubKey.toBytes(),\n        address: pubKey.getAddress(),\n        isNanoLedger: true\n      };\n    } else {\n      const privKey = this.loadPrivKey(coinType);\n      const pubKey = privKey.getPubKey();\n      if (useEthereumAddress) {\n        // For Ethereum Key-Gen Only:\n        const wallet = new wallet_1.Wallet(privKey.toBytes());\n        return {\n          algo: \"ethsecp256k1\",\n          pubKey: pubKey.toBytes(),\n          address: buffer_1.Buffer.from(wallet.address.replace(\"0x\", \"\"), \"hex\"),\n          isNanoLedger: false\n        };\n      }\n      // Default\n      return {\n        algo: \"secp256k1\",\n        pubKey: pubKey.toBytes(),\n        address: pubKey.getAddress(),\n        isNanoLedger: false\n      };\n    }\n  }\n  loadPrivKey(coinType) {\n    if (this.status !== KeyRingStatus.UNLOCKED || this.type === \"none\" || !this.keyStore) {\n      throw new router_1.KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n    }\n    const bip44HDPath = KeyRing.getKeyStoreBIP44Path(this.keyStore);\n    if (this.type === \"mnemonic\") {\n      const path = `m/44'/${coinType}'/${bip44HDPath.account}'/${bip44HDPath.change}/${bip44HDPath.addressIndex}`;\n      const cachedKey = this.cached.get(path);\n      if (cachedKey) {\n        return new crypto_2.PrivKeySecp256k1(cachedKey);\n      }\n      if (!this.mnemonicMasterSeed) {\n        throw new router_1.KeplrError(\"keyring\", 133, \"Key store type is mnemonic and it is unlocked. But, mnemonic is not loaded unexpectedly\");\n      }\n      const privKey = crypto_2.Mnemonic.generatePrivateKeyFromMasterSeed(this.mnemonicMasterSeed, path);\n      this.cached.set(path, privKey);\n      return new crypto_2.PrivKeySecp256k1(privKey);\n    } else if (this.type === \"privateKey\") {\n      // If key store type is private key, path will be ignored.\n      if (!this.privateKey) {\n        throw new router_1.KeplrError(\"keyring\", 134, \"Key store type is private key and it is unlocked. But, private key is not loaded unexpectedly\");\n      }\n      return new crypto_2.PrivKeySecp256k1(this.privateKey);\n    } else {\n      throw new router_1.KeplrError(\"keyring\", 145, \"Unexpected type of keyring\");\n    }\n  }\n  sign(env, chainId, defaultCoinType, message, useEthereumSigning) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== KeyRingStatus.UNLOCKED) {\n        throw new router_1.KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n      }\n      if (!this.keyStore) {\n        throw new router_1.KeplrError(\"keyring\", 130, \"Key store is empty\");\n      }\n      // Sign with Evmos/Ethereum\n      if (useEthereumSigning) {\n        return this.signEthereum(chainId, defaultCoinType, message);\n      }\n      if (this.keyStore.type === \"ledger\") {\n        const pubKey = this.ledgerPublicKey;\n        if (!pubKey) {\n          throw new router_1.KeplrError(\"keyring\", 151, \"Ledger public key is not initialized\");\n        }\n        return yield this.ledgerKeeper.sign(env, KeyRing.getKeyStoreBIP44Path(this.keyStore), pubKey, message);\n      } else {\n        const coinType = this.computeKeyStoreCoinType(chainId, defaultCoinType);\n        const privKey = this.loadPrivKey(coinType);\n        const signature = privKey.sign(message);\n        // Signing indicates an explicit use of this coin type.\n        // Mainly, this logic exists to explicitly set the coin type when signing by an external request.\n        if (!this.isKeyStoreCoinTypeSet(chainId)) {\n          yield this.setKeyStoreCoinType(chainId, coinType);\n        }\n        return signature;\n      }\n    });\n  }\n  signEthereum(chainId, defaultCoinType, message) {\n    let type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : types_1.EthSignType.BYTE64;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== KeyRingStatus.UNLOCKED) {\n        throw new router_1.KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n      }\n      if (!this.keyStore) {\n        throw new router_1.KeplrError(\"keyring\", 130, \"Key store is empty\");\n      }\n      if (this.keyStore.type === \"ledger\") {\n        // TODO: Ethereum Ledger Integration\n        throw new router_1.KeplrError(\"keyring\", 112, \"Ethereum signing with Ledger is not yet supported\");\n      }\n      const coinType = this.computeKeyStoreCoinType(chainId, defaultCoinType);\n      // Allow signing with Ethereum for chains with coinType !== 60\n      const privKey = this.loadPrivKey(coinType);\n      const ethWallet = new wallet_1.Wallet(privKey.toBytes());\n      if (type === types_1.EthSignType.BYTE64) {\n        // ECDSA Sign Keccak256 and discard parity byte\n        const signature = yield ethWallet._signingKey().signDigest(keccak256_1.keccak256(message));\n        const splitSignature = BytesUtils.splitSignature(signature);\n        return BytesUtils.arrayify(BytesUtils.concat([splitSignature.r, splitSignature.s]));\n      } else if (type === types_1.EthSignType.MESSAGE) {\n        // Sign bytes with prefixed Ethereum magic\n        const signature = yield ethWallet.signMessage(message);\n        return BytesUtils.arrayify(signature);\n      } else {\n        // Sign Ethereum transaction\n        const signature = yield ethWallet.signTransaction(JSON.parse(buffer_1.Buffer.from(message).toString()));\n        return BytesUtils.arrayify(signature);\n      }\n    });\n  }\n  // Show private key or mnemonic key if password is valid.\n  showKeyRing(index, password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== KeyRingStatus.UNLOCKED) {\n        throw new router_1.KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n      }\n      if (this.password !== password) {\n        throw new router_1.KeplrError(\"keyring\", 121, \"Invalid password\");\n      }\n      const keyStore = this.multiKeyStore[index];\n      if (!keyStore) {\n        throw new router_1.KeplrError(\"keyring\", 130, \"Key store is empty\");\n      }\n      if (keyStore.type === \"mnemonic\") {\n        // If password is invalid, error will be thrown.\n        return buffer_1.Buffer.from(yield crypto_1.Crypto.decrypt(this.crypto, keyStore, password)).toString();\n      } else {\n        // If password is invalid, error will be thrown.\n        return buffer_1.Buffer.from(yield crypto_1.Crypto.decrypt(this.crypto, keyStore, password)).toString();\n      }\n    });\n  }\n  get canSetPath() {\n    return this.type === \"mnemonic\" || this.type === \"ledger\";\n  }\n  addMnemonicKey(kdf, mnemonic, meta, bip44HDPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== KeyRingStatus.UNLOCKED || this.password == \"\") {\n        throw new router_1.KeplrError(\"keyring\", 141, \"Key ring is locked or not initialized\");\n      }\n      const keyStore = yield KeyRing.CreateMnemonicKeyStore(this.crypto, kdf, mnemonic, this.password, yield this.assignKeyStoreIdMeta(meta), bip44HDPath);\n      this.multiKeyStore.push(keyStore);\n      yield this.save();\n      return {\n        multiKeyStoreInfo: this.getMultiKeyStoreInfo()\n      };\n    });\n  }\n  addPrivateKey(kdf, privateKey, meta) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== KeyRingStatus.UNLOCKED || this.password == \"\") {\n        throw new router_1.KeplrError(\"keyring\", 141, \"Key ring is locked or not initialized\");\n      }\n      const keyStore = yield KeyRing.CreatePrivateKeyStore(this.crypto, kdf, privateKey, this.password, yield this.assignKeyStoreIdMeta(meta));\n      this.multiKeyStore.push(keyStore);\n      yield this.save();\n      return {\n        multiKeyStoreInfo: this.getMultiKeyStoreInfo()\n      };\n    });\n  }\n  addLedgerKey(env, kdf, meta, bip44HDPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== KeyRingStatus.UNLOCKED || this.password == \"\") {\n        throw new router_1.KeplrError(\"keyring\", 141, \"Key ring is locked or not initialized\");\n      }\n      // Get public key first\n      const publicKey = yield this.ledgerKeeper.getPublicKey(env, bip44HDPath);\n      const keyStore = yield KeyRing.CreateLedgerKeyStore(this.crypto, kdf, publicKey, this.password, yield this.assignKeyStoreIdMeta(meta), bip44HDPath);\n      this.multiKeyStore.push(keyStore);\n      yield this.save();\n      return {\n        multiKeyStoreInfo: this.getMultiKeyStoreInfo()\n      };\n    });\n  }\n  changeKeyStoreFromMultiKeyStore(index) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== KeyRingStatus.UNLOCKED || this.password == \"\") {\n        throw new router_1.KeplrError(\"keyring\", 141, \"Key ring is locked or not initialized\");\n      }\n      const keyStore = this.multiKeyStore[index];\n      if (!keyStore) {\n        throw new router_1.KeplrError(\"keyring\", 120, \"Invalid keystore\");\n      }\n      this.keyStore = keyStore;\n      yield this.unlock(this.password);\n      yield this.save();\n      return {\n        multiKeyStoreInfo: this.getMultiKeyStoreInfo()\n      };\n    });\n  }\n  getMultiKeyStoreInfo() {\n    const result = [];\n    for (const keyStore of this.multiKeyStore) {\n      result.push({\n        version: keyStore.version,\n        type: keyStore.type,\n        meta: keyStore.meta,\n        coinTypeForChain: keyStore.coinTypeForChain,\n        bip44HDPath: keyStore.bip44HDPath,\n        selected: this.keyStore ? KeyRing.getKeyStoreId(keyStore) === KeyRing.getKeyStoreId(this.keyStore) : false\n      });\n    }\n    return result;\n  }\n  checkPassword(password) {\n    if (!this.password) {\n      throw new router_1.KeplrError(\"keyring\", 100, \"Keyring is locked\");\n    }\n    return this.password === password;\n  }\n  exportKeyRingDatas(password) {\n    var _a, _b, _c, _d, _e;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.password) {\n        throw new router_1.KeplrError(\"keyring\", 100, \"Keyring is locked\");\n      }\n      if (this.password !== password) {\n        throw new router_1.KeplrError(\"keyring\", 121, \"Invalid password\");\n      }\n      const result = [];\n      for (const keyStore of this.multiKeyStore) {\n        const type = (_a = keyStore.type) !== null && _a !== void 0 ? _a : \"mnemonic\";\n        switch (type) {\n          case \"mnemonic\":\n            {\n              const mnemonic = buffer_1.Buffer.from(yield crypto_1.Crypto.decrypt(this.crypto, keyStore, password)).toString();\n              result.push({\n                bip44HDPath: (_b = keyStore.bip44HDPath) !== null && _b !== void 0 ? _b : {\n                  account: 0,\n                  change: 0,\n                  addressIndex: 0\n                },\n                coinTypeForChain: keyStore.coinTypeForChain,\n                key: mnemonic,\n                meta: (_c = keyStore.meta) !== null && _c !== void 0 ? _c : {},\n                type: \"mnemonic\"\n              });\n              break;\n            }\n          case \"privateKey\":\n            {\n              const privateKey = buffer_1.Buffer.from(yield crypto_1.Crypto.decrypt(this.crypto, keyStore, password)).toString();\n              result.push({\n                bip44HDPath: (_d = keyStore.bip44HDPath) !== null && _d !== void 0 ? _d : {\n                  account: 0,\n                  change: 0,\n                  addressIndex: 0\n                },\n                coinTypeForChain: keyStore.coinTypeForChain,\n                key: privateKey,\n                meta: (_e = keyStore.meta) !== null && _e !== void 0 ? _e : {},\n                type: \"privateKey\"\n              });\n              break;\n            }\n        }\n      }\n      return result;\n    });\n  }\n  static CreateMnemonicKeyStore(crypto, kdf, mnemonic, password, meta, bip44HDPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield crypto_1.Crypto.encrypt(crypto, kdf, \"mnemonic\", mnemonic, password, meta, bip44HDPath);\n    });\n  }\n  static CreatePrivateKeyStore(crypto, kdf, privateKey, password, meta) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield crypto_1.Crypto.encrypt(crypto, kdf, \"privateKey\", buffer_1.Buffer.from(privateKey).toString(\"hex\"), password, meta);\n    });\n  }\n  static CreateLedgerKeyStore(crypto, kdf, publicKey, password, meta, bip44HDPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield crypto_1.Crypto.encrypt(crypto, kdf, \"ledger\", buffer_1.Buffer.from(publicKey).toString(\"hex\"), password, meta, bip44HDPath);\n    });\n  }\n  assignKeyStoreIdMeta(meta) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // `__id__` is used to distinguish the key store.\n      return Object.assign({}, meta, {\n        __id__: (yield this.getIncrementalNumber()).toString()\n      });\n    });\n  }\n  static getKeyStoreId(keyStore) {\n    var _a;\n    const id = (_a = keyStore.meta) === null || _a === void 0 ? void 0 : _a.__id__;\n    if (!id) {\n      throw new router_1.KeplrError(\"keyring\", 131, \"Key store's id is empty\");\n    }\n    return id;\n  }\n  static getKeyStoreBIP44Path(keyStore) {\n    if (!keyStore.bip44HDPath) {\n      return {\n        account: 0,\n        change: 0,\n        addressIndex: 0\n      };\n    }\n    KeyRing.validateBIP44Path(keyStore.bip44HDPath);\n    return keyStore.bip44HDPath;\n  }\n  static validateBIP44Path(bip44Path) {\n    if (!Number.isInteger(bip44Path.account) || bip44Path.account < 0) {\n      throw new router_1.KeplrError(\"keyring\", 100, \"Invalid account in hd path\");\n    }\n    if (!Number.isInteger(bip44Path.change) || !(bip44Path.change === 0 || bip44Path.change === 1)) {\n      throw new router_1.KeplrError(\"keyring\", 102, \"Invalid change in hd path\");\n    }\n    if (!Number.isInteger(bip44Path.addressIndex) || bip44Path.addressIndex < 0) {\n      throw new router_1.KeplrError(\"keyring\", 101, \"Invalid address index in hd path\");\n    }\n  }\n  getIncrementalNumber() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let num = yield this.kvStore.get(\"incrementalNumber\");\n      if (num === undefined) {\n        num = 0;\n      }\n      num++;\n      yield this.kvStore.set(\"incrementalNumber\", num);\n      return num;\n    });\n  }\n}\nexports.KeyRing = KeyRing;","map":{"version":3,"mappings":"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","names":["KeyRingStatus","exports","KeyStoreKey","KeyMultiStoreKey","KeyRing","constructor","embedChainInfos","kvStore","ledgerKeeper","crypto","Map","loaded","keyStore","multiKeyStore","getTypeOfKeyStore","type","router_1","isLocked","privateKey","mnemonicMasterSeed","ledgerPublicKey","_privateKey","_mnemonicMasterSeed","undefined","_ledgerPublicKey","cached","masterSeed","publicKey","status","NOTLOADED","EMPTY","UNLOCKED","LOCKED","getKeyStoreCoinType","chainId","coinTypeForChain","cosmos_1","parse","identifier","getKey","defaultCoinType","useEthereumAddress","loadKey","computeKeyStoreCoinType","getKeyStoreMeta","key","meta","getKeyFromCoinType","coinType","createMnemonicKey","kdf","mnemonic","password","bip44HDPath","crypto_2","generateMasterSeedFromMnemonic","CreateMnemonicKeyStore","assignKeyStoreIdMeta","push","save","multiKeyStoreInfo","getMultiKeyStoreInfo","createPrivateKey","CreatePrivateKeyStore","createLedgerKey","env","getPublicKey","CreateLedgerKeyStore","lock","unlock","buffer_1","from","crypto_1","decrypt","toString","set","restore","get","hasLegacyKeyStore","version","updateLegacyKeyStore","chainInfo","alternativeBIP44s","length","bip44","isKeyStoreCoinTypeSet","setKeyStoreCoinType","keyStoreInMulti","find","getKeyStoreId","removeAllKeyStoreCoinType","deleteKeyRing","index","slice","concat","keyStoreChanged","updateNameKeyRing","name","pubKey","algo","toBytes","address","getAddress","isNanoLedger","privKey","loadPrivKey","getPubKey","wallet","wallet_1","replace","getKeyStoreBIP44Path","path","account","change","addressIndex","cachedKey","generatePrivateKeyFromMasterSeed","sign","message","useEthereumSigning","signEthereum","signature","types_1","BYTE64","ethWallet","_signingKey","signDigest","keccak256_1","splitSignature","BytesUtils","arrayify","r","s","MESSAGE","signMessage","signTransaction","JSON","showKeyRing","canSetPath","addMnemonicKey","addPrivateKey","addLedgerKey","changeKeyStoreFromMultiKeyStore","result","selected","checkPassword","exportKeyRingDatas","encrypt","Object","assign","__id__","getIncrementalNumber","id","validateBIP44Path","bip44Path","Number","isInteger","num"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/background/src/keyring/keyring.ts"],"sourcesContent":["import { Crypto, KeyStore } from \"./crypto\";\nimport {\n  Mnemonic,\n  PrivKeySecp256k1,\n  PubKeySecp256k1,\n} from \"@keplr-wallet/crypto\";\nimport { KVStore } from \"@keplr-wallet/common\";\nimport { LedgerService } from \"../ledger\";\nimport { BIP44HDPath, CommonCrypto, ExportKeyRingData } from \"./types\";\nimport { ChainInfo, EthSignType } from \"@keplr-wallet/types\";\nimport { Env, KeplrError } from \"@keplr-wallet/router\";\n\nimport { Buffer } from \"buffer/\";\nimport { ChainIdHelper } from \"@keplr-wallet/cosmos\";\n\nimport { Wallet } from \"@ethersproject/wallet\";\nimport * as BytesUtils from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\n\nexport enum KeyRingStatus {\n  NOTLOADED,\n  EMPTY,\n  LOCKED,\n  UNLOCKED,\n}\n\nexport interface Key {\n  algo: string;\n  pubKey: Uint8Array;\n  address: Uint8Array;\n  isNanoLedger: boolean;\n}\n\nexport type MultiKeyStoreInfoElem = Pick<\n  KeyStore,\n  \"version\" | \"type\" | \"meta\" | \"bip44HDPath\" | \"coinTypeForChain\"\n>;\nexport type MultiKeyStoreInfo = MultiKeyStoreInfoElem[];\nexport type MultiKeyStoreInfoWithSelectedElem = MultiKeyStoreInfoElem & {\n  selected: boolean;\n};\nexport type MultiKeyStoreInfoWithSelected = MultiKeyStoreInfoWithSelectedElem[];\n\nconst KeyStoreKey = \"key-store\";\nconst KeyMultiStoreKey = \"key-multi-store\";\n\n/*\n Keyring stores keys in persistent backround.\n And, this manages the state, crypto, address, signing and so on...\n */\nexport class KeyRing {\n  private cached: Map<string, Uint8Array> = new Map();\n\n  private loaded: boolean;\n\n  /**\n   * Keyring can have either private key or mnemonic.\n   * If keyring has private key, it can't set the BIP 44 path.\n   */\n  private _privateKey?: Uint8Array;\n  private _mnemonicMasterSeed?: Uint8Array;\n  private _ledgerPublicKey?: Uint8Array;\n\n  private keyStore: KeyStore | null;\n\n  private multiKeyStore: KeyStore[];\n\n  private password: string = \"\";\n\n  constructor(\n    private readonly embedChainInfos: ChainInfo[],\n    private readonly kvStore: KVStore,\n    private readonly ledgerKeeper: LedgerService,\n    private readonly crypto: CommonCrypto\n  ) {\n    this.loaded = false;\n    this.keyStore = null;\n    this.multiKeyStore = [];\n  }\n\n  public static getTypeOfKeyStore(\n    keyStore: Omit<KeyStore, \"crypto\">\n  ): \"mnemonic\" | \"privateKey\" | \"ledger\" {\n    const type = keyStore.type;\n    if (type == null) {\n      return \"mnemonic\";\n    }\n\n    if (type !== \"mnemonic\" && type !== \"privateKey\" && type !== \"ledger\") {\n      throw new KeplrError(\"keyring\", 132, \"Invalid type of key store\");\n    }\n\n    return type;\n  }\n\n  public get type(): \"mnemonic\" | \"privateKey\" | \"ledger\" | \"none\" {\n    if (!this.keyStore) {\n      return \"none\";\n    } else {\n      return KeyRing.getTypeOfKeyStore(this.keyStore);\n    }\n  }\n\n  public isLocked(): boolean {\n    return (\n      this.privateKey == null &&\n      this.mnemonicMasterSeed == null &&\n      this.ledgerPublicKey == null\n    );\n  }\n\n  private get privateKey(): Uint8Array | undefined {\n    return this._privateKey;\n  }\n\n  private set privateKey(privateKey: Uint8Array | undefined) {\n    this._privateKey = privateKey;\n    this._mnemonicMasterSeed = undefined;\n    this._ledgerPublicKey = undefined;\n    this.cached = new Map();\n  }\n\n  private get mnemonicMasterSeed(): Uint8Array | undefined {\n    return this._mnemonicMasterSeed;\n  }\n\n  private set mnemonicMasterSeed(masterSeed: Uint8Array | undefined) {\n    this._mnemonicMasterSeed = masterSeed;\n    this._privateKey = undefined;\n    this._ledgerPublicKey = undefined;\n    this.cached = new Map();\n  }\n\n  private get ledgerPublicKey(): Uint8Array | undefined {\n    return this._ledgerPublicKey;\n  }\n\n  private set ledgerPublicKey(publicKey: Uint8Array | undefined) {\n    this._mnemonicMasterSeed = undefined;\n    this._privateKey = undefined;\n    this._ledgerPublicKey = publicKey;\n    this.cached = new Map();\n  }\n\n  public get status(): KeyRingStatus {\n    if (!this.loaded) {\n      return KeyRingStatus.NOTLOADED;\n    }\n\n    if (!this.keyStore) {\n      return KeyRingStatus.EMPTY;\n    } else if (!this.isLocked()) {\n      return KeyRingStatus.UNLOCKED;\n    } else {\n      return KeyRingStatus.LOCKED;\n    }\n  }\n\n  public getKeyStoreCoinType(chainId: string): number | undefined {\n    if (!this.keyStore) {\n      return undefined;\n    }\n\n    if (!this.keyStore.coinTypeForChain) {\n      return undefined;\n    }\n\n    return this.keyStore.coinTypeForChain[\n      ChainIdHelper.parse(chainId).identifier\n    ];\n  }\n\n  public getKey(\n    chainId: string,\n    defaultCoinType: number,\n    useEthereumAddress: boolean\n  ): Key {\n    return this.loadKey(\n      this.computeKeyStoreCoinType(chainId, defaultCoinType),\n      useEthereumAddress\n    );\n  }\n\n  public getKeyStoreMeta(key: string): string {\n    if (!this.keyStore || this.keyStore.meta == null) {\n      return \"\";\n    }\n\n    return this.keyStore.meta[key] ?? \"\";\n  }\n\n  public computeKeyStoreCoinType(\n    chainId: string,\n    defaultCoinType: number\n  ): number {\n    if (!this.keyStore) {\n      throw new KeplrError(\"keyring\", 130, \"Key store is empty\");\n    }\n\n    return this.keyStore.coinTypeForChain\n      ? this.keyStore.coinTypeForChain[\n          ChainIdHelper.parse(chainId).identifier\n        ] ?? defaultCoinType\n      : defaultCoinType;\n  }\n\n  public getKeyFromCoinType(\n    coinType: number,\n    useEthereumAddress: boolean\n  ): Key {\n    return this.loadKey(coinType, useEthereumAddress);\n  }\n\n  public async createMnemonicKey(\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    mnemonic: string,\n    password: string,\n    meta: Record<string, string>,\n    bip44HDPath: BIP44HDPath\n  ): Promise<{\n    status: KeyRingStatus;\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    if (this.status !== KeyRingStatus.EMPTY) {\n      throw new KeplrError(\n        \"keyring\",\n        142,\n        \"Key ring is not loaded or not empty\"\n      );\n    }\n\n    this.mnemonicMasterSeed = Mnemonic.generateMasterSeedFromMnemonic(mnemonic);\n    this.keyStore = await KeyRing.CreateMnemonicKeyStore(\n      this.crypto,\n      kdf,\n      mnemonic,\n      password,\n      await this.assignKeyStoreIdMeta(meta),\n      bip44HDPath\n    );\n    this.password = password;\n    this.multiKeyStore.push(this.keyStore);\n\n    await this.save();\n\n    return {\n      status: this.status,\n      multiKeyStoreInfo: await this.getMultiKeyStoreInfo(),\n    };\n  }\n\n  public async createPrivateKey(\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    privateKey: Uint8Array,\n    password: string,\n    meta: Record<string, string>\n  ): Promise<{\n    status: KeyRingStatus;\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    if (this.status !== KeyRingStatus.EMPTY) {\n      throw new KeplrError(\n        \"keyring\",\n        142,\n        \"Key ring is not loaded or not empty\"\n      );\n    }\n\n    this.privateKey = privateKey;\n    this.keyStore = await KeyRing.CreatePrivateKeyStore(\n      this.crypto,\n      kdf,\n      privateKey,\n      password,\n      await this.assignKeyStoreIdMeta(meta)\n    );\n    this.password = password;\n    this.multiKeyStore.push(this.keyStore);\n\n    await this.save();\n\n    return {\n      status: this.status,\n      multiKeyStoreInfo: await this.getMultiKeyStoreInfo(),\n    };\n  }\n\n  public async createLedgerKey(\n    env: Env,\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    password: string,\n    meta: Record<string, string>,\n    bip44HDPath: BIP44HDPath\n  ): Promise<{\n    status: KeyRingStatus;\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    if (this.status !== KeyRingStatus.EMPTY) {\n      throw new KeplrError(\n        \"keyring\",\n        142,\n        \"Key ring is not loaded or not empty\"\n      );\n    }\n\n    // Get public key first\n    this.ledgerPublicKey = await this.ledgerKeeper.getPublicKey(\n      env,\n      bip44HDPath\n    );\n\n    const keyStore = await KeyRing.CreateLedgerKeyStore(\n      this.crypto,\n      kdf,\n      this.ledgerPublicKey,\n      password,\n      await this.assignKeyStoreIdMeta(meta),\n      bip44HDPath\n    );\n\n    this.password = password;\n    this.keyStore = keyStore;\n    this.multiKeyStore.push(this.keyStore);\n\n    await this.save();\n\n    return {\n      status: this.status,\n      multiKeyStoreInfo: await this.getMultiKeyStoreInfo(),\n    };\n  }\n\n  public lock() {\n    if (this.status !== KeyRingStatus.UNLOCKED) {\n      throw new KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n    }\n\n    this.mnemonicMasterSeed = undefined;\n    this.privateKey = undefined;\n    this.ledgerPublicKey = undefined;\n    this.password = \"\";\n  }\n\n  public async unlock(password: string) {\n    if (!this.keyStore || this.type === \"none\") {\n      throw new KeplrError(\"keyring\", 144, \"Key ring not initialized\");\n    }\n\n    if (this.type === \"mnemonic\") {\n      // If password is invalid, error will be thrown.\n      this.mnemonicMasterSeed = Mnemonic.generateMasterSeedFromMnemonic(\n        Buffer.from(\n          await Crypto.decrypt(this.crypto, this.keyStore, password)\n        ).toString()\n      );\n    } else if (this.type === \"privateKey\") {\n      // If password is invalid, error will be thrown.\n      this.privateKey = Buffer.from(\n        Buffer.from(\n          await Crypto.decrypt(this.crypto, this.keyStore, password)\n        ).toString(),\n        \"hex\"\n      );\n    } else if (this.type === \"ledger\") {\n      this.ledgerPublicKey = Buffer.from(\n        Buffer.from(\n          await Crypto.decrypt(this.crypto, this.keyStore, password)\n        ).toString(),\n        \"hex\"\n      );\n    } else {\n      throw new KeplrError(\"keyring\", 145, \"Unexpected type of keyring\");\n    }\n\n    this.password = password;\n  }\n\n  public async save() {\n    await this.kvStore.set<KeyStore>(KeyStoreKey, this.keyStore);\n    await this.kvStore.set<KeyStore[]>(KeyMultiStoreKey, this.multiKeyStore);\n  }\n\n  public async restore() {\n    const keyStore = await this.kvStore.get<KeyStore>(KeyStoreKey);\n    if (!keyStore) {\n      this.keyStore = null;\n    } else {\n      this.keyStore = keyStore;\n    }\n    const multiKeyStore = await this.kvStore.get<KeyStore[]>(KeyMultiStoreKey);\n    if (!multiKeyStore) {\n      // Restore the multi keystore if key store exist 13t multi Key store is empty.\n      // This case will occur if extension is updated from the prior version that doesn't support the multi key store.\n      // This line ensures the backward compatibility.\n      if (keyStore) {\n        keyStore.meta = await this.assignKeyStoreIdMeta({});\n        this.multiKeyStore = [keyStore];\n      } else {\n        this.multiKeyStore = [];\n      }\n      await this.save();\n    } else {\n      this.multiKeyStore = multiKeyStore;\n    }\n\n    let hasLegacyKeyStore = false;\n    // In prior of version 1.2, bip44 path didn't tie with the keystore, and bip44 exists on the chain info.\n    // But, after some chain matures, they decided the bip44 path's coin type.\n    // So, some chain can have the multiple bip44 coin type (one is the standard coin type and other is the legacy coin type).\n    // We should support the legacy coin type, so we determined that the coin type ties with the keystore.\n    // To decrease the barrier of existing users, set the alternative coin type by force if the keystore version is prior than 1.2.\n    if (this.keyStore) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      if (this.keyStore.version === \"1\" || this.keyStore.version === \"1.1\") {\n        hasLegacyKeyStore = true;\n        this.updateLegacyKeyStore(this.keyStore);\n      }\n    }\n    for (const keyStore of this.multiKeyStore) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      if (keyStore.version === \"1\" || keyStore.version === \"1.1\") {\n        hasLegacyKeyStore = true;\n        this.updateLegacyKeyStore(keyStore);\n      }\n    }\n    if (hasLegacyKeyStore) {\n      await this.save();\n    }\n\n    this.loaded = true;\n  }\n\n  private updateLegacyKeyStore(keyStore: KeyStore) {\n    keyStore.version = \"1.2\";\n    for (const chainInfo of this.embedChainInfos) {\n      const coinType = (() => {\n        if (\n          chainInfo.alternativeBIP44s &&\n          chainInfo.alternativeBIP44s.length > 0\n        ) {\n          return chainInfo.alternativeBIP44s[0].coinType;\n        } else {\n          return chainInfo.bip44.coinType;\n        }\n      })();\n      keyStore.coinTypeForChain = {\n        ...keyStore.coinTypeForChain,\n        [ChainIdHelper.parse(chainInfo.chainId).identifier]: coinType,\n      };\n    }\n  }\n\n  public isKeyStoreCoinTypeSet(chainId: string): boolean {\n    if (!this.keyStore) {\n      throw new KeplrError(\"keyring\", 130, \"Key store is empty\");\n    }\n\n    return (\n      this.keyStore.coinTypeForChain &&\n      this.keyStore.coinTypeForChain[\n        ChainIdHelper.parse(chainId).identifier\n      ] !== undefined\n    );\n  }\n\n  public async setKeyStoreCoinType(chainId: string, coinType: number) {\n    if (!this.keyStore) {\n      throw new KeplrError(\"keyring\", 130, \"Key store is empty\");\n    }\n\n    if (\n      this.keyStore.coinTypeForChain &&\n      this.keyStore.coinTypeForChain[\n        ChainIdHelper.parse(chainId).identifier\n      ] !== undefined\n    ) {\n      throw new KeplrError(\"keyring\", 110, \"Coin type already set\");\n    }\n\n    this.keyStore.coinTypeForChain = {\n      ...this.keyStore.coinTypeForChain,\n      [ChainIdHelper.parse(chainId).identifier]: coinType,\n    };\n\n    const keyStoreInMulti = this.multiKeyStore.find((keyStore) => {\n      return (\n        KeyRing.getKeyStoreId(keyStore) ===\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        KeyRing.getKeyStoreId(this.keyStore!)\n      );\n    });\n\n    if (keyStoreInMulti) {\n      keyStoreInMulti.coinTypeForChain = {\n        ...this.keyStore.coinTypeForChain,\n      };\n    }\n\n    await this.save();\n  }\n\n  public removeAllKeyStoreCoinType(chainId: string) {\n    const identifier = ChainIdHelper.parse(chainId).identifier;\n\n    if (this.keyStore) {\n      const coinTypeForChain = this.keyStore.coinTypeForChain ?? {};\n      delete coinTypeForChain[identifier];\n      this.keyStore.coinTypeForChain = coinTypeForChain;\n    }\n\n    for (const keyStore of this.multiKeyStore) {\n      const coinTypeForChain = keyStore.coinTypeForChain ?? {};\n      delete coinTypeForChain[identifier];\n      keyStore.coinTypeForChain = coinTypeForChain;\n    }\n\n    this.save();\n  }\n\n  public async deleteKeyRing(\n    index: number,\n    password: string\n  ): Promise<{\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n    keyStoreChanged: boolean;\n  }> {\n    if (this.status !== KeyRingStatus.UNLOCKED) {\n      throw new KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n    }\n\n    if (this.password !== password) {\n      throw new KeplrError(\"keyring\", 121, \"Invalid password\");\n    }\n\n    const keyStore = this.multiKeyStore[index];\n\n    if (!keyStore) {\n      throw new KeplrError(\"keyring\", 130, \"Key store is empty\");\n    }\n\n    const multiKeyStore = this.multiKeyStore\n      .slice(0, index)\n      .concat(this.multiKeyStore.slice(index + 1));\n\n    // Make sure that password is valid.\n    await Crypto.decrypt(this.crypto, keyStore, password);\n\n    let keyStoreChanged = false;\n    if (this.keyStore) {\n      // If key store is currently selected key store\n      if (\n        KeyRing.getKeyStoreId(keyStore) === KeyRing.getKeyStoreId(this.keyStore)\n      ) {\n        // If there is a key store left\n        if (multiKeyStore.length > 0) {\n          // Lock key store at first\n          await this.lock();\n          // Select first key store\n          this.keyStore = multiKeyStore[0];\n          // And unlock it\n          await this.unlock(password);\n        } else {\n          // Else clear keyring.\n          this.keyStore = null;\n          this.mnemonicMasterSeed = undefined;\n          this.privateKey = undefined;\n          this.ledgerPublicKey = undefined;\n        }\n\n        keyStoreChanged = true;\n      }\n    }\n\n    this.multiKeyStore = multiKeyStore;\n    await this.save();\n    return {\n      multiKeyStoreInfo: this.getMultiKeyStoreInfo(),\n      keyStoreChanged,\n    };\n  }\n\n  public async updateNameKeyRing(\n    index: number,\n    name: string\n  ): Promise<MultiKeyStoreInfoWithSelected> {\n    if (this.status !== KeyRingStatus.UNLOCKED) {\n      throw new KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n    }\n\n    const keyStore = this.multiKeyStore[index];\n\n    if (!keyStore) {\n      throw new KeplrError(\"keyring\", 130, \"Key store is empty\");\n    }\n\n    keyStore.meta = { ...keyStore.meta, name: name };\n\n    // If select key store and changed store are same, sync keystore\n    if (\n      this.keyStore &&\n      KeyRing.getKeyStoreId(this.keyStore) === KeyRing.getKeyStoreId(keyStore)\n    ) {\n      this.keyStore = keyStore;\n    }\n    await this.save();\n    return this.getMultiKeyStoreInfo();\n  }\n\n  private loadKey(coinType: number, useEthereumAddress: boolean = false): Key {\n    if (this.status !== KeyRingStatus.UNLOCKED) {\n      throw new KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n    }\n\n    if (!this.keyStore) {\n      throw new KeplrError(\"keyring\", 130, \"Key store is empty\");\n    }\n\n    if (this.keyStore.type === \"ledger\") {\n      if (!this.ledgerPublicKey) {\n        throw new KeplrError(\"keyring\", 150, \"Ledger public key not set\");\n      }\n\n      if (useEthereumAddress) {\n        throw new KeplrError(\n          \"keyring\",\n          152,\n          \"Ledger is not compatible with this coinType right now\"\n        );\n      }\n\n      const pubKey = new PubKeySecp256k1(this.ledgerPublicKey);\n\n      return {\n        algo: \"secp256k1\",\n        pubKey: pubKey.toBytes(),\n        address: pubKey.getAddress(),\n        isNanoLedger: true,\n      };\n    } else {\n      const privKey = this.loadPrivKey(coinType);\n      const pubKey = privKey.getPubKey();\n\n      if (useEthereumAddress) {\n        // For Ethereum Key-Gen Only:\n        const wallet = new Wallet(privKey.toBytes());\n\n        return {\n          algo: \"ethsecp256k1\",\n          pubKey: pubKey.toBytes(),\n          address: Buffer.from(wallet.address.replace(\"0x\", \"\"), \"hex\"),\n          isNanoLedger: false,\n        };\n      }\n\n      // Default\n      return {\n        algo: \"secp256k1\",\n        pubKey: pubKey.toBytes(),\n        address: pubKey.getAddress(),\n        isNanoLedger: false,\n      };\n    }\n  }\n\n  private loadPrivKey(coinType: number): PrivKeySecp256k1 {\n    if (\n      this.status !== KeyRingStatus.UNLOCKED ||\n      this.type === \"none\" ||\n      !this.keyStore\n    ) {\n      throw new KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n    }\n\n    const bip44HDPath = KeyRing.getKeyStoreBIP44Path(this.keyStore);\n\n    if (this.type === \"mnemonic\") {\n      const path = `m/44'/${coinType}'/${bip44HDPath.account}'/${bip44HDPath.change}/${bip44HDPath.addressIndex}`;\n      const cachedKey = this.cached.get(path);\n      if (cachedKey) {\n        return new PrivKeySecp256k1(cachedKey);\n      }\n\n      if (!this.mnemonicMasterSeed) {\n        throw new KeplrError(\n          \"keyring\",\n          133,\n          \"Key store type is mnemonic and it is unlocked. But, mnemonic is not loaded unexpectedly\"\n        );\n      }\n\n      const privKey = Mnemonic.generatePrivateKeyFromMasterSeed(\n        this.mnemonicMasterSeed,\n        path\n      );\n\n      this.cached.set(path, privKey);\n      return new PrivKeySecp256k1(privKey);\n    } else if (this.type === \"privateKey\") {\n      // If key store type is private key, path will be ignored.\n\n      if (!this.privateKey) {\n        throw new KeplrError(\n          \"keyring\",\n          134,\n          \"Key store type is private key and it is unlocked. But, private key is not loaded unexpectedly\"\n        );\n      }\n\n      return new PrivKeySecp256k1(this.privateKey);\n    } else {\n      throw new KeplrError(\"keyring\", 145, \"Unexpected type of keyring\");\n    }\n  }\n\n  public async sign(\n    env: Env,\n    chainId: string,\n    defaultCoinType: number,\n    message: Uint8Array,\n    useEthereumSigning: boolean\n  ): Promise<Uint8Array> {\n    if (this.status !== KeyRingStatus.UNLOCKED) {\n      throw new KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n    }\n\n    if (!this.keyStore) {\n      throw new KeplrError(\"keyring\", 130, \"Key store is empty\");\n    }\n\n    // Sign with Evmos/Ethereum\n    if (useEthereumSigning) {\n      return this.signEthereum(chainId, defaultCoinType, message);\n    }\n\n    if (this.keyStore.type === \"ledger\") {\n      const pubKey = this.ledgerPublicKey;\n\n      if (!pubKey) {\n        throw new KeplrError(\n          \"keyring\",\n          151,\n          \"Ledger public key is not initialized\"\n        );\n      }\n\n      return await this.ledgerKeeper.sign(\n        env,\n        KeyRing.getKeyStoreBIP44Path(this.keyStore),\n        pubKey,\n        message\n      );\n    } else {\n      const coinType = this.computeKeyStoreCoinType(chainId, defaultCoinType);\n\n      const privKey = this.loadPrivKey(coinType);\n      const signature = privKey.sign(message);\n\n      // Signing indicates an explicit use of this coin type.\n      // Mainly, this logic exists to explicitly set the coin type when signing by an external request.\n      if (!this.isKeyStoreCoinTypeSet(chainId)) {\n        await this.setKeyStoreCoinType(chainId, coinType);\n      }\n\n      return signature;\n    }\n  }\n\n  public async signEthereum(\n    chainId: string,\n    defaultCoinType: number,\n    message: Uint8Array,\n    type: EthSignType = EthSignType.BYTE64 // Default to Ethereum signing for Evmos\n  ): Promise<Uint8Array> {\n    if (this.status !== KeyRingStatus.UNLOCKED) {\n      throw new KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n    }\n\n    if (!this.keyStore) {\n      throw new KeplrError(\"keyring\", 130, \"Key store is empty\");\n    }\n\n    if (this.keyStore.type === \"ledger\") {\n      // TODO: Ethereum Ledger Integration\n      throw new KeplrError(\n        \"keyring\",\n        112,\n        \"Ethereum signing with Ledger is not yet supported\"\n      );\n    }\n\n    const coinType = this.computeKeyStoreCoinType(chainId, defaultCoinType);\n    // Allow signing with Ethereum for chains with coinType !== 60\n    const privKey = this.loadPrivKey(coinType);\n\n    const ethWallet = new Wallet(privKey.toBytes());\n\n    if (type === EthSignType.BYTE64) {\n      // ECDSA Sign Keccak256 and discard parity byte\n      const signature = await ethWallet\n        ._signingKey()\n        .signDigest(keccak256(message));\n      const splitSignature = BytesUtils.splitSignature(signature);\n      return BytesUtils.arrayify(\n        BytesUtils.concat([splitSignature.r, splitSignature.s])\n      );\n    } else if (type === EthSignType.MESSAGE) {\n      // Sign bytes with prefixed Ethereum magic\n      const signature = await ethWallet.signMessage(message);\n      return BytesUtils.arrayify(signature);\n    } else {\n      // Sign Ethereum transaction\n      const signature = await ethWallet.signTransaction(\n        JSON.parse(Buffer.from(message).toString())\n      );\n      return BytesUtils.arrayify(signature);\n    }\n  }\n\n  // Show private key or mnemonic key if password is valid.\n  public async showKeyRing(index: number, password: string): Promise<string> {\n    if (this.status !== KeyRingStatus.UNLOCKED) {\n      throw new KeplrError(\"keyring\", 143, \"Key ring is not unlocked\");\n    }\n\n    if (this.password !== password) {\n      throw new KeplrError(\"keyring\", 121, \"Invalid password\");\n    }\n\n    const keyStore = this.multiKeyStore[index];\n\n    if (!keyStore) {\n      throw new KeplrError(\"keyring\", 130, \"Key store is empty\");\n    }\n\n    if (keyStore.type === \"mnemonic\") {\n      // If password is invalid, error will be thrown.\n      return Buffer.from(\n        await Crypto.decrypt(this.crypto, keyStore, password)\n      ).toString();\n    } else {\n      // If password is invalid, error will be thrown.\n      return Buffer.from(\n        await Crypto.decrypt(this.crypto, keyStore, password)\n      ).toString();\n    }\n  }\n\n  public get canSetPath(): boolean {\n    return this.type === \"mnemonic\" || this.type === \"ledger\";\n  }\n\n  public async addMnemonicKey(\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    mnemonic: string,\n    meta: Record<string, string>,\n    bip44HDPath: BIP44HDPath\n  ): Promise<{\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    if (this.status !== KeyRingStatus.UNLOCKED || this.password == \"\") {\n      throw new KeplrError(\n        \"keyring\",\n        141,\n        \"Key ring is locked or not initialized\"\n      );\n    }\n\n    const keyStore = await KeyRing.CreateMnemonicKeyStore(\n      this.crypto,\n      kdf,\n      mnemonic,\n      this.password,\n      await this.assignKeyStoreIdMeta(meta),\n      bip44HDPath\n    );\n    this.multiKeyStore.push(keyStore);\n\n    await this.save();\n    return {\n      multiKeyStoreInfo: this.getMultiKeyStoreInfo(),\n    };\n  }\n\n  public async addPrivateKey(\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    privateKey: Uint8Array,\n    meta: Record<string, string>\n  ): Promise<{\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    if (this.status !== KeyRingStatus.UNLOCKED || this.password == \"\") {\n      throw new KeplrError(\n        \"keyring\",\n        141,\n        \"Key ring is locked or not initialized\"\n      );\n    }\n\n    const keyStore = await KeyRing.CreatePrivateKeyStore(\n      this.crypto,\n      kdf,\n      privateKey,\n      this.password,\n      await this.assignKeyStoreIdMeta(meta)\n    );\n    this.multiKeyStore.push(keyStore);\n\n    await this.save();\n    return {\n      multiKeyStoreInfo: this.getMultiKeyStoreInfo(),\n    };\n  }\n\n  public async addLedgerKey(\n    env: Env,\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    meta: Record<string, string>,\n    bip44HDPath: BIP44HDPath\n  ): Promise<{\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    if (this.status !== KeyRingStatus.UNLOCKED || this.password == \"\") {\n      throw new KeplrError(\n        \"keyring\",\n        141,\n        \"Key ring is locked or not initialized\"\n      );\n    }\n\n    // Get public key first\n    const publicKey = await this.ledgerKeeper.getPublicKey(env, bip44HDPath);\n\n    const keyStore = await KeyRing.CreateLedgerKeyStore(\n      this.crypto,\n      kdf,\n      publicKey,\n      this.password,\n      await this.assignKeyStoreIdMeta(meta),\n      bip44HDPath\n    );\n\n    this.multiKeyStore.push(keyStore);\n\n    await this.save();\n    return {\n      multiKeyStoreInfo: this.getMultiKeyStoreInfo(),\n    };\n  }\n\n  public async changeKeyStoreFromMultiKeyStore(\n    index: number\n  ): Promise<{\n    multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;\n  }> {\n    if (this.status !== KeyRingStatus.UNLOCKED || this.password == \"\") {\n      throw new KeplrError(\n        \"keyring\",\n        141,\n        \"Key ring is locked or not initialized\"\n      );\n    }\n\n    const keyStore = this.multiKeyStore[index];\n    if (!keyStore) {\n      throw new KeplrError(\"keyring\", 120, \"Invalid keystore\");\n    }\n\n    this.keyStore = keyStore;\n\n    await this.unlock(this.password);\n\n    await this.save();\n    return {\n      multiKeyStoreInfo: this.getMultiKeyStoreInfo(),\n    };\n  }\n\n  public getMultiKeyStoreInfo(): MultiKeyStoreInfoWithSelected {\n    const result: MultiKeyStoreInfoWithSelected = [];\n\n    for (const keyStore of this.multiKeyStore) {\n      result.push({\n        version: keyStore.version,\n        type: keyStore.type,\n        meta: keyStore.meta,\n        coinTypeForChain: keyStore.coinTypeForChain,\n        bip44HDPath: keyStore.bip44HDPath,\n        selected: this.keyStore\n          ? KeyRing.getKeyStoreId(keyStore) ===\n            KeyRing.getKeyStoreId(this.keyStore)\n          : false,\n      });\n    }\n\n    return result;\n  }\n\n  checkPassword(password: string): boolean {\n    if (!this.password) {\n      throw new KeplrError(\"keyring\", 100, \"Keyring is locked\");\n    }\n\n    return this.password === password;\n  }\n\n  async exportKeyRingDatas(password: string): Promise<ExportKeyRingData[]> {\n    if (!this.password) {\n      throw new KeplrError(\"keyring\", 100, \"Keyring is locked\");\n    }\n\n    if (this.password !== password) {\n      throw new KeplrError(\"keyring\", 121, \"Invalid password\");\n    }\n\n    const result: ExportKeyRingData[] = [];\n\n    for (const keyStore of this.multiKeyStore) {\n      const type = keyStore.type ?? \"mnemonic\";\n\n      switch (type) {\n        case \"mnemonic\": {\n          const mnemonic = Buffer.from(\n            await Crypto.decrypt(this.crypto, keyStore, password)\n          ).toString();\n\n          result.push({\n            bip44HDPath: keyStore.bip44HDPath ?? {\n              account: 0,\n              change: 0,\n              addressIndex: 0,\n            },\n            coinTypeForChain: keyStore.coinTypeForChain,\n            key: mnemonic,\n            meta: keyStore.meta ?? {},\n            type: \"mnemonic\",\n          });\n\n          break;\n        }\n        case \"privateKey\": {\n          const privateKey = Buffer.from(\n            await Crypto.decrypt(this.crypto, keyStore, password)\n          ).toString();\n\n          result.push({\n            bip44HDPath: keyStore.bip44HDPath ?? {\n              account: 0,\n              change: 0,\n              addressIndex: 0,\n            },\n            coinTypeForChain: keyStore.coinTypeForChain,\n            key: privateKey,\n            meta: keyStore.meta ?? {},\n            type: \"privateKey\",\n          });\n\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private static async CreateMnemonicKeyStore(\n    crypto: CommonCrypto,\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    mnemonic: string,\n    password: string,\n    meta: Record<string, string>,\n    bip44HDPath: BIP44HDPath\n  ): Promise<KeyStore> {\n    return await Crypto.encrypt(\n      crypto,\n      kdf,\n      \"mnemonic\",\n      mnemonic,\n      password,\n      meta,\n      bip44HDPath\n    );\n  }\n\n  private static async CreatePrivateKeyStore(\n    crypto: CommonCrypto,\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    privateKey: Uint8Array,\n    password: string,\n    meta: Record<string, string>\n  ): Promise<KeyStore> {\n    return await Crypto.encrypt(\n      crypto,\n      kdf,\n      \"privateKey\",\n      Buffer.from(privateKey).toString(\"hex\"),\n      password,\n      meta\n    );\n  }\n\n  private static async CreateLedgerKeyStore(\n    crypto: CommonCrypto,\n    kdf: \"scrypt\" | \"sha256\" | \"pbkdf2\",\n    publicKey: Uint8Array,\n    password: string,\n    meta: Record<string, string>,\n    bip44HDPath: BIP44HDPath\n  ): Promise<KeyStore> {\n    return await Crypto.encrypt(\n      crypto,\n      kdf,\n      \"ledger\",\n      Buffer.from(publicKey).toString(\"hex\"),\n      password,\n      meta,\n      bip44HDPath\n    );\n  }\n\n  private async assignKeyStoreIdMeta(meta: {\n    [key: string]: string;\n  }): Promise<{\n    [key: string]: string;\n  }> {\n    // `__id__` is used to distinguish the key store.\n    return Object.assign({}, meta, {\n      __id__: (await this.getIncrementalNumber()).toString(),\n    });\n  }\n\n  private static getKeyStoreId(keyStore: KeyStore): string {\n    const id = keyStore.meta?.__id__;\n    if (!id) {\n      throw new KeplrError(\"keyring\", 131, \"Key store's id is empty\");\n    }\n\n    return id;\n  }\n\n  private static getKeyStoreBIP44Path(keyStore: KeyStore): BIP44HDPath {\n    if (!keyStore.bip44HDPath) {\n      return {\n        account: 0,\n        change: 0,\n        addressIndex: 0,\n      };\n    }\n    KeyRing.validateBIP44Path(keyStore.bip44HDPath);\n    return keyStore.bip44HDPath;\n  }\n\n  public static validateBIP44Path(bip44Path: BIP44HDPath): void {\n    if (!Number.isInteger(bip44Path.account) || bip44Path.account < 0) {\n      throw new KeplrError(\"keyring\", 100, \"Invalid account in hd path\");\n    }\n\n    if (\n      !Number.isInteger(bip44Path.change) ||\n      !(bip44Path.change === 0 || bip44Path.change === 1)\n    ) {\n      throw new KeplrError(\"keyring\", 102, \"Invalid change in hd path\");\n    }\n\n    if (\n      !Number.isInteger(bip44Path.addressIndex) ||\n      bip44Path.addressIndex < 0\n    ) {\n      throw new KeplrError(\"keyring\", 101, \"Invalid address index in hd path\");\n    }\n  }\n\n  private async getIncrementalNumber(): Promise<number> {\n    let num = await this.kvStore.get<number>(\"incrementalNumber\");\n    if (num === undefined) {\n      num = 0;\n    }\n    num++;\n\n    await this.kvStore.set(\"incrementalNumber\", num);\n    return num;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}