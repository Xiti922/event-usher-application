{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokensStore = exports.TokensStoreInner = void 0;\nconst common_1 = require(\"../common\");\nconst router_1 = require(\"@keplr-wallet/router\");\nconst background_1 = require(\"@keplr-wallet/background\");\nconst mobx_1 = require(\"mobx\");\nconst common_2 = require(\"@keplr-wallet/common\");\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nclass TokensStoreInner {\n  constructor(eventListener, chainStore, chainId, requester) {\n    this.eventListener = eventListener;\n    this.chainStore = chainStore;\n    this.chainId = chainId;\n    this.requester = requester;\n    this._tokens = [];\n    mobx_1.makeObservable(this);\n    this.refreshTokens();\n    // If key store in the keplr extension is unlocked, this event will be dispatched.\n    // This is needed becuase the token such as secret20 exists according to the account.\n    this.eventListener.addEventListener(\"keplr_keystoreunlock\", () => {\n      this.refreshTokens();\n    });\n    // If key store in the keplr extension is changed, this event will be dispatched.\n    // This is needed becuase the token such as secret20 exists according to the account.\n    this.eventListener.addEventListener(\"keplr_keystorechange\", () => {\n      this.refreshTokens();\n    });\n  }\n  get tokens() {\n    return this._tokens;\n  }\n  *refreshTokens() {\n    const chainInfo = this.chainStore.getChain(this.chainId);\n    if (chainInfo.features && (\n    // Tokens service is only needed for secretwasm and cosmwasm,\n    // so, there is no need to fetch the registered token if the chain doesn't support the secretwasm and cosmwasm.\n    chainInfo.features.includes(\"secretwasm\") || chainInfo.features.includes(\"cosmwasm\"))) {\n      const msg = new background_1.GetTokensMsg(this.chainId);\n      this._tokens = yield* common_2.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));\n    } else {\n      this._tokens = [];\n    }\n  }\n  *addToken(currency) {\n    const msg = new background_1.AddTokenMsg(this.chainId, currency);\n    yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);\n    yield this.refreshTokens();\n  }\n  *removeToken(currency) {\n    const msg = new background_1.RemoveTokenMsg(this.chainId, currency);\n    yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);\n    yield this.refreshTokens();\n  }\n}\n__decorate([mobx_1.observable.ref], TokensStoreInner.prototype, \"_tokens\", void 0);\n__decorate([mobx_1.flow], TokensStoreInner.prototype, \"refreshTokens\", null);\n__decorate([mobx_1.flow], TokensStoreInner.prototype, \"addToken\", null);\n__decorate([mobx_1.flow], TokensStoreInner.prototype, \"removeToken\", null);\nexports.TokensStoreInner = TokensStoreInner;\nclass TokensStore extends common_1.HasMapStore {\n  constructor(eventListener, chainStore, requester, interactionStore) {\n    super(chainId => {\n      return new TokensStoreInner(this.eventListener, this.chainStore, chainId, this.requester);\n    });\n    this.eventListener = eventListener;\n    this.chainStore = chainStore;\n    this.requester = requester;\n    this.interactionStore = interactionStore;\n    this.prevTokens = new Map();\n    mobx_1.makeObservable(this);\n    this.chainStore.addSetChainInfoHandler(chainInfoInner => {\n      mobx_1.autorun(() => {\n        var _a;\n        const chainIdentifier = cosmos_1.ChainIdHelper.parse(chainInfoInner.chainId);\n        // Tokens should be changed whenever the account changed.\n        // But, the added currencies are not removed automatically.\n        // So, we should remove the prev token currencies from the chain info.\n        const prevToken = (_a = this.prevTokens.get(chainIdentifier.identifier)) !== null && _a !== void 0 ? _a : [];\n        chainInfoInner.removeCurrencies(...prevToken.map(token => token.coinMinimalDenom));\n        const inner = this.getTokensOf(chainInfoInner.chainId);\n        chainInfoInner.addCurrencies(...inner.tokens);\n        this.prevTokens.set(chainIdentifier.identifier, inner.tokens);\n      });\n    });\n  }\n  getTokensOf(chainId) {\n    return this.get(chainId);\n  }\n  get waitingSuggestedToken() {\n    const datas = this.interactionStore.getDatas(background_1.SuggestTokenMsg.type());\n    if (datas.length > 0) {\n      return datas[0];\n    }\n  }\n  *approveSuggestedToken(appCurrency) {\n    const data = this.waitingSuggestedToken;\n    if (data) {\n      yield this.interactionStore.approve(background_1.SuggestTokenMsg.type(), data.id, appCurrency);\n      yield this.getTokensOf(data.data.chainId).refreshTokens();\n    }\n  }\n  *rejectSuggestedToken() {\n    const data = this.waitingSuggestedToken;\n    if (data) {\n      yield this.interactionStore.reject(background_1.SuggestTokenMsg.type(), data.id);\n    }\n  }\n  *rejectAllSuggestedTokens() {\n    yield this.interactionStore.rejectAll(background_1.SuggestTokenMsg.type());\n  }\n}\n__decorate([mobx_1.flow], TokensStore.prototype, \"approveSuggestedToken\", null);\n__decorate([mobx_1.flow], TokensStore.prototype, \"rejectSuggestedToken\", null);\n__decorate([mobx_1.flow], TokensStore.prototype, \"rejectAllSuggestedTokens\", null);\nexports.TokensStore = TokensStore;","map":{"version":3,"mappings":"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","names":["TokensStoreInner","constructor","eventListener","chainStore","chainId","requester","mobx_1","refreshTokens","addEventListener","tokens","_tokens","chainInfo","getChain","features","includes","msg","background_1","common_2","sendMessage","router_1","addToken","currency","removeToken","__decorate","ref","exports","TokensStore","common_1","interactionStore","Map","addSetChainInfoHandler","chainInfoInner","chainIdentifier","cosmos_1","parse","prevToken","prevTokens","get","identifier","removeCurrencies","map","token","coinMinimalDenom","inner","getTokensOf","addCurrencies","set","waitingSuggestedToken","datas","getDatas","type","length","approveSuggestedToken","appCurrency","data","approve","id","rejectSuggestedToken","reject","rejectAllSuggestedTokens","rejectAll"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/core/tokens.ts"],"sourcesContent":["import { HasMapStore } from \"../common\";\nimport { BACKGROUND_PORT, MessageRequester } from \"@keplr-wallet/router\";\nimport {\n  AddTokenMsg,\n  GetTokensMsg,\n  RemoveTokenMsg,\n  SuggestTokenMsg,\n} from \"@keplr-wallet/background\";\nimport { autorun, flow, makeObservable, observable } from \"mobx\";\nimport { AppCurrency, ChainInfo } from \"@keplr-wallet/types\";\nimport { DeepReadonly } from \"utility-types\";\nimport { ChainStore } from \"../chain\";\nimport { InteractionStore } from \"./interaction\";\nimport { toGenerator } from \"@keplr-wallet/common\";\nimport { ChainIdHelper } from \"@keplr-wallet/cosmos\";\n\nexport class TokensStoreInner {\n  @observable.ref\n  protected _tokens: AppCurrency[] = [];\n\n  constructor(\n    protected readonly eventListener: {\n      addEventListener: (type: string, fn: () => unknown) => void;\n    },\n    protected readonly chainStore: ChainStore<any>,\n    protected readonly chainId: string,\n    protected readonly requester: MessageRequester\n  ) {\n    makeObservable(this);\n\n    this.refreshTokens();\n\n    // If key store in the keplr extension is unlocked, this event will be dispatched.\n    // This is needed becuase the token such as secret20 exists according to the account.\n    this.eventListener.addEventListener(\"keplr_keystoreunlock\", () => {\n      this.refreshTokens();\n    });\n\n    // If key store in the keplr extension is changed, this event will be dispatched.\n    // This is needed becuase the token such as secret20 exists according to the account.\n    this.eventListener.addEventListener(\"keplr_keystorechange\", () => {\n      this.refreshTokens();\n    });\n  }\n\n  get tokens(): DeepReadonly<AppCurrency[]> {\n    return this._tokens;\n  }\n\n  @flow\n  *refreshTokens() {\n    const chainInfo = this.chainStore.getChain(this.chainId);\n\n    if (\n      chainInfo.features &&\n      // Tokens service is only needed for secretwasm and cosmwasm,\n      // so, there is no need to fetch the registered token if the chain doesn't support the secretwasm and cosmwasm.\n      (chainInfo.features.includes(\"secretwasm\") ||\n        chainInfo.features.includes(\"cosmwasm\"))\n    ) {\n      const msg = new GetTokensMsg(this.chainId);\n      this._tokens = yield* toGenerator(\n        this.requester.sendMessage(BACKGROUND_PORT, msg)\n      );\n    } else {\n      this._tokens = [];\n    }\n  }\n\n  @flow\n  *addToken(currency: AppCurrency) {\n    const msg = new AddTokenMsg(this.chainId, currency);\n    yield this.requester.sendMessage(BACKGROUND_PORT, msg);\n    yield this.refreshTokens();\n  }\n\n  @flow\n  *removeToken(currency: AppCurrency) {\n    const msg = new RemoveTokenMsg(this.chainId, currency);\n    yield this.requester.sendMessage(BACKGROUND_PORT, msg);\n    yield this.refreshTokens();\n  }\n}\n\nexport class TokensStore<\n  C extends ChainInfo = ChainInfo\n> extends HasMapStore<TokensStoreInner> {\n  protected prevTokens: Map<string, AppCurrency[]> = new Map();\n\n  constructor(\n    protected readonly eventListener: {\n      addEventListener: (type: string, fn: () => unknown) => void;\n    },\n    protected readonly chainStore: ChainStore<C>,\n    protected readonly requester: MessageRequester,\n    protected readonly interactionStore: InteractionStore\n  ) {\n    super((chainId: string) => {\n      return new TokensStoreInner(\n        this.eventListener,\n        this.chainStore,\n        chainId,\n        this.requester\n      );\n    });\n    makeObservable(this);\n\n    this.chainStore.addSetChainInfoHandler((chainInfoInner) => {\n      autorun(() => {\n        const chainIdentifier = ChainIdHelper.parse(chainInfoInner.chainId);\n\n        // Tokens should be changed whenever the account changed.\n        // But, the added currencies are not removed automatically.\n        // So, we should remove the prev token currencies from the chain info.\n        const prevToken = this.prevTokens.get(chainIdentifier.identifier) ?? [];\n        chainInfoInner.removeCurrencies(\n          ...prevToken.map((token) => token.coinMinimalDenom)\n        );\n\n        const inner = this.getTokensOf(chainInfoInner.chainId);\n        chainInfoInner.addCurrencies(...inner.tokens);\n\n        this.prevTokens.set(\n          chainIdentifier.identifier,\n          inner.tokens as AppCurrency[]\n        );\n      });\n    });\n  }\n\n  getTokensOf(chainId: string) {\n    return this.get(chainId);\n  }\n\n  get waitingSuggestedToken() {\n    const datas = this.interactionStore.getDatas<{\n      chainId: string;\n      contractAddress: string;\n      viewingKey?: string;\n    }>(SuggestTokenMsg.type());\n\n    if (datas.length > 0) {\n      return datas[0];\n    }\n  }\n\n  @flow\n  *approveSuggestedToken(appCurrency: AppCurrency) {\n    const data = this.waitingSuggestedToken;\n    if (data) {\n      yield this.interactionStore.approve(\n        SuggestTokenMsg.type(),\n        data.id,\n        appCurrency\n      );\n\n      yield this.getTokensOf(data.data.chainId).refreshTokens();\n    }\n  }\n\n  @flow\n  *rejectSuggestedToken() {\n    const data = this.waitingSuggestedToken;\n    if (data) {\n      yield this.interactionStore.reject(SuggestTokenMsg.type(), data.id);\n    }\n  }\n\n  @flow\n  *rejectAllSuggestedTokens() {\n    yield this.interactionStore.rejectAll(SuggestTokenMsg.type());\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}