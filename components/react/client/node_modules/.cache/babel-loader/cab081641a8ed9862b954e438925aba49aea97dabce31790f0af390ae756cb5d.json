{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeStores = void 0;\n/**\n * The pattern of using one store with multiple sub stores is often used.\n * For example, `queries.cosmos, queries.cosmwasm` is used by putting sub-stores per module in the main store.\n * This is a function that handles this part in common way.\n * `merge` is only provided at a shallow level and can't handle properly for deep, nested objects.\n * Also, if the properties of objects overlap, it does not guarantee proper functioning.\n *\n * AFAIK, `variadic tuple types` and `recursive conditional types` features are introduced in typescript 4,\n * thus, this only works on typescript 4+.\n *\n * KR: `Base`로부터 시작해서 Injects의 값들을 강제로 주입(?)한다. 실제 구현은 구리고 단순하다.\n *      단순히 이후의 object의 field들을 강제로 이전의 결과에 같은 key로 집어넣는다.\n *      즉, nested object나 deep object는 다루지 못 한다. 또한 `Base`로 전달된 값을 mutate한다.\n *      같은 key의 field가 이미 이전 결과에 존재한다면 오류를 던진다.\n *      @keplr-wallet/stores 패키지 내에서 필요로 하는 최소한의 기능만을 한다.\n *      최소한의 case만을 다룰 수 있기 때문에 어떤 함수인지 이해한 상태로만 사용하길 바람.\n *\n * @param baseStore The base store on top.\n * @param parameters Tuple to pass to fns as parameters.\n * @param fns The functions to create the merged object.\n */\nconst mergeStores = function (baseStore, parameters) {\n  for (let i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {\n    const fn = i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2];\n    const r = fn(baseStore, ...parameters);\n    for (const key of Object.keys(r)) {\n      if (baseStore[key]) {\n        throw new Error(`${key} is already merged`);\n      }\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      baseStore[key] = r[key];\n    }\n  }\n  return baseStore;\n};\nexports.mergeStores = mergeStores;","map":{"version":3,"mappings":";;;;;;AA4CA;;;;;;;;;;;;;;;;;;;;;AAqBO,MAAMA,WAAW,GAAG,UAMzBC,SAAe,EACfC,UAAkB,EAER;EACV,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,qDAAa,EAAEA,CAAC,EAAE,EAAE;IACnC,MAAMC,EAAE,GAAOD,CAAC,gCAADA,CAAC,6BAADA,CAAC,KAA0B;IAC1C,MAAME,CAAC,GAAGD,EAAE,CAACH,SAAS,EAAE,GAAGC,UAAU,CAAC;IAEtC,KAAK,MAAMI,GAAG,IAAIC,MAAM,CAACC,IAAI,CAACH,CAAC,CAAC,EAAE;MAChC,IAAIJ,SAAS,CAACK,GAAG,CAAC,EAAE;QAClB,MAAM,IAAIG,KAAK,CAAC,GAAGH,GAAG,oBAAoB,CAAC;;MAE7C;MACA;MACAL,SAAS,CAACK,GAAG,CAAC,GAAGD,CAAC,CAACC,GAAG,CAAC;;;EAI3B,OAAOL,SAAgB;AACzB,CAAC;AAzBYS,mBAAW","names":["mergeStores","baseStore","parameters","i","fn","r","key","Object","keys","Error","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/common/merge.ts"],"sourcesContent":["import { UnionToIntersection } from \"utility-types\";\n\nexport interface IObject {\n  [key: string]: any;\n  length?: never;\n}\n\n/**\n * Makes the function that accepts tuple `Params` as parameter and return `Return`.\n * This is not useful when used alone.\n * This is used to implement `TupleFunctionify` and `mergeStores`.\n *\n * Functionify<[number, string], number> = (n:number, s:string) => number\n */\nexport type Functionify<Params extends Array<any>, Return> = (\n  ...p: Params\n) => Return;\n/**\n * Make the tuple of functions that accept `Base` tuple `Params` as parameter and return `Injects` respectively.\n * The passed `Base` parameter is merged from `Base` by chaining.\n *\n * KR: `Base`부터 시작해서 다음 Inject에는 이전 Inject의 결과가 merge된 값이 파라미터에 전달된다.\n *\n * ChainedFunctionifyTuple<{base: boolean}, [number, string], [{test1: number}, {test2: number}, {test3: string}]> =\n *  [\n *      ({base: boolean}, n:number, s:string) => {test1: number},\n *      ({base: boolean, test1: number}, n:number, s:string) => {test2: number},\n *      ({base: boolean, test1: number, test2: number}, n:number, s:string) => {test3: string}\n *  ]\n *\n * AFAIK, `variadic tuple types` and `recursive conditional types` features are introduced in typescript 4,\n * thus, this only works on typescript 4+.\n */\nexport type ChainedFunctionifyTuple<\n  Base extends IObject,\n  Params extends Array<any>,\n  Injects extends Array<any>\n> = Injects extends [infer Head, ...infer Tail]\n  ? [\n      Functionify<[Base, ...Params], Head>,\n      ...ChainedFunctionifyTuple<Base & Head, Params, Tail>\n    ]\n  : [];\n\n/**\n * The pattern of using one store with multiple sub stores is often used.\n * For example, `queries.cosmos, queries.cosmwasm` is used by putting sub-stores per module in the main store.\n * This is a function that handles this part in common way.\n * `merge` is only provided at a shallow level and can't handle properly for deep, nested objects.\n * Also, if the properties of objects overlap, it does not guarantee proper functioning.\n *\n * AFAIK, `variadic tuple types` and `recursive conditional types` features are introduced in typescript 4,\n * thus, this only works on typescript 4+.\n *\n * KR: `Base`로부터 시작해서 Injects의 값들을 강제로 주입(?)한다. 실제 구현은 구리고 단순하다.\n *      단순히 이후의 object의 field들을 강제로 이전의 결과에 같은 key로 집어넣는다.\n *      즉, nested object나 deep object는 다루지 못 한다. 또한 `Base`로 전달된 값을 mutate한다.\n *      같은 key의 field가 이미 이전 결과에 존재한다면 오류를 던진다.\n *      @keplr-wallet/stores 패키지 내에서 필요로 하는 최소한의 기능만을 한다.\n *      최소한의 case만을 다룰 수 있기 때문에 어떤 함수인지 이해한 상태로만 사용하길 바람.\n *\n * @param baseStore The base store on top.\n * @param parameters Tuple to pass to fns as parameters.\n * @param fns The functions to create the merged object.\n */\nexport const mergeStores = <\n  Base extends IObject,\n  Params extends Array<any>,\n  Injects extends Array<IObject>,\n  Return = Base & UnionToIntersection<Injects[number]>\n>(\n  baseStore: Base,\n  parameters: Params,\n  ...fns: ChainedFunctionifyTuple<Base, Params, Injects>\n): Return => {\n  for (let i = 0; i < fns.length; i++) {\n    const fn = fns[i] as Functionify<any, any>;\n    const r = fn(baseStore, ...parameters);\n\n    for (const key of Object.keys(r)) {\n      if (baseStore[key]) {\n        throw new Error(`${key} is already merged`);\n      }\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      baseStore[key] = r[key];\n    }\n  }\n\n  return baseStore as any;\n};\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}