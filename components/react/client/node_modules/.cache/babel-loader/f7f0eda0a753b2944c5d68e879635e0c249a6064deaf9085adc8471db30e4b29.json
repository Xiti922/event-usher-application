{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChainUpdaterService = void 0;\nconst axios_1 = __importDefault(require(\"axios\"));\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nconst router_1 = require(\"@keplr-wallet/router\");\nclass ChainUpdaterService {\n  constructor(kvStore) {\n    this.kvStore = kvStore;\n  }\n  init(chainsService) {\n    this.chainsService = chainsService;\n  }\n  putUpdatedPropertyToChainInfo(chainInfo) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const updatedProperty = yield this.getUpdatedChainProperty(chainInfo.chainId);\n      const chainId = cosmos_1.ChainIdHelper.parse(chainInfo.chainId);\n      const updatedChainId = cosmos_1.ChainIdHelper.parse(updatedProperty.chainId || chainInfo.chainId);\n      // If the saved property is lesser than the current chain id, just ignore.\n      if (updatedChainId.version < chainId.version) {\n        return chainInfo;\n      }\n      const features = (_a = chainInfo.features) !== null && _a !== void 0 ? _a : [];\n      for (const updatedFeature of (_b = updatedProperty.features) !== null && _b !== void 0 ? _b : []) {\n        if (!features.includes(updatedFeature)) {\n          features.push(updatedFeature);\n        }\n      }\n      return Object.assign(Object.assign({}, chainInfo), {\n        chainId: updatedProperty.chainId || chainInfo.chainId,\n        rpc: updatedProperty.rpc || chainInfo.rpc,\n        rest: updatedProperty.rest || chainInfo.rest,\n        features\n      });\n    });\n  }\n  clearUpdatedProperty(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.kvStore.set(cosmos_1.ChainIdHelper.parse(chainId).identifier, null);\n      this.chainsService.clearCachedChainInfos();\n    });\n  }\n  tryUpdateChain(chainId) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainInfo = yield this.chainsService.getChainInfo(chainId);\n      // If chain id is not fomatted as {chainID}-{version},\n      // there is no way to deal with the updated chain id.\n      if (!cosmos_1.ChainIdHelper.hasChainVersion(chainInfo.chainId)) {\n        return;\n      }\n      const updates = yield ChainUpdaterService.checkChainUpdate(chainInfo);\n      if (updates.explicit || updates.slient) {\n        const currentVersion = cosmos_1.ChainIdHelper.parse(chainInfo.chainId);\n        if (updates.chainId) {\n          const fetchedChainId = updates.chainId;\n          const fetchedVersion = cosmos_1.ChainIdHelper.parse(fetchedChainId);\n          if (currentVersion.identifier === fetchedVersion.identifier && currentVersion.version < fetchedVersion.version) {\n            yield this.saveChainProperty(currentVersion.identifier, {\n              chainId: fetchedChainId\n            });\n          }\n        }\n        if (updates.features && updates.features.length > 0) {\n          const savedChainProperty = yield this.getUpdatedChainProperty(chainInfo.chainId);\n          const updateFeatures = (_a = savedChainProperty.features) !== null && _a !== void 0 ? _a : [];\n          for (const feature of updates.features) {\n            if (!updateFeatures.includes(feature)) {\n              updateFeatures.push(feature);\n            }\n          }\n          yield this.saveChainProperty(currentVersion.identifier, {\n            features: updateFeatures\n          });\n        }\n      }\n    });\n  }\n  getUpdatedChainProperty(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const version = cosmos_1.ChainIdHelper.parse(chainId);\n      return yield this.loadChainProperty(version.identifier);\n    });\n  }\n  saveChainProperty(identifier, chainInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const saved = yield this.loadChainProperty(identifier);\n      yield this.kvStore.set(identifier, Object.assign(Object.assign({}, saved), chainInfo));\n      this.chainsService.clearCachedChainInfos();\n    });\n  }\n  loadChainProperty(identifier) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainInfo = yield this.kvStore.get(identifier);\n      if (!chainInfo) return {};\n      return chainInfo;\n    });\n  }\n  /**\n   * Returns wether the chain has been changed.\n   * Currently, only check the chain id has been changed.\n   * @param chainInfo Chain information.\n   */\n  static checkChainUpdate(chainInfo) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainId = chainInfo.chainId;\n      // If chain id is not fomatted as {chainID}-{version},\n      // there is no way to deal with the updated chain id.\n      if (!cosmos_1.ChainIdHelper.hasChainVersion(chainId)) {\n        return {\n          explicit: false,\n          slient: false\n        };\n      }\n      const instance = axios_1.default.create({\n        baseURL: chainInfo.rpc\n      });\n      // Get the status to get the chain id.\n      const result = yield instance.get(\"/status\");\n      const resultChainId = result.data.result.node_info.network;\n      const version = cosmos_1.ChainIdHelper.parse(chainId);\n      const fetchedVersion = cosmos_1.ChainIdHelper.parse(resultChainId);\n      // TODO: Should throw an error?\n      if (version.identifier !== fetchedVersion.identifier) {\n        return {\n          explicit: false,\n          slient: false\n        };\n      }\n      const restInstance = axios_1.default.create({\n        baseURL: chainInfo.rest\n      });\n      let ibcGoUpdates = false;\n      try {\n        if (!chainInfo.features || !chainInfo.features.includes(\"ibc-go\")) {\n          // If the chain uses the ibc-go module separated from the cosmos-sdk,\n          // we need to check it because the REST API is different.\n          const result = yield restInstance.get(\"/ibc/apps/transfer/v1/params\");\n          if (result.status === 200) {\n            ibcGoUpdates = true;\n          }\n        }\n      } catch (_b) {}\n      let ibcTransferUpdate = false;\n      try {\n        if (!chainInfo.features || !chainInfo.features.includes(\"ibc-transfer\")) {\n          const isIBCGo = ibcGoUpdates || chainInfo.features && chainInfo.features.includes(\"ibc-go\");\n          // If the chain doesn't have the ibc transfer feature,\n          // try to fetch the params of ibc transfer module.\n          // assume that it can support the ibc transfer if the params return true, and try to update the features.\n          const result = yield restInstance.get(isIBCGo ? \"/ibc/apps/transfer/v1/params\" : \"/ibc/applications/transfer/v1beta1/params\");\n          if (result.data.params.receive_enabled && result.data.params.send_enabled) {\n            ibcTransferUpdate = true;\n          }\n        }\n      } catch (_c) {}\n      let wasmd24Update = false;\n      try {\n        if (((_a = chainInfo.features) === null || _a === void 0 ? void 0 : _a.includes(\"cosmwasm\")) && !chainInfo.features.includes(\"wasmd_0.24+\")) {\n          // It is difficult to decide which contract address to test on each chain.\n          // So it simply sends a query that fails unconditionally.\n          // However, if 400 bad request instead of 501 occurs, the url itself exists.\n          // In this case, it is assumed that wasmd 0.24+ version.\n          const result = yield restInstance.get(\"/cosmwasm/wasm/v1/contract/test/smart/test\", {\n            validateStatus: status => {\n              return status === 400 || status === 501;\n            }\n          });\n          if (result.status === 400) {\n            wasmd24Update = true;\n          }\n        }\n      } catch (_d) {}\n      let querySpendableBalances = false;\n      try {\n        if (!chainInfo.features || !chainInfo.features.includes(\"query:/cosmos/bank/v1beta1/spendable_balances\")) {\n          // It is difficult to decide which account to test on each chain.\n          // So it simply sends a query that fails unconditionally.\n          // However, if 400 bad request instead of 501 occurs, the url itself exists.\n          // In this case, it is assumed that we can query /cosmos/bank/v1beta1/spendable_balances/{account}\n          const result = yield restInstance.get(\"/cosmos/bank/v1beta1/spendable_balances/test\", {\n            validateStatus: status => {\n              return status === 400 || status === 501;\n            }\n          });\n          if (result.status === 400) {\n            querySpendableBalances = true;\n          }\n        }\n      } catch (_e) {}\n      const features = [];\n      if (ibcGoUpdates) {\n        features.push(\"ibc-go\");\n      }\n      if (ibcTransferUpdate) {\n        features.push(\"ibc-transfer\");\n      }\n      if (wasmd24Update) {\n        features.push(\"wasmd_0.24+\");\n      }\n      if (querySpendableBalances) {\n        features.push(\"query:/cosmos/bank/v1beta1/spendable_balances\");\n      }\n      return {\n        explicit: version.version < fetchedVersion.version,\n        slient: features.length > 0,\n        chainId: resultChainId,\n        features\n      };\n    });\n  }\n  // XXX: It is not conceptually valid that the function to set the rpc/rest endpoint of the chain exists in this service.\n  //      However, in order to focus on adding feature rather than making a big change, the refactor is postponed later and the configuration of the rpc/rest endpoint is handled here.\n  setChainEndpoints(chainId, rpc, rest) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainInfo = {};\n      // `saveChainProperty` method merges chain info using spread operator.\n      // That is, if the field is undefined, the field is finally saved as undefined and the field is treated as if it were deleted.\n      // To avoid this problem, the field must not exist. The implementation of the below is critical to its operation.\n      if (rpc) {\n        chainInfo.rpc = rpc;\n      }\n      if (rest) {\n        chainInfo.rest = rest;\n      }\n      const version = cosmos_1.ChainIdHelper.parse(chainId);\n      yield this.saveChainProperty(version.identifier, chainInfo);\n      return yield this.chainsService.getChainInfos();\n    });\n  }\n  resetChainEndpoints(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const version = cosmos_1.ChainIdHelper.parse(chainId);\n      // `saveChainProperty` method merges chain info using spread operator.\n      // That is, if the field is undefined, the field is finally saved as undefined and the field is treated as if it were deleted.\n      yield this.saveChainProperty(version.identifier, {\n        rpc: undefined,\n        rest: undefined\n      });\n      return yield this.chainsService.getChainInfos();\n    });\n  }\n  static checkEndpointsConnectivity(chainId, rpc, rest, wsObject) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const rpcInstance = axios_1.default.create({\n        baseURL: rpc\n      });\n      let resultStatus;\n      try {\n        // Get the status to get the chain id.\n        resultStatus = yield rpcInstance.get(\"/status\");\n      } catch (e) {\n        console.log(e);\n        throw new Error(\"Failed to get response /status from rpc endpoint\");\n      }\n      const version = cosmos_1.ChainIdHelper.parse(chainId);\n      const versionFromRPCStatus = cosmos_1.ChainIdHelper.parse(resultStatus.data.result.node_info.network);\n      if (versionFromRPCStatus.identifier !== version.identifier) {\n        throw new router_1.KeplrError(\"updater\", 8001, `RPC endpoint has different chain id (expected: ${chainId}, actual: ${resultStatus.data.result.node_info.network})`);\n      } else if (versionFromRPCStatus.version !== version.version) {\n        // In the form of {chain_identifier}-{chain_version}, if the identifier is the same but the version is different, it is strictly an error,\n        // but it is actually the same chain but the chain version of the node is different.\n        // In this case, it is possible to treat as a warning and proceed as it is, so this is separated with above error.\n        throw new router_1.KeplrError(\"updater\", 8002, `RPC endpoint has different chain id (expected: ${chainId}, actual: ${resultStatus.data.result.node_info.network})`);\n      }\n      let wsURL = rpc;\n      if (wsURL.startsWith(\"http\")) {\n        wsURL = wsURL.replace(\"http\", \"ws\");\n      }\n      wsURL = wsURL.endsWith(\"/\") ? wsURL + \"websocket\" : wsURL + \"/websocket\";\n      const wsInstance = wsObject ? new wsObject(wsURL) : new WebSocket(wsURL);\n      // Try 15 times at 1 second intervals to test websocket connectivity.\n      for (let i = 0; i < 15; i++) {\n        // If ws state is not \"connecting\"\n        if (wsInstance.readyState !== 0) {\n          // If ws state is \"open\", it means that app can connect ws to /websocket rpc\n          if (wsInstance.readyState === 1) {\n            break;\n          } else {\n            // else, handle that as error.\n            throw new Error(\"Failed to connect websocket to /websocket rpc\");\n          }\n        }\n        yield new Promise(resolve => setTimeout(resolve, 1000));\n      }\n      const restInstance = axios_1.default.create({\n        baseURL: rest\n      });\n      let resultLCDNodeInfo;\n      try {\n        // Get the node info to get the chain id.\n        resultLCDNodeInfo = yield restInstance.get(\"/cosmos/base/tendermint/v1beta1/node_info\");\n      } catch (e) {\n        console.log(e);\n        throw new Error(\"Failed to get response /cosmos/base/tendermint/v1beta1/node_info from lcd endpoint\");\n      }\n      const versionFromLCDNodeInfo = cosmos_1.ChainIdHelper.parse(resultLCDNodeInfo.data.default_node_info.network);\n      if (versionFromLCDNodeInfo.identifier !== version.identifier) {\n        throw new router_1.KeplrError(\"updater\", 8101, `LCD endpoint has different chain id (expected: ${chainId}, actual: ${resultStatus.data.result.node_info.network})`);\n      } else if (versionFromLCDNodeInfo.version !== version.version) {\n        // In the form of {chain_identifier}-{chain_version}, if the identifier is the same but the version is different, it is strictly an error,\n        // but it is actually the same chain but the chain version of the node is different.\n        // In this case, it is possible to treat as a warning and proceed as it is, so this is separated with above error.\n        throw new router_1.KeplrError(\"updater\", 8102, `LCD endpoint has different chain id (expected: ${chainId}, actual: ${resultStatus.data.result.node_info.network})`);\n      }\n    });\n  }\n}\nexports.ChainUpdaterService = ChainUpdaterService;","map":{"version":3,"mappings":"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","names":["ChainUpdaterService","constructor","kvStore","init","chainsService","putUpdatedPropertyToChainInfo","chainInfo","updatedProperty","getUpdatedChainProperty","chainId","cosmos_1","parse","updatedChainId","version","features","updatedFeature","includes","push","rpc","rest","clearUpdatedProperty","set","identifier","clearCachedChainInfos","tryUpdateChain","getChainInfo","hasChainVersion","updates","checkChainUpdate","explicit","slient","currentVersion","fetchedChainId","fetchedVersion","saveChainProperty","length","savedChainProperty","updateFeatures","feature","loadChainProperty","saved","get","instance","axios_1","create","baseURL","result","resultChainId","data","node_info","network","restInstance","ibcGoUpdates","status","ibcTransferUpdate","isIBCGo","params","receive_enabled","send_enabled","wasmd24Update","validateStatus","querySpendableBalances","setChainEndpoints","getChainInfos","resetChainEndpoints","undefined","checkEndpointsConnectivity","wsObject","rpcInstance","resultStatus","e","console","log","Error","versionFromRPCStatus","router_1","wsURL","startsWith","replace","endsWith","wsInstance","WebSocket","i","readyState","Promise","resolve","setTimeout","resultLCDNodeInfo","versionFromLCDNodeInfo","default_node_info","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/background/src/updater/service.ts"],"sourcesContent":["import { ChainInfo } from \"@keplr-wallet/types\";\nimport Axios, { AxiosResponse } from \"axios\";\nimport { KVStore } from \"@keplr-wallet/common\";\nimport { ChainIdHelper } from \"@keplr-wallet/cosmos\";\nimport { ChainInfoWithEmbed, ChainsService } from \"../chains\";\nimport { Mutable } from \"utility-types\";\nimport { KeplrError } from \"@keplr-wallet/router\";\n\nexport class ChainUpdaterService {\n  protected chainsService!: ChainsService;\n\n  constructor(protected readonly kvStore: KVStore) {}\n\n  init(chainsService: ChainsService) {\n    this.chainsService = chainsService;\n  }\n\n  async putUpdatedPropertyToChainInfo(\n    chainInfo: ChainInfo\n  ): Promise<ChainInfo> {\n    const updatedProperty = await this.getUpdatedChainProperty(\n      chainInfo.chainId\n    );\n\n    const chainId = ChainIdHelper.parse(chainInfo.chainId);\n    const updatedChainId = ChainIdHelper.parse(\n      updatedProperty.chainId || chainInfo.chainId\n    );\n\n    // If the saved property is lesser than the current chain id, just ignore.\n    if (updatedChainId.version < chainId.version) {\n      return chainInfo;\n    }\n\n    const features = chainInfo.features ?? [];\n    for (const updatedFeature of updatedProperty.features ?? []) {\n      if (!features.includes(updatedFeature)) {\n        features.push(updatedFeature);\n      }\n    }\n\n    return {\n      ...chainInfo,\n      ...{\n        chainId: updatedProperty.chainId || chainInfo.chainId,\n        rpc: updatedProperty.rpc || chainInfo.rpc,\n        rest: updatedProperty.rest || chainInfo.rest,\n        features,\n      },\n    };\n  }\n\n  async clearUpdatedProperty(chainId: string) {\n    await this.kvStore.set(ChainIdHelper.parse(chainId).identifier, null);\n\n    this.chainsService.clearCachedChainInfos();\n  }\n\n  async tryUpdateChain(chainId: string) {\n    const chainInfo = await this.chainsService.getChainInfo(chainId);\n\n    // If chain id is not fomatted as {chainID}-{version},\n    // there is no way to deal with the updated chain id.\n    if (!ChainIdHelper.hasChainVersion(chainInfo.chainId)) {\n      return;\n    }\n\n    const updates = await ChainUpdaterService.checkChainUpdate(chainInfo);\n\n    if (updates.explicit || updates.slient) {\n      const currentVersion = ChainIdHelper.parse(chainInfo.chainId);\n\n      if (updates.chainId) {\n        const fetchedChainId = updates.chainId;\n        const fetchedVersion = ChainIdHelper.parse(fetchedChainId);\n\n        if (\n          currentVersion.identifier === fetchedVersion.identifier &&\n          currentVersion.version < fetchedVersion.version\n        ) {\n          await this.saveChainProperty(currentVersion.identifier, {\n            chainId: fetchedChainId,\n          });\n        }\n      }\n\n      if (updates.features && updates.features.length > 0) {\n        const savedChainProperty = await this.getUpdatedChainProperty(\n          chainInfo.chainId\n        );\n\n        const updateFeatures = savedChainProperty.features ?? [];\n\n        for (const feature of updates.features) {\n          if (!updateFeatures.includes(feature)) {\n            updateFeatures.push(feature);\n          }\n        }\n\n        await this.saveChainProperty(currentVersion.identifier, {\n          features: updateFeatures,\n        });\n      }\n    }\n  }\n\n  private async getUpdatedChainProperty(\n    chainId: string\n  ): Promise<Partial<ChainInfo>> {\n    const version = ChainIdHelper.parse(chainId);\n\n    return await this.loadChainProperty(version.identifier);\n  }\n\n  private async saveChainProperty(\n    identifier: string,\n    chainInfo: Partial<ChainInfo>\n  ) {\n    const saved = await this.loadChainProperty(identifier);\n\n    await this.kvStore.set(identifier, {\n      ...saved,\n      ...chainInfo,\n    });\n\n    this.chainsService.clearCachedChainInfos();\n  }\n\n  private async loadChainProperty(\n    identifier: string\n  ): Promise<Partial<ChainInfo>> {\n    const chainInfo = await this.kvStore.get<Partial<ChainInfo>>(identifier);\n    if (!chainInfo) return {};\n    return chainInfo;\n  }\n\n  /**\n   * Returns wether the chain has been changed.\n   * Currently, only check the chain id has been changed.\n   * @param chainInfo Chain information.\n   */\n  public static async checkChainUpdate(\n    chainInfo: Readonly<ChainInfo>\n  ): Promise<{\n    explicit: boolean;\n    slient: boolean;\n\n    chainId?: string;\n    features?: string[];\n  }> {\n    const chainId = chainInfo.chainId;\n\n    // If chain id is not fomatted as {chainID}-{version},\n    // there is no way to deal with the updated chain id.\n    if (!ChainIdHelper.hasChainVersion(chainId)) {\n      return {\n        explicit: false,\n        slient: false,\n      };\n    }\n\n    const instance = Axios.create({\n      baseURL: chainInfo.rpc,\n    });\n\n    // Get the status to get the chain id.\n    const result = await instance.get<{\n      result: {\n        node_info: {\n          network: string;\n        };\n      };\n    }>(\"/status\");\n\n    const resultChainId = result.data.result.node_info.network;\n\n    const version = ChainIdHelper.parse(chainId);\n    const fetchedVersion = ChainIdHelper.parse(resultChainId);\n\n    // TODO: Should throw an error?\n    if (version.identifier !== fetchedVersion.identifier) {\n      return {\n        explicit: false,\n        slient: false,\n      };\n    }\n\n    const restInstance = Axios.create({\n      baseURL: chainInfo.rest,\n    });\n\n    let ibcGoUpdates = false;\n    try {\n      if (!chainInfo.features || !chainInfo.features.includes(\"ibc-go\")) {\n        // If the chain uses the ibc-go module separated from the cosmos-sdk,\n        // we need to check it because the REST API is different.\n        const result = await restInstance.get<{\n          params: {\n            receive_enabled: boolean;\n            send_enabled: boolean;\n          };\n        }>(\"/ibc/apps/transfer/v1/params\");\n\n        if (result.status === 200) {\n          ibcGoUpdates = true;\n        }\n      }\n    } catch {}\n\n    let ibcTransferUpdate = false;\n    try {\n      if (!chainInfo.features || !chainInfo.features.includes(\"ibc-transfer\")) {\n        const isIBCGo =\n          ibcGoUpdates ||\n          (chainInfo.features && chainInfo.features.includes(\"ibc-go\"));\n\n        // If the chain doesn't have the ibc transfer feature,\n        // try to fetch the params of ibc transfer module.\n        // assume that it can support the ibc transfer if the params return true, and try to update the features.\n        const result = await restInstance.get<{\n          params: {\n            receive_enabled: boolean;\n            send_enabled: boolean;\n          };\n        }>(\n          isIBCGo\n            ? \"/ibc/apps/transfer/v1/params\"\n            : \"/ibc/applications/transfer/v1beta1/params\"\n        );\n        if (\n          result.data.params.receive_enabled &&\n          result.data.params.send_enabled\n        ) {\n          ibcTransferUpdate = true;\n        }\n      }\n    } catch {}\n\n    let wasmd24Update = false;\n    try {\n      if (\n        chainInfo.features?.includes(\"cosmwasm\") &&\n        !chainInfo.features.includes(\"wasmd_0.24+\")\n      ) {\n        // It is difficult to decide which contract address to test on each chain.\n        // So it simply sends a query that fails unconditionally.\n        // However, if 400 bad request instead of 501 occurs, the url itself exists.\n        // In this case, it is assumed that wasmd 0.24+ version.\n        const result = await restInstance.get(\n          \"/cosmwasm/wasm/v1/contract/test/smart/test\",\n          {\n            validateStatus: (status) => {\n              return status === 400 || status === 501;\n            },\n          }\n        );\n        if (result.status === 400) {\n          wasmd24Update = true;\n        }\n      }\n    } catch {}\n\n    let querySpendableBalances = false;\n    try {\n      if (\n        !chainInfo.features ||\n        !chainInfo.features.includes(\n          \"query:/cosmos/bank/v1beta1/spendable_balances\"\n        )\n      ) {\n        // It is difficult to decide which account to test on each chain.\n        // So it simply sends a query that fails unconditionally.\n        // However, if 400 bad request instead of 501 occurs, the url itself exists.\n        // In this case, it is assumed that we can query /cosmos/bank/v1beta1/spendable_balances/{account}\n        const result = await restInstance.get(\n          \"/cosmos/bank/v1beta1/spendable_balances/test\",\n          {\n            validateStatus: (status) => {\n              return status === 400 || status === 501;\n            },\n          }\n        );\n        if (result.status === 400) {\n          querySpendableBalances = true;\n        }\n      }\n    } catch {}\n\n    const features: string[] = [];\n    if (ibcGoUpdates) {\n      features.push(\"ibc-go\");\n    }\n    if (ibcTransferUpdate) {\n      features.push(\"ibc-transfer\");\n    }\n    if (wasmd24Update) {\n      features.push(\"wasmd_0.24+\");\n    }\n    if (querySpendableBalances) {\n      features.push(\"query:/cosmos/bank/v1beta1/spendable_balances\");\n    }\n\n    return {\n      explicit: version.version < fetchedVersion.version,\n      slient: features.length > 0,\n\n      chainId: resultChainId,\n      features,\n    };\n  }\n\n  // XXX: It is not conceptually valid that the function to set the rpc/rest endpoint of the chain exists in this service.\n  //      However, in order to focus on adding feature rather than making a big change, the refactor is postponed later and the configuration of the rpc/rest endpoint is handled here.\n\n  public async setChainEndpoints(\n    chainId: string,\n    rpc: string | undefined,\n    rest: string | undefined\n  ): Promise<ChainInfoWithEmbed[]> {\n    const chainInfo: Mutable<Partial<ChainInfo>> = {};\n\n    // `saveChainProperty` method merges chain info using spread operator.\n    // That is, if the field is undefined, the field is finally saved as undefined and the field is treated as if it were deleted.\n    // To avoid this problem, the field must not exist. The implementation of the below is critical to its operation.\n    if (rpc) {\n      chainInfo.rpc = rpc;\n    }\n    if (rest) {\n      chainInfo.rest = rest;\n    }\n\n    const version = ChainIdHelper.parse(chainId);\n\n    await this.saveChainProperty(version.identifier, chainInfo);\n\n    return await this.chainsService.getChainInfos();\n  }\n\n  public async resetChainEndpoints(\n    chainId: string\n  ): Promise<ChainInfoWithEmbed[]> {\n    const version = ChainIdHelper.parse(chainId);\n\n    // `saveChainProperty` method merges chain info using spread operator.\n    // That is, if the field is undefined, the field is finally saved as undefined and the field is treated as if it were deleted.\n    await this.saveChainProperty(version.identifier, {\n      rpc: undefined,\n      rest: undefined,\n    });\n\n    return await this.chainsService.getChainInfos();\n  }\n\n  public static async checkEndpointsConnectivity(\n    chainId: string,\n    rpc: string,\n    rest: string,\n    wsObject?: new (url: string, protocols?: string | string[]) => WebSocket\n  ): Promise<void> {\n    const rpcInstance = Axios.create({\n      baseURL: rpc,\n    });\n\n    let resultStatus: AxiosResponse<{\n      result: {\n        node_info: {\n          network: string;\n        };\n      };\n    }>;\n\n    try {\n      // Get the status to get the chain id.\n      resultStatus = await rpcInstance.get<{\n        result: {\n          node_info: {\n            network: string;\n          };\n        };\n      }>(\"/status\");\n    } catch (e) {\n      console.log(e);\n      throw new Error(\"Failed to get response /status from rpc endpoint\");\n    }\n\n    const version = ChainIdHelper.parse(chainId);\n\n    const versionFromRPCStatus = ChainIdHelper.parse(\n      resultStatus.data.result.node_info.network\n    );\n\n    if (versionFromRPCStatus.identifier !== version.identifier) {\n      throw new KeplrError(\n        \"updater\",\n        8001,\n        `RPC endpoint has different chain id (expected: ${chainId}, actual: ${resultStatus.data.result.node_info.network})`\n      );\n    } else if (versionFromRPCStatus.version !== version.version) {\n      // In the form of {chain_identifier}-{chain_version}, if the identifier is the same but the version is different, it is strictly an error,\n      // but it is actually the same chain but the chain version of the node is different.\n      // In this case, it is possible to treat as a warning and proceed as it is, so this is separated with above error.\n      throw new KeplrError(\n        \"updater\",\n        8002,\n        `RPC endpoint has different chain id (expected: ${chainId}, actual: ${resultStatus.data.result.node_info.network})`\n      );\n    }\n\n    let wsURL = rpc;\n    if (wsURL.startsWith(\"http\")) {\n      wsURL = wsURL.replace(\"http\", \"ws\");\n    }\n    wsURL = wsURL.endsWith(\"/\") ? wsURL + \"websocket\" : wsURL + \"/websocket\";\n\n    const wsInstance = wsObject ? new wsObject(wsURL) : new WebSocket(wsURL);\n\n    // Try 15 times at 1 second intervals to test websocket connectivity.\n    for (let i = 0; i < 15; i++) {\n      // If ws state is not \"connecting\"\n      if (wsInstance.readyState !== 0) {\n        // If ws state is \"open\", it means that app can connect ws to /websocket rpc\n        if (wsInstance.readyState === 1) {\n          break;\n        } else {\n          // else, handle that as error.\n          throw new Error(\"Failed to connect websocket to /websocket rpc\");\n        }\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n    }\n\n    const restInstance = Axios.create({\n      baseURL: rest,\n    });\n\n    let resultLCDNodeInfo: AxiosResponse<{\n      default_node_info: {\n        network: string;\n      };\n    }>;\n\n    try {\n      // Get the node info to get the chain id.\n      resultLCDNodeInfo = await restInstance.get<{\n        default_node_info: {\n          network: string;\n        };\n      }>(\"/cosmos/base/tendermint/v1beta1/node_info\");\n    } catch (e) {\n      console.log(e);\n      throw new Error(\n        \"Failed to get response /cosmos/base/tendermint/v1beta1/node_info from lcd endpoint\"\n      );\n    }\n\n    const versionFromLCDNodeInfo = ChainIdHelper.parse(\n      resultLCDNodeInfo.data.default_node_info.network\n    );\n\n    if (versionFromLCDNodeInfo.identifier !== version.identifier) {\n      throw new KeplrError(\n        \"updater\",\n        8101,\n        `LCD endpoint has different chain id (expected: ${chainId}, actual: ${resultStatus.data.result.node_info.network})`\n      );\n    } else if (versionFromLCDNodeInfo.version !== version.version) {\n      // In the form of {chain_identifier}-{chain_version}, if the identifier is the same but the version is different, it is strictly an error,\n      // but it is actually the same chain but the chain version of the node is different.\n      // In this case, it is possible to treat as a warning and proceed as it is, so this is separated with above error.\n      throw new KeplrError(\n        \"updater\",\n        8102,\n        `LCD endpoint has different chain id (expected: ${chainId}, actual: ${resultStatus.data.result.node_info.network})`\n      );\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}