{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableQueryBalances = exports.ObservableQueryBalancesInner = exports.ObservableQueryBalanceInner = void 0;\nconst chain_query_1 = require(\"./chain-query\");\nconst common_1 = require(\"@keplr-wallet/common\");\nconst mobx_1 = require(\"mobx\");\nconst unit_1 = require(\"@keplr-wallet/unit\");\nconst common_2 = require(\"../common\");\nconst mobx_utils_1 = require(\"mobx-utils\");\nclass ObservableQueryBalanceInner extends chain_query_1.ObservableChainQuery {\n  constructor(kvStore, chainId, chainGetter, url, denomHelper) {\n    super(kvStore, chainId, chainGetter, url);\n    this.denomHelper = denomHelper;\n    mobx_1.makeObservable(this);\n  }\n  get currency() {\n    const denom = this.denomHelper.denom;\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    const currency = chainInfo.findCurrency(denom);\n    // TODO: Infer the currency according to its denom (such if denom is `uatom` -> `Atom` with decimal 6)?\n    if (!currency) {\n      throw new Error(`Unknown currency: ${denom}`);\n    }\n    return currency;\n  }\n}\n__decorate([mobx_1.computed], ObservableQueryBalanceInner.prototype, \"currency\", null);\nexports.ObservableQueryBalanceInner = ObservableQueryBalanceInner;\nclass ObservableQueryBalancesInner {\n  constructor(kvStore, chainId, chainGetter, balanceRegistries, bech32Address) {\n    this.kvStore = kvStore;\n    this.chainId = chainId;\n    this.chainGetter = chainGetter;\n    this.balanceRegistries = balanceRegistries;\n    this.balanceMap = new Map();\n    this.getBalanceFromCurrency = mobx_utils_1.computedFn(currency => {\n      const bal = this.balances.find(bal => bal.currency.coinMinimalDenom === currency.coinMinimalDenom);\n      if (bal) {\n        return bal.balance;\n      }\n      return new unit_1.CoinPretty(currency, new unit_1.Int(0));\n    });\n    mobx_1.makeObservable(this);\n    this.bech32Address = bech32Address;\n  }\n  fetch() {\n    this.balanceMap.forEach(bal => bal.fetch());\n  }\n  getBalanceInner(currency) {\n    let key = currency.coinMinimalDenom;\n    // If the currency is secret20, it will be different according to not only the minimal denom but also the viewing key of the currency.\n    if (\"type\" in currency && currency.type === \"secret20\") {\n      key = currency.coinMinimalDenom + \"/\" + currency.viewingKey;\n    }\n    if (!this.balanceMap.has(key)) {\n      mobx_1.runInAction(() => {\n        let balanceInner;\n        for (const registry of this.balanceRegistries) {\n          balanceInner = registry.getBalanceInner(this.chainId, this.chainGetter, this.bech32Address, currency.coinMinimalDenom);\n          if (balanceInner) {\n            break;\n          }\n        }\n        if (balanceInner) {\n          this.balanceMap.set(key, balanceInner);\n        } else {\n          throw new Error(`Failed to get and parse the balance for ${key}`);\n        }\n      });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.balanceMap.get(key);\n  }\n  get stakable() {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    return this.getBalanceInner(chainInfo.stakeCurrency);\n  }\n  /**\n   * 알려진 모든 Currency들의 balance를 반환환다.\n   */\n  get balances() {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    const result = [];\n    for (let i = 0; i < chainInfo.currencies.length; i++) {\n      const currency = chainInfo.currencies[i];\n      result.push(this.getBalanceInner(currency));\n    }\n    return result;\n  }\n  /**\n   * 알려진 모든 Currency들 중 0 이상의 잔고를 가진 balance를 반환환다.\n   */\n  get positiveBalances() {\n    const balances = this.balances;\n    return balances.filter(bal => bal.balance.toDec().gt(new unit_1.Dec(0)));\n  }\n  /**\n   * Returns that the balances that are not native tokens.\n   * Native token means that the token that exists on the `bank` module.\n   */\n  get nonNativeBalances() {\n    const balances = this.balances;\n    return balances.filter(bal => new common_1.DenomHelper(bal.currency.coinMinimalDenom).type !== \"native\");\n  }\n  /**\n   * Returns that the balances that are native tokens with greater than 0 balance.\n   * Native token means that the token that exists on the `bank` module.\n   */\n  get positiveNativeUnstakables() {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    const balances = this.balances;\n    return balances.filter(bal => new common_1.DenomHelper(bal.currency.coinMinimalDenom).type === \"native\" && bal.balance.toDec().gt(new unit_1.Dec(0)) && bal.currency.coinMinimalDenom !== chainInfo.stakeCurrency.coinMinimalDenom);\n  }\n  get unstakables() {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    const currencies = chainInfo.currencies.filter(cur => cur.coinMinimalDenom !== chainInfo.stakeCurrency.coinMinimalDenom);\n    const result = [];\n    for (let i = 0; i < currencies.length; i++) {\n      const currency = currencies[i];\n      result.push(this.getBalanceInner(currency));\n    }\n    return result;\n  }\n}\n__decorate([mobx_1.observable.shallow], ObservableQueryBalancesInner.prototype, \"balanceMap\", void 0);\n__decorate([mobx_1.computed], ObservableQueryBalancesInner.prototype, \"stakable\", null);\n__decorate([mobx_1.computed], ObservableQueryBalancesInner.prototype, \"balances\", null);\n__decorate([mobx_1.computed], ObservableQueryBalancesInner.prototype, \"positiveBalances\", null);\n__decorate([mobx_1.computed], ObservableQueryBalancesInner.prototype, \"nonNativeBalances\", null);\n__decorate([mobx_1.computed], ObservableQueryBalancesInner.prototype, \"positiveNativeUnstakables\", null);\n__decorate([mobx_1.computed], ObservableQueryBalancesInner.prototype, \"unstakables\", null);\nexports.ObservableQueryBalancesInner = ObservableQueryBalancesInner;\nclass ObservableQueryBalances extends common_2.HasMapStore {\n  constructor(kvStore, chainId, chainGetter) {\n    super(bech32Address => {\n      return new ObservableQueryBalancesInner(this.kvStore, this.chainId, this.chainGetter, this.balanceRegistries, bech32Address);\n    });\n    this.kvStore = kvStore;\n    this.chainId = chainId;\n    this.chainGetter = chainGetter;\n    this.balanceRegistries = [];\n  }\n  addBalanceRegistry(registry) {\n    this.balanceRegistries.push(registry);\n  }\n  getQueryBech32Address(bech32Address) {\n    return this.get(bech32Address);\n  }\n}\nexports.ObservableQueryBalances = ObservableQueryBalances;","map":{"version":3,"mappings":"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","names":["ObservableQueryBalanceInner","chain_query_1","constructor","kvStore","chainId","chainGetter","url","denomHelper","mobx_1","currency","denom","chainInfo","getChain","findCurrency","Error","__decorate","exports","ObservableQueryBalancesInner","balanceRegistries","bech32Address","Map","mobx_utils_1","bal","balances","find","coinMinimalDenom","balance","unit_1","fetch","balanceMap","forEach","getBalanceInner","key","type","viewingKey","has","balanceInner","registry","set","get","stakable","stakeCurrency","result","i","currencies","length","push","positiveBalances","filter","toDec","gt","nonNativeBalances","common_1","positiveNativeUnstakables","unstakables","cur","shallow","ObservableQueryBalances","common_2","addBalanceRegistry","getQueryBech32Address"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/query/balances.ts"],"sourcesContent":["import { ObservableChainQuery } from \"./chain-query\";\nimport { DenomHelper, KVStore } from \"@keplr-wallet/common\";\nimport { ChainGetter } from \"../common\";\nimport { computed, makeObservable, observable, runInAction } from \"mobx\";\nimport { CoinPretty, Dec, Int } from \"@keplr-wallet/unit\";\nimport { AppCurrency } from \"@keplr-wallet/types\";\nimport { HasMapStore } from \"../common\";\nimport { computedFn } from \"mobx-utils\";\n\nexport abstract class ObservableQueryBalanceInner<\n  T = unknown,\n  E = unknown\n> extends ObservableChainQuery<T, E> {\n  protected constructor(\n    kvStore: KVStore,\n    chainId: string,\n    chainGetter: ChainGetter,\n    url: string,\n    protected readonly denomHelper: DenomHelper\n  ) {\n    super(kvStore, chainId, chainGetter, url);\n    makeObservable(this);\n  }\n\n  abstract get balance(): CoinPretty;\n\n  @computed\n  get currency(): AppCurrency {\n    const denom = this.denomHelper.denom;\n\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    const currency = chainInfo.findCurrency(denom);\n\n    // TODO: Infer the currency according to its denom (such if denom is `uatom` -> `Atom` with decimal 6)?\n    if (!currency) {\n      throw new Error(`Unknown currency: ${denom}`);\n    }\n\n    return currency;\n  }\n}\n\nexport interface BalanceRegistry {\n  getBalanceInner(\n    chainId: string,\n    chainGetter: ChainGetter,\n    bech32Address: string,\n    minimalDenom: string\n  ): ObservableQueryBalanceInner | undefined;\n}\n\nexport class ObservableQueryBalancesInner {\n  protected bech32Address: string;\n\n  @observable.shallow\n  protected balanceMap: Map<string, ObservableQueryBalanceInner> = new Map();\n\n  constructor(\n    protected readonly kvStore: KVStore,\n    protected readonly chainId: string,\n    protected readonly chainGetter: ChainGetter,\n    protected readonly balanceRegistries: BalanceRegistry[],\n    bech32Address: string\n  ) {\n    makeObservable(this);\n\n    this.bech32Address = bech32Address;\n  }\n\n  fetch() {\n    this.balanceMap.forEach((bal) => bal.fetch());\n  }\n\n  protected getBalanceInner(\n    currency: AppCurrency\n  ): ObservableQueryBalanceInner {\n    let key = currency.coinMinimalDenom;\n    // If the currency is secret20, it will be different according to not only the minimal denom but also the viewing key of the currency.\n    if (\"type\" in currency && currency.type === \"secret20\") {\n      key = currency.coinMinimalDenom + \"/\" + currency.viewingKey;\n    }\n\n    if (!this.balanceMap.has(key)) {\n      runInAction(() => {\n        let balanceInner: ObservableQueryBalanceInner | undefined;\n\n        for (const registry of this.balanceRegistries) {\n          balanceInner = registry.getBalanceInner(\n            this.chainId,\n            this.chainGetter,\n            this.bech32Address,\n            currency.coinMinimalDenom\n          );\n          if (balanceInner) {\n            break;\n          }\n        }\n\n        if (balanceInner) {\n          this.balanceMap.set(key, balanceInner);\n        } else {\n          throw new Error(`Failed to get and parse the balance for ${key}`);\n        }\n      });\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.balanceMap.get(key)!;\n  }\n\n  @computed\n  get stakable(): ObservableQueryBalanceInner {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n\n    return this.getBalanceInner(chainInfo.stakeCurrency);\n  }\n\n  /**\n   * 알려진 모든 Currency들의 balance를 반환환다.\n   */\n  @computed\n  get balances(): ObservableQueryBalanceInner[] {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n\n    const result = [];\n\n    for (let i = 0; i < chainInfo.currencies.length; i++) {\n      const currency = chainInfo.currencies[i];\n      result.push(this.getBalanceInner(currency));\n    }\n\n    return result;\n  }\n\n  /**\n   * 알려진 모든 Currency들 중 0 이상의 잔고를 가진 balance를 반환환다.\n   */\n  @computed\n  get positiveBalances(): ObservableQueryBalanceInner[] {\n    const balances = this.balances;\n    return balances.filter((bal) => bal.balance.toDec().gt(new Dec(0)));\n  }\n\n  /**\n   * Returns that the balances that are not native tokens.\n   * Native token means that the token that exists on the `bank` module.\n   */\n  @computed\n  get nonNativeBalances(): ObservableQueryBalanceInner[] {\n    const balances = this.balances;\n    return balances.filter(\n      (bal) => new DenomHelper(bal.currency.coinMinimalDenom).type !== \"native\"\n    );\n  }\n\n  /**\n   * Returns that the balances that are native tokens with greater than 0 balance.\n   * Native token means that the token that exists on the `bank` module.\n   */\n  @computed\n  get positiveNativeUnstakables(): ObservableQueryBalanceInner[] {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n\n    const balances = this.balances;\n    return balances.filter(\n      (bal) =>\n        new DenomHelper(bal.currency.coinMinimalDenom).type === \"native\" &&\n        bal.balance.toDec().gt(new Dec(0)) &&\n        bal.currency.coinMinimalDenom !==\n          chainInfo.stakeCurrency.coinMinimalDenom\n    );\n  }\n\n  @computed\n  get unstakables(): ObservableQueryBalanceInner[] {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n\n    const currencies = chainInfo.currencies.filter(\n      (cur) => cur.coinMinimalDenom !== chainInfo.stakeCurrency.coinMinimalDenom\n    );\n\n    const result = [];\n\n    for (let i = 0; i < currencies.length; i++) {\n      const currency = currencies[i];\n      result.push(this.getBalanceInner(currency));\n    }\n\n    return result;\n  }\n\n  readonly getBalanceFromCurrency = computedFn(\n    (currency: AppCurrency): CoinPretty => {\n      const bal = this.balances.find(\n        (bal) => bal.currency.coinMinimalDenom === currency.coinMinimalDenom\n      );\n      if (bal) {\n        return bal.balance;\n      }\n\n      return new CoinPretty(currency, new Int(0));\n    }\n  );\n}\n\nexport class ObservableQueryBalances extends HasMapStore<ObservableQueryBalancesInner> {\n  protected balanceRegistries: BalanceRegistry[] = [];\n\n  constructor(\n    protected readonly kvStore: KVStore,\n    protected readonly chainId: string,\n    protected readonly chainGetter: ChainGetter\n  ) {\n    super((bech32Address: string) => {\n      return new ObservableQueryBalancesInner(\n        this.kvStore,\n        this.chainId,\n        this.chainGetter,\n        this.balanceRegistries,\n        bech32Address\n      );\n    });\n  }\n\n  addBalanceRegistry(registry: BalanceRegistry) {\n    this.balanceRegistries.push(registry);\n  }\n\n  getQueryBech32Address(bech32Address: string): ObservableQueryBalancesInner {\n    return this.get(bech32Address) as ObservableQueryBalancesInner;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}