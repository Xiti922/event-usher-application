{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst encoding_1 = require(\"@iov/encoding\");\nconst fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\nconst types_1 = require(\"./types\");\nfunction encodeSecp256k1Pubkey(pubkey) {\n  if (pubkey.length !== 33 || pubkey[0] !== 0x02 && pubkey[0] !== 0x03) {\n    throw new Error(\"Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03\");\n  }\n  return {\n    type: types_1.pubkeyType.secp256k1,\n    value: encoding_1.Encoding.toBase64(pubkey)\n  };\n}\nexports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;\n// As discussed in https://github.com/binance-chain/javascript-sdk/issues/163\n// Prefixes listed here: https://github.com/tendermint/tendermint/blob/d419fffe18531317c28c29a292ad7d253f6cafdf/docs/spec/blockchain/encoding.md#public-key-cryptography\n// Last bytes is varint-encoded length prefix\nconst pubkeyAminoPrefixSecp256k1 = encoding_1.Encoding.fromHex(\"eb5ae98721\");\nconst pubkeyAminoPrefixEd25519 = encoding_1.Encoding.fromHex(\"1624de6420\");\nconst pubkeyAminoPrefixSr25519 = encoding_1.Encoding.fromHex(\"0dfb1005\");\nconst pubkeyAminoPrefixLength = pubkeyAminoPrefixSecp256k1.length;\nfunction decodeBech32Pubkey(bechEncoded) {\n  const {\n    data\n  } = encoding_1.Bech32.decode(bechEncoded);\n  const aminoPrefix = data.slice(0, pubkeyAminoPrefixLength);\n  const rest = data.slice(pubkeyAminoPrefixLength);\n  if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixSecp256k1)) {\n    if (rest.length !== 33) {\n      throw new Error(\"Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).\");\n    }\n    return {\n      type: types_1.pubkeyType.secp256k1,\n      value: encoding_1.Encoding.toBase64(rest)\n    };\n  } else if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixEd25519)) {\n    if (rest.length !== 32) {\n      throw new Error(\"Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).\");\n    }\n    return {\n      type: types_1.pubkeyType.ed25519,\n      value: encoding_1.Encoding.toBase64(rest)\n    };\n  } else if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixSr25519)) {\n    if (rest.length !== 32) {\n      throw new Error(\"Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).\");\n    }\n    return {\n      type: types_1.pubkeyType.sr25519,\n      value: encoding_1.Encoding.toBase64(rest)\n    };\n  } else {\n    throw new Error(\"Unsupported Pubkey type. Amino prefix: \" + encoding_1.Encoding.toHex(aminoPrefix));\n  }\n}\nexports.decodeBech32Pubkey = decodeBech32Pubkey;\nfunction encodeBech32Pubkey(pubkey, prefix) {\n  let aminoPrefix;\n  switch (pubkey.type) {\n    // Note: please don't add cases here without writing additional unit tests\n    case types_1.pubkeyType.secp256k1:\n      aminoPrefix = pubkeyAminoPrefixSecp256k1;\n      break;\n    default:\n      throw new Error(\"Unsupported pubkey type\");\n  }\n  const data = new Uint8Array([...aminoPrefix, ...encoding_1.Encoding.fromBase64(pubkey.value)]);\n  return encoding_1.Bech32.encode(prefix, data);\n}\nexports.encodeBech32Pubkey = encodeBech32Pubkey;","map":{"version":3,"mappings":";;;;;;;;;;AAAA;AACA;AAEA;AAEA,SAAgBA,qBAAqB,CAACC,MAAkB;EACtD,IAAIA,MAAM,CAACC,MAAM,KAAK,EAAE,IAAKD,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,MAAM,CAAC,CAAC,CAAC,KAAK,IAAK,EAAE;IACtE,MAAM,IAAIE,KAAK,CAAC,mFAAmF,CAAC;;EAEtG,OAAO;IACLC,IAAI,EAAEC,kBAAU,CAACC,SAAS;IAC1BC,KAAK,EAAEC,mBAAQ,CAACC,QAAQ,CAACR,MAAM;GAChC;AACH;AARAS;AAUA;AACA;AACA;AACA,MAAMC,0BAA0B,GAAGH,mBAAQ,CAACI,OAAO,CAAC,YAAY,CAAC;AACjE,MAAMC,wBAAwB,GAAGL,mBAAQ,CAACI,OAAO,CAAC,YAAY,CAAC;AAC/D,MAAME,wBAAwB,GAAGN,mBAAQ,CAACI,OAAO,CAAC,UAAU,CAAC;AAC7D,MAAMG,uBAAuB,GAAGJ,0BAA0B,CAACT,MAAM;AAEjE,SAAgBc,kBAAkB,CAACC,WAAmB;EACpD,MAAM;IAAEC;EAAI,CAAE,GAAGV,iBAAM,CAACW,MAAM,CAACF,WAAW,CAAC;EAE3C,MAAMG,WAAW,GAAGF,IAAI,CAACG,KAAK,CAAC,CAAC,EAAEN,uBAAuB,CAAC;EAC1D,MAAMO,IAAI,GAAGJ,IAAI,CAACG,KAAK,CAACN,uBAAuB,CAAC;EAChD,IAAIQ,yBAAK,CAACH,WAAW,EAAET,0BAA0B,CAAC,EAAE;IAClD,IAAIW,IAAI,CAACpB,MAAM,KAAK,EAAE,EAAE;MACtB,MAAM,IAAIC,KAAK,CAAC,4EAA4E,CAAC;;IAE/F,OAAO;MACLC,IAAI,EAAEC,kBAAU,CAACC,SAAS;MAC1BC,KAAK,EAAEC,mBAAQ,CAACC,QAAQ,CAACa,IAAI;KAC9B;GACF,MAAM,IAAIC,yBAAK,CAACH,WAAW,EAAEP,wBAAwB,CAAC,EAAE;IACvD,IAAIS,IAAI,CAACpB,MAAM,KAAK,EAAE,EAAE;MACtB,MAAM,IAAIC,KAAK,CAAC,+DAA+D,CAAC;;IAElF,OAAO;MACLC,IAAI,EAAEC,kBAAU,CAACmB,OAAO;MACxBjB,KAAK,EAAEC,mBAAQ,CAACC,QAAQ,CAACa,IAAI;KAC9B;GACF,MAAM,IAAIC,yBAAK,CAACH,WAAW,EAAEN,wBAAwB,CAAC,EAAE;IACvD,IAAIQ,IAAI,CAACpB,MAAM,KAAK,EAAE,EAAE;MACtB,MAAM,IAAIC,KAAK,CAAC,+DAA+D,CAAC;;IAElF,OAAO;MACLC,IAAI,EAAEC,kBAAU,CAACoB,OAAO;MACxBlB,KAAK,EAAEC,mBAAQ,CAACC,QAAQ,CAACa,IAAI;KAC9B;GACF,MAAM;IACL,MAAM,IAAInB,KAAK,CAAC,yCAAyC,GAAGK,mBAAQ,CAACkB,KAAK,CAACN,WAAW,CAAC,CAAC;;AAE5F;AAhCAV;AAkCA,SAAgBiB,kBAAkB,CAAC1B,MAAc,EAAE2B,MAAc;EAC/D,IAAIR,WAAuB;EAC3B,QAAQnB,MAAM,CAACG,IAAI;IACjB;IACA,KAAKC,kBAAU,CAACC,SAAS;MACvBc,WAAW,GAAGT,0BAA0B;MACxC;IACF;MACE,MAAM,IAAIR,KAAK,CAAC,yBAAyB,CAAC;EAAC;EAG/C,MAAMe,IAAI,GAAG,IAAIW,UAAU,CAAC,CAAC,GAAGT,WAAW,EAAE,GAAGZ,mBAAQ,CAACsB,UAAU,CAAC7B,MAAM,CAACM,KAAK,CAAC,CAAC,CAAC;EACnF,OAAOC,iBAAM,CAACuB,MAAM,CAACH,MAAM,EAAEV,IAAI,CAAC;AACpC;AAbAR","names":["encodeSecp256k1Pubkey","pubkey","length","Error","type","types_1","secp256k1","value","encoding_1","toBase64","exports","pubkeyAminoPrefixSecp256k1","fromHex","pubkeyAminoPrefixEd25519","pubkeyAminoPrefixSr25519","pubkeyAminoPrefixLength","decodeBech32Pubkey","bechEncoded","data","decode","aminoPrefix","slice","rest","fast_deep_equal_1","ed25519","sr25519","toHex","encodeBech32Pubkey","prefix","Uint8Array","fromBase64","encode"],"sources":["../src/pubkey.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}