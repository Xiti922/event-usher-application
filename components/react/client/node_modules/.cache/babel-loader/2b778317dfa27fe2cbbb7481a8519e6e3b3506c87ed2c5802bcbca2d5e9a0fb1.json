{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokensService = void 0;\nconst router_1 = require(\"@keplr-wallet/router\");\nconst chains_1 = require(\"../chains\");\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nconst keyring_1 = require(\"../keyring\");\nconst buffer_1 = require(\"buffer/\");\nconst messages_1 = require(\"./messages\");\nconst types_1 = require(\"./types\");\nclass TokensService {\n  constructor(kvStore) {\n    this.kvStore = kvStore;\n    this.onChainRemoved = chainId => {\n      this.clearTokens(chainId);\n    };\n  }\n  init(interactionService, permissionService, chainsService, keyRingService) {\n    this.interactionService = interactionService;\n    this.permissionService = permissionService;\n    this.chainsService = chainsService;\n    this.keyRingService = keyRingService;\n    this.chainsService.addChainRemovedHandler(this.onChainRemoved);\n  }\n  suggestToken(env, chainId, contractAddress, viewingKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainInfo = yield this.chainsService.getChainInfo(chainId);\n      const find = (yield this.getTokens(chainId)).find(currency => \"contractAddress\" in currency && currency.contractAddress === contractAddress);\n      // If the same currency is already registered, do nothing.\n      if (find) {\n        // If the secret20 token,\n        // just try to change the viewing key.\n        if (viewingKey) {\n          if (\"type\" in find && find.type === \"secret20\") {\n            yield this.addToken(chainId, Object.assign(Object.assign({}, find), {\n              viewingKey\n            }));\n          }\n          return;\n        }\n        return;\n      }\n      // Validate the contract address.\n      cosmos_1.Bech32Address.validate(contractAddress, chainInfo.bech32Config.bech32PrefixAccAddr);\n      const params = {\n        chainId,\n        contractAddress,\n        viewingKey\n      };\n      const appCurrency = yield this.interactionService.waitApprove(env, \"/setting/token/add\", messages_1.SuggestTokenMsg.type(), params);\n      yield this.addToken(chainId, appCurrency);\n    });\n  }\n  addToken(chainId, currency) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainInfo = yield this.chainsService.getChainInfo(chainId);\n      currency = yield TokensService.validateCurrency(chainInfo, currency);\n      const chainCurrencies = yield this.getTokens(chainId);\n      const isTokenForAccount = \"type\" in currency && currency.type === \"secret20\";\n      let isCurrencyUpdated = false;\n      for (const chainCurrency of chainCurrencies) {\n        if (currency.coinMinimalDenom === chainCurrency.coinMinimalDenom) {\n          if (!isTokenForAccount) {\n            // If currency is already registered, do nothing.\n            return;\n          }\n          isCurrencyUpdated = true;\n        }\n      }\n      if (!isTokenForAccount) {\n        const currencies = yield this.getTokensFromChain(chainId);\n        currencies.push(currency);\n        yield this.saveTokensToChain(chainId, currencies);\n      } else {\n        const currencies = yield this.getTokensFromChainAndAccount(chainId);\n        if (!isCurrencyUpdated) {\n          currencies.push(currency);\n          yield this.saveTokensToChainAndAccount(chainId, currencies);\n        } else {\n          const index = currencies.findIndex(cur => cur.coinMinimalDenom === currency.coinMinimalDenom);\n          if (index >= 0) {\n            currencies[index] = currency;\n            yield this.saveTokensToChainAndAccount(chainId, currencies);\n          }\n        }\n      }\n    });\n  }\n  removeToken(chainId, currency) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainInfo = yield this.chainsService.getChainInfo(chainId);\n      currency = yield TokensService.validateCurrency(chainInfo, currency);\n      const chainCurrencies = yield this.getTokens(chainId);\n      const isTokenForAccount = \"type\" in currency && currency.type === \"secret20\";\n      let isFoundCurrency = false;\n      for (const chainCurrency of chainCurrencies) {\n        if (currency.coinMinimalDenom === chainCurrency.coinMinimalDenom) {\n          isFoundCurrency = true;\n          break;\n        }\n      }\n      if (!isFoundCurrency) {\n        return;\n      }\n      if (!isTokenForAccount) {\n        const currencies = (yield this.getTokensFromChain(chainId)).filter(cur => cur.coinMinimalDenom !== currency.coinMinimalDenom);\n        yield this.saveTokensToChain(chainId, currencies);\n      } else {\n        const currencies = (yield this.getTokensFromChainAndAccount(chainId)).filter(cur => cur.coinMinimalDenom !== currency.coinMinimalDenom);\n        yield this.saveTokensToChainAndAccount(chainId, currencies);\n      }\n    });\n  }\n  getTokens(chainId) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);\n      const chainCurrencies = (_a = yield this.kvStore.get(chainIdHelper.identifier)) !== null && _a !== void 0 ? _a : [];\n      let keyCurrencies = [];\n      if (this.keyRingService.keyRingStatus === keyring_1.KeyRingStatus.UNLOCKED) {\n        const currentKey = yield this.keyRingService.getKey(chainId);\n        keyCurrencies = (_b = yield this.kvStore.get(`${chainIdHelper.identifier}-${buffer_1.Buffer.from(currentKey.address).toString(\"hex\")}`)) !== null && _b !== void 0 ? _b : [];\n      }\n      return chainCurrencies.concat(keyCurrencies);\n    });\n  }\n  clearTokens(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);\n      yield this.kvStore.set(chainIdHelper.identifier, null);\n      const reverse = yield this.getTokensToAccountReverse(chainId);\n      for (const hexAddress of reverse) {\n        yield this.kvStore.set(`${chainIdHelper.identifier}-${hexAddress}`, null);\n      }\n      yield this.setTokensToAccountReverse(chainId, []);\n    });\n  }\n  getTokensFromChain(chainId) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);\n      return (_a = yield this.kvStore.get(chainIdHelper.identifier)) !== null && _a !== void 0 ? _a : [];\n    });\n  }\n  saveTokensToChain(chainId, currencies) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);\n      yield this.kvStore.set(chainIdHelper.identifier, currencies);\n    });\n  }\n  getTokensFromChainAndAccount(chainId) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);\n      const currentKey = yield this.keyRingService.getKey(chainId);\n      return (_a = yield this.kvStore.get(`${chainIdHelper.identifier}-${buffer_1.Buffer.from(currentKey.address).toString(\"hex\")}`)) !== null && _a !== void 0 ? _a : [];\n    });\n  }\n  saveTokensToChainAndAccount(chainId, currencies) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);\n      const currentKey = yield this.keyRingService.getKey(chainId);\n      const hexAddress = buffer_1.Buffer.from(currentKey.address).toString(\"hex\");\n      yield this.kvStore.set(`${chainIdHelper.identifier}-${hexAddress}`, currencies);\n      yield this.insertTokensToAccountReverse(chainId, hexAddress);\n    });\n  }\n  getTokensToAccountReverse(chainId) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);\n      return (_a = yield this.kvStore.get(`${chainIdHelper.identifier}-addresses`)) !== null && _a !== void 0 ? _a : [];\n    });\n  }\n  setTokensToAccountReverse(chainId, addresses) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);\n      yield this.kvStore.set(`${chainIdHelper.identifier}-addresses`, addresses);\n    });\n  }\n  insertTokensToAccountReverse(chainId, address) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const reverse = yield this.getTokensToAccountReverse(chainId);\n      if (reverse.indexOf(address) < 0) {\n        reverse.push(address);\n        yield this.setTokensToAccountReverse(chainId, reverse);\n      }\n    });\n  }\n  getSecret20ViewingKey(chainId, contractAddress) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const tokens = yield this.getTokens(chainId);\n      for (const currency of tokens) {\n        if (\"type\" in currency && currency.type === \"secret20\") {\n          if (currency.contractAddress === contractAddress) {\n            return currency.viewingKey;\n          }\n        }\n      }\n      throw new router_1.KeplrError(\"tokens\", 111, \"There is no matched secret20\");\n    });\n  }\n  checkOrGrantSecret20ViewingKeyPermission(env, chainId, contractAddress, origin) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Ensure that the secret20 was registered.\n      yield this.getSecret20ViewingKey(chainId, contractAddress);\n      const type = types_1.getSecret20ViewingKeyPermissionType(contractAddress);\n      if (!this.permissionService.hasPermisson(chainId, type, origin)) {\n        yield this.permissionService.grantPermission(env, \"/access/viewing-key\", [chainId], type, [origin]);\n      }\n      this.permissionService.checkPermission(env, chainId, type, origin);\n    });\n  }\n  static validateCurrency(chainInfo, currency) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Validate the schema.\n      if (\"type\" in currency) {\n        switch (currency.type) {\n          case \"cw20\":\n            currency = yield TokensService.validateCW20Currency(chainInfo, currency);\n            break;\n          case \"secret20\":\n            currency = yield TokensService.validateSecret20Currency(chainInfo, currency);\n            break;\n          default:\n            throw new router_1.KeplrError(\"tokens\", 110, \"Unknown type of currency\");\n        }\n      } else {\n        currency = yield chains_1.CurrencySchema.validateAsync(currency);\n      }\n      return currency;\n    });\n  }\n  static validateCW20Currency(chainInfo, currency) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Validate the schema.\n      currency = yield chains_1.CW20CurrencySchema.validateAsync(currency);\n      // Validate the contract address.\n      cosmos_1.Bech32Address.validate(currency.contractAddress, chainInfo.bech32Config.bech32PrefixAccAddr);\n      return currency;\n    });\n  }\n  static validateSecret20Currency(chainInfo, currency) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Validate the schema.\n      currency = yield chains_1.Secret20CurrencySchema.validateAsync(currency);\n      // Validate the contract address.\n      cosmos_1.Bech32Address.validate(currency.contractAddress, chainInfo.bech32Config.bech32PrefixAccAddr);\n      return currency;\n    });\n  }\n}\nexports.TokensService = TokensService;","map":{"version":3,"mappings":"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","names":["TokensService","constructor","kvStore","chainId","clearTokens","init","interactionService","permissionService","chainsService","keyRingService","addChainRemovedHandler","onChainRemoved","suggestToken","env","contractAddress","viewingKey","chainInfo","getChainInfo","find","getTokens","currency","type","addToken","cosmos_1","validate","bech32Config","bech32PrefixAccAddr","params","appCurrency","waitApprove","messages_1","validateCurrency","chainCurrencies","isTokenForAccount","isCurrencyUpdated","chainCurrency","coinMinimalDenom","currencies","getTokensFromChain","push","saveTokensToChain","getTokensFromChainAndAccount","saveTokensToChainAndAccount","index","findIndex","cur","removeToken","isFoundCurrency","filter","chainIdHelper","parse","get","identifier","keyCurrencies","keyRingStatus","keyring_1","UNLOCKED","currentKey","getKey","buffer_1","from","address","toString","concat","set","reverse","getTokensToAccountReverse","hexAddress","setTokensToAccountReverse","insertTokensToAccountReverse","addresses","indexOf","getSecret20ViewingKey","tokens","router_1","checkOrGrantSecret20ViewingKeyPermission","origin","types_1","hasPermisson","grantPermission","checkPermission","validateCW20Currency","validateSecret20Currency","chains_1","validateAsync","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/background/src/tokens/service.ts"],"sourcesContent":["import { Env, KeplrError } from \"@keplr-wallet/router\";\nimport {\n  ChainInfo,\n  AppCurrency,\n  CW20Currency,\n  Secret20Currency,\n} from \"@keplr-wallet/types\";\nimport {\n  CurrencySchema,\n  CW20CurrencySchema,\n  Secret20CurrencySchema,\n} from \"../chains\";\nimport { Bech32Address, ChainIdHelper } from \"@keplr-wallet/cosmos\";\nimport { ChainsService } from \"../chains\";\nimport { KeyRingService } from \"../keyring\";\nimport { KVStore } from \"@keplr-wallet/common\";\nimport { KeyRingStatus } from \"../keyring\";\nimport { InteractionService } from \"../interaction\";\nimport { PermissionService } from \"../permission\";\n\nimport { Buffer } from \"buffer/\";\nimport { SuggestTokenMsg } from \"./messages\";\nimport { getSecret20ViewingKeyPermissionType } from \"./types\";\n\nexport class TokensService {\n  protected interactionService!: InteractionService;\n  public permissionService!: PermissionService;\n  protected chainsService!: ChainsService;\n  protected keyRingService!: KeyRingService;\n\n  constructor(protected readonly kvStore: KVStore) {}\n\n  init(\n    interactionService: InteractionService,\n    permissionService: PermissionService,\n    chainsService: ChainsService,\n    keyRingService: KeyRingService\n  ) {\n    this.interactionService = interactionService;\n    this.permissionService = permissionService;\n    this.chainsService = chainsService;\n    this.keyRingService = keyRingService;\n\n    this.chainsService.addChainRemovedHandler(this.onChainRemoved);\n  }\n\n  protected readonly onChainRemoved = (chainId: string) => {\n    this.clearTokens(chainId);\n  };\n\n  async suggestToken(\n    env: Env,\n    chainId: string,\n    contractAddress: string,\n    viewingKey?: string\n  ) {\n    const chainInfo = await this.chainsService.getChainInfo(chainId);\n\n    const find = (await this.getTokens(chainId)).find(\n      (currency) =>\n        \"contractAddress\" in currency &&\n        currency.contractAddress === contractAddress\n    );\n    // If the same currency is already registered, do nothing.\n    if (find) {\n      // If the secret20 token,\n      // just try to change the viewing key.\n      if (viewingKey) {\n        if (\"type\" in find && find.type === \"secret20\") {\n          await this.addToken(chainId, {\n            ...find,\n            viewingKey,\n          });\n        }\n        return;\n      }\n      return;\n    }\n\n    // Validate the contract address.\n    Bech32Address.validate(\n      contractAddress,\n      chainInfo.bech32Config.bech32PrefixAccAddr\n    );\n\n    const params = {\n      chainId,\n      contractAddress,\n      viewingKey,\n    };\n\n    const appCurrency = await this.interactionService.waitApprove(\n      env,\n      \"/setting/token/add\",\n      SuggestTokenMsg.type(),\n      params\n    );\n\n    await this.addToken(chainId, appCurrency as AppCurrency);\n  }\n\n  async addToken(chainId: string, currency: AppCurrency) {\n    const chainInfo = await this.chainsService.getChainInfo(chainId);\n\n    currency = await TokensService.validateCurrency(chainInfo, currency);\n\n    const chainCurrencies = await this.getTokens(chainId);\n\n    const isTokenForAccount =\n      \"type\" in currency && currency.type === \"secret20\";\n    let isCurrencyUpdated = false;\n\n    for (const chainCurrency of chainCurrencies) {\n      if (currency.coinMinimalDenom === chainCurrency.coinMinimalDenom) {\n        if (!isTokenForAccount) {\n          // If currency is already registered, do nothing.\n          return;\n        }\n\n        isCurrencyUpdated = true;\n      }\n    }\n\n    if (!isTokenForAccount) {\n      const currencies = await this.getTokensFromChain(chainId);\n      currencies.push(currency);\n      await this.saveTokensToChain(chainId, currencies);\n    } else {\n      const currencies = await this.getTokensFromChainAndAccount(chainId);\n      if (!isCurrencyUpdated) {\n        currencies.push(currency);\n        await this.saveTokensToChainAndAccount(chainId, currencies);\n      } else {\n        const index = currencies.findIndex(\n          (cur) => cur.coinMinimalDenom === currency.coinMinimalDenom\n        );\n        if (index >= 0) {\n          currencies[index] = currency;\n          await this.saveTokensToChainAndAccount(chainId, currencies);\n        }\n      }\n    }\n  }\n\n  async removeToken(chainId: string, currency: AppCurrency) {\n    const chainInfo = await this.chainsService.getChainInfo(chainId);\n\n    currency = await TokensService.validateCurrency(chainInfo, currency);\n\n    const chainCurrencies = await this.getTokens(chainId);\n\n    const isTokenForAccount =\n      \"type\" in currency && currency.type === \"secret20\";\n    let isFoundCurrency = false;\n\n    for (const chainCurrency of chainCurrencies) {\n      if (currency.coinMinimalDenom === chainCurrency.coinMinimalDenom) {\n        isFoundCurrency = true;\n        break;\n      }\n    }\n\n    if (!isFoundCurrency) {\n      return;\n    }\n\n    if (!isTokenForAccount) {\n      const currencies = (await this.getTokensFromChain(chainId)).filter(\n        (cur) => cur.coinMinimalDenom !== currency.coinMinimalDenom\n      );\n      await this.saveTokensToChain(chainId, currencies);\n    } else {\n      const currencies = (\n        await this.getTokensFromChainAndAccount(chainId)\n      ).filter((cur) => cur.coinMinimalDenom !== currency.coinMinimalDenom);\n      await this.saveTokensToChainAndAccount(chainId, currencies);\n    }\n  }\n\n  public async getTokens(chainId: string): Promise<AppCurrency[]> {\n    const chainIdHelper = ChainIdHelper.parse(chainId);\n\n    const chainCurrencies =\n      (await this.kvStore.get<AppCurrency[]>(chainIdHelper.identifier)) ?? [];\n\n    let keyCurrencies: AppCurrency[] = [];\n    if (this.keyRingService.keyRingStatus === KeyRingStatus.UNLOCKED) {\n      const currentKey = await this.keyRingService.getKey(chainId);\n\n      keyCurrencies =\n        (await this.kvStore.get<AppCurrency[]>(\n          `${chainIdHelper.identifier}-${Buffer.from(\n            currentKey.address\n          ).toString(\"hex\")}`\n        )) ?? [];\n    }\n\n    return chainCurrencies.concat(keyCurrencies);\n  }\n\n  public async clearTokens(chainId: string): Promise<void> {\n    const chainIdHelper = ChainIdHelper.parse(chainId);\n\n    await this.kvStore.set(chainIdHelper.identifier, null);\n\n    const reverse = await this.getTokensToAccountReverse(chainId);\n    for (const hexAddress of reverse) {\n      await this.kvStore.set(`${chainIdHelper.identifier}-${hexAddress}`, null);\n    }\n    await this.setTokensToAccountReverse(chainId, []);\n  }\n\n  private async getTokensFromChain(chainId: string): Promise<AppCurrency[]> {\n    const chainIdHelper = ChainIdHelper.parse(chainId);\n\n    return (\n      (await this.kvStore.get<AppCurrency[]>(chainIdHelper.identifier)) ?? []\n    );\n  }\n\n  private async saveTokensToChain(chainId: string, currencies: AppCurrency[]) {\n    const chainIdHelper = ChainIdHelper.parse(chainId);\n\n    await this.kvStore.set(chainIdHelper.identifier, currencies);\n  }\n\n  private async getTokensFromChainAndAccount(\n    chainId: string\n  ): Promise<AppCurrency[]> {\n    const chainIdHelper = ChainIdHelper.parse(chainId);\n\n    const currentKey = await this.keyRingService.getKey(chainId);\n    return (\n      (await this.kvStore.get<Promise<AppCurrency[]>>(\n        `${chainIdHelper.identifier}-${Buffer.from(currentKey.address).toString(\n          \"hex\"\n        )}`\n      )) ?? []\n    );\n  }\n\n  private async saveTokensToChainAndAccount(\n    chainId: string,\n    currencies: AppCurrency[]\n  ) {\n    const chainIdHelper = ChainIdHelper.parse(chainId);\n\n    const currentKey = await this.keyRingService.getKey(chainId);\n    const hexAddress = Buffer.from(currentKey.address).toString(\"hex\");\n    await this.kvStore.set(\n      `${chainIdHelper.identifier}-${hexAddress}`,\n      currencies\n    );\n\n    await this.insertTokensToAccountReverse(chainId, hexAddress);\n  }\n\n  private async getTokensToAccountReverse(chainId: string): Promise<string[]> {\n    const chainIdHelper = ChainIdHelper.parse(chainId);\n\n    return (\n      (await this.kvStore.get(`${chainIdHelper.identifier}-addresses`)) ?? []\n    );\n  }\n\n  private async setTokensToAccountReverse(\n    chainId: string,\n    addresses: string[]\n  ) {\n    const chainIdHelper = ChainIdHelper.parse(chainId);\n\n    await this.kvStore.set(`${chainIdHelper.identifier}-addresses`, addresses);\n  }\n\n  private async insertTokensToAccountReverse(chainId: string, address: string) {\n    const reverse = await this.getTokensToAccountReverse(chainId);\n    if (reverse.indexOf(address) < 0) {\n      reverse.push(address);\n      await this.setTokensToAccountReverse(chainId, reverse);\n    }\n  }\n\n  async getSecret20ViewingKey(\n    chainId: string,\n    contractAddress: string\n  ): Promise<string> {\n    const tokens = await this.getTokens(chainId);\n\n    for (const currency of tokens) {\n      if (\"type\" in currency && currency.type === \"secret20\") {\n        if (currency.contractAddress === contractAddress) {\n          return currency.viewingKey;\n        }\n      }\n    }\n\n    throw new KeplrError(\"tokens\", 111, \"There is no matched secret20\");\n  }\n\n  async checkOrGrantSecret20ViewingKeyPermission(\n    env: Env,\n    chainId: string,\n    contractAddress: string,\n    origin: string\n  ) {\n    // Ensure that the secret20 was registered.\n    await this.getSecret20ViewingKey(chainId, contractAddress);\n\n    const type = getSecret20ViewingKeyPermissionType(contractAddress);\n\n    if (!this.permissionService.hasPermisson(chainId, type, origin)) {\n      await this.permissionService.grantPermission(\n        env,\n        \"/access/viewing-key\",\n        [chainId],\n        type,\n        [origin]\n      );\n    }\n\n    this.permissionService.checkPermission(env, chainId, type, origin);\n  }\n\n  static async validateCurrency(\n    chainInfo: ChainInfo,\n    currency: AppCurrency\n  ): Promise<AppCurrency> {\n    // Validate the schema.\n    if (\"type\" in currency) {\n      switch (currency.type) {\n        case \"cw20\":\n          currency = await TokensService.validateCW20Currency(\n            chainInfo,\n            currency\n          );\n          break;\n        case \"secret20\":\n          currency = await TokensService.validateSecret20Currency(\n            chainInfo,\n            currency\n          );\n          break;\n        default:\n          throw new KeplrError(\"tokens\", 110, \"Unknown type of currency\");\n      }\n    } else {\n      currency = await CurrencySchema.validateAsync(currency);\n    }\n\n    return currency;\n  }\n\n  static async validateCW20Currency(\n    chainInfo: ChainInfo,\n    currency: CW20Currency\n  ): Promise<CW20Currency> {\n    // Validate the schema.\n    currency = await CW20CurrencySchema.validateAsync(currency);\n\n    // Validate the contract address.\n    Bech32Address.validate(\n      currency.contractAddress,\n      chainInfo.bech32Config.bech32PrefixAccAddr\n    );\n\n    return currency;\n  }\n\n  static async validateSecret20Currency(\n    chainInfo: ChainInfo,\n    currency: Secret20Currency\n  ): Promise<Secret20Currency> {\n    // Validate the schema.\n    currency = await Secret20CurrencySchema.validateAsync(currency);\n\n    // Validate the contract address.\n    Bech32Address.validate(\n      currency.contractAddress,\n      chainInfo.bech32Config.bech32PrefixAccAddr\n    );\n\n    return currency;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}