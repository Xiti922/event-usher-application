{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst crypto_1 = require(\"@iov/crypto\");\nconst encoding_1 = require(\"./encoding\");\nconst signature_1 = require(\"./signature\");\n/**\n * Serach for sequence s with `min` <= `s` < `upperBound` to find the sequence that was used to sign the transaction\n *\n * @param tx The signed transaction\n * @param chainId The chain ID for which this transaction was signed\n * @param accountNumber The account number for which this transaction was signed\n * @param upperBound The upper bound for the testing, i.e. sequence must be lower than this value\n * @param min The lowest sequence that is tested\n *\n * @returns the sequence if a match was found and undefined otherwise\n */\nasync function findSequenceForSignedTx(tx, chainId, accountNumber, upperBound) {\n  let min = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  const firstSignature = tx.value.signatures.find(() => true);\n  if (!firstSignature) throw new Error(\"Signature missing in tx\");\n  const {\n    pubkey,\n    signature\n  } = signature_1.decodeSignature(firstSignature);\n  const secp256keSignature = crypto_1.Secp256k1Signature.fromFixedLength(signature);\n  for (let s = min; s < upperBound; s++) {\n    // console.log(`Trying sequence ${s}`);\n    const signBytes = encoding_1.makeSignBytes(tx.value.msg, tx.value.fee, chainId, tx.value.memo || \"\", accountNumber, s);\n    const prehashed = new crypto_1.Sha256(signBytes).digest();\n    const valid = await crypto_1.Secp256k1.verifySignature(secp256keSignature, prehashed, pubkey);\n    if (valid) return s;\n  }\n  return undefined;\n}\nexports.findSequenceForSignedTx = findSequenceForSignedTx;","map":{"version":3,"mappings":";;;;;AAAA;AAEA;AACA;AAGA;;;;;;;;;;;AAWO,eAAeA,uBAAuB,CAC3CC,EAAe,EACfC,OAAe,EACfC,aAAqB,EACrBC,UAAkB,EACX;EAAA,IAAPC,GAAG,uEAAG,CAAC;EAEP,MAAMC,cAAc,GAAGL,EAAE,CAACM,KAAK,CAACC,UAAU,CAACC,IAAI,CAAC,MAAM,IAAI,CAAC;EAC3D,IAAI,CAACH,cAAc,EAAE,MAAM,IAAII,KAAK,CAAC,yBAAyB,CAAC;EAE/D,MAAM;IAAEC,MAAM;IAAEC;EAAS,CAAE,GAAGC,2BAAe,CAACP,cAAc,CAAC;EAC7D,MAAMQ,kBAAkB,GAAGC,2BAAkB,CAACC,eAAe,CAACJ,SAAS,CAAC;EAExE,KAAK,IAAIK,CAAC,GAAGZ,GAAG,EAAEY,CAAC,GAAGb,UAAU,EAAEa,CAAC,EAAE,EAAE;IACrC;IACA,MAAMC,SAAS,GAAGC,wBAAa,CAC7BlB,EAAE,CAACM,KAAK,CAACa,GAAG,EACZnB,EAAE,CAACM,KAAK,CAACc,GAAG,EACZnB,OAAO,EACPD,EAAE,CAACM,KAAK,CAACe,IAAI,IAAI,EAAE,EACnBnB,aAAa,EACbc,CAAC,CACF;IACD,MAAMM,SAAS,GAAG,IAAIR,eAAM,CAACG,SAAS,CAAC,CAACM,MAAM,EAAE;IAChD,MAAMC,KAAK,GAAG,MAAMV,kBAAS,CAACW,eAAe,CAACZ,kBAAkB,EAAES,SAAS,EAAEZ,MAAM,CAAC;IACpF,IAAIc,KAAK,EAAE,OAAOR,CAAC;;EAErB,OAAOU,SAAS;AAClB;AA5BAC","names":["findSequenceForSignedTx","tx","chainId","accountNumber","upperBound","min","firstSignature","value","signatures","find","Error","pubkey","signature","signature_1","secp256keSignature","crypto_1","fromFixedLength","s","signBytes","encoding_1","msg","fee","memo","prehashed","digest","valid","verifySignature","undefined","exports"],"sources":["../src/sequence.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}