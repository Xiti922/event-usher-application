"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableQueryMap = exports.ObservableQuery = exports.ObservableQueryBase = exports.DeferInitialQueryController = exports.defaultOptions = void 0;
const mobx_1 = require("mobx");
const axios_1 = __importDefault(require("axios"));
const common_1 = require("@keplr-wallet/common");
const map_1 = require("../map");
const eventemitter3_1 = __importDefault(require("eventemitter3"));
exports.defaultOptions = {
    cacheMaxAge: 0,
    fetchingInterval: 0,
};
class FlowCancelerError extends Error {
    constructor(m) {
        super(m);
        // Set the prototype explicitly.
        Object.setPrototypeOf(this, FlowCancelerError.prototype);
    }
}
class FlowCanceler {
    constructor() {
        this.rejectors = [];
    }
    get hasCancelable() {
        return this.rejectors.length > 0;
    }
    cancel(message) {
        while (this.rejectors.length > 0) {
            const rejector = this.rejectors.shift();
            if (rejector) {
                rejector.reject(new FlowCancelerError(message));
                if (rejector.onCancel) {
                    rejector.onCancel();
                }
            }
        }
    }
    callOrCanceledWithPromise(promise, onCancel) {
        return new Promise((resolve, reject) => {
            this.rejectors.push({
                reject,
                onCancel,
            });
            promise.then((r) => {
                const i = this.rejectors.findIndex((r) => r.reject === reject);
                if (i >= 0) {
                    this.rejectors.splice(i, 1);
                }
                resolve(r);
            }, (e) => {
                const i = this.rejectors.findIndex((r) => r.reject === reject);
                if (i >= 0) {
                    this.rejectors.splice(i, 1);
                }
                reject(e);
            });
        });
    }
    callOrCanceled(fn, onCancel) {
        return new Promise((resolve, reject) => {
            this.rejectors.push({
                reject,
                onCancel,
            });
            Promise.resolve().then(() => {
                if (!this.rejectors.find((r) => r.reject === reject)) {
                    return;
                }
                fn().then((r) => {
                    const i = this.rejectors.findIndex((r) => r.reject === reject);
                    if (i >= 0) {
                        this.rejectors.splice(i, 1);
                    }
                    resolve(r);
                }, (e) => {
                    const i = this.rejectors.findIndex((r) => r.reject === reject);
                    if (i >= 0) {
                        this.rejectors.splice(i, 1);
                    }
                    reject(e);
                });
            });
        });
    }
}
class DeferInitialQueryController {
    constructor() {
        this._isReady = false;
        mobx_1.makeObservable(this);
    }
    ready() {
        this._isReady = true;
    }
    wait() {
        if (this.isReady) {
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            const disposer = mobx_1.autorun(() => {
                if (this.isReady) {
                    resolve();
                    if (disposer) {
                        disposer();
                    }
                }
            });
        });
    }
    get isReady() {
        return this._isReady;
    }
}
__decorate([
    mobx_1.observable
], DeferInitialQueryController.prototype, "_isReady", void 0);
__decorate([
    mobx_1.action
], DeferInitialQueryController.prototype, "ready", null);
exports.DeferInitialQueryController = DeferInitialQueryController;
/**
 * Base of the observable query classes.
 * This recommends to use the Axios to query the response.
 */
class ObservableQueryBase {
    constructor(instance, options) {
        // Just use the oberable ref because the response is immutable and not directly adjusted.
        this._response = undefined;
        this._isFetching = false;
        this._error = undefined;
        this._isStarted = false;
        this._pendingOnStart = false;
        this.observedCount = 0;
        // intervalId can be number or NodeJS's Timout object according to the environment.
        // If environment is browser, intervalId should be number.
        // If environment is NodeJS, intervalId should be NodeJS.Timeout.
        this.intervalId = undefined;
        this.becomeObserved = () => {
            if (this.observedCount === 0) {
                this.start();
            }
            this.observedCount++;
        };
        this.becomeUnobserved = () => {
            this.observedCount--;
            if (this.observedCount === 0) {
                this.stop();
            }
        };
        this.intervalFetch = () => {
            if (!this.isFetching) {
                this.fetch();
            }
        };
        this.options = Object.assign(Object.assign({}, exports.defaultOptions), options);
        this._instance = instance;
        this.queryCanceler = new FlowCanceler();
        this.onStartCanceler = new FlowCanceler();
        this.queryControllerConceler = new FlowCanceler();
        mobx_1.makeObservable(this);
        mobx_1.onBecomeObserved(this, "_response", this.becomeObserved);
        mobx_1.onBecomeObserved(this, "_isFetching", this.becomeObserved);
        mobx_1.onBecomeObserved(this, "_error", this.becomeObserved);
        mobx_1.onBecomeUnobserved(this, "_response", this.becomeUnobserved);
        mobx_1.onBecomeUnobserved(this, "_isFetching", this.becomeUnobserved);
        mobx_1.onBecomeUnobserved(this, "_error", this.becomeUnobserved);
    }
    static guessResponseTruncated(headers, data) {
        return (headers &&
            typeof headers["content-type"] === "string" &&
            headers["content-type"].startsWith("application/json") &&
            data.startsWith("{"));
    }
    get isObserved() {
        return this.observedCount > 0;
    }
    start() {
        if (!this._isStarted) {
            this._isStarted = true;
            const promise = this.onStart();
            if (promise) {
                this.handleAsyncOnStart(promise);
            }
            else {
                this.postStart();
            }
        }
    }
    *handleAsyncOnStart(promise) {
        this._pendingOnStart = true;
        this._isFetching = true;
        try {
            yield this.onStartCanceler.callOrCanceledWithPromise(promise);
            if (this._isStarted) {
                this._pendingOnStart = false;
                this.postStart();
            }
        }
        catch (e) {
            if (e instanceof FlowCancelerError) {
                return;
            }
            throw e;
        }
    }
    stop() {
        if (this._isStarted) {
            if (this.onStartCanceler.hasCancelable) {
                this.onStartCanceler.cancel();
            }
            if (this.isFetching && this.queryCanceler.hasCancelable) {
                this.cancel();
            }
            this._pendingOnStart = false;
            this._isFetching = false;
            if (this.intervalId != null) {
                clearInterval(this.intervalId);
            }
            this.intervalId = undefined;
            this.onStop();
            this._isStarted = false;
        }
    }
    get isStarted() {
        return this._isStarted;
    }
    postStart() {
        this.fetch();
        if (this.options.fetchingInterval > 0) {
            this.intervalId = setInterval(this.intervalFetch, this.options.fetchingInterval);
        }
    }
    onStart() {
        // noop yet.
        // Override this if you need something to do whenever starting.
    }
    onStop() {
        // noop yet.
        // Override this if you need something to do whenever starting.
    }
    canFetch() {
        return true;
    }
    get isFetching() {
        return this._isFetching;
    }
    // Return the instance.
    // You can memorize this by using @computed if you need to override this.
    // NOTE: If this getter returns the different instance with previous instance.
    // It will be used in the latter fetching.
    get instance() {
        return this._instance;
    }
    *fetch() {
        var _a, _b, _c;
        // If not started, do nothing.
        if (!this.isStarted || this._pendingOnStart) {
            return;
        }
        if (ObservableQueryBase.experimentalDeferInitialQueryController &&
            !ObservableQueryBase.experimentalDeferInitialQueryController.isReady) {
            this._isFetching = true;
            if (this.queryControllerConceler.hasCancelable) {
                this.queryControllerConceler.cancel();
            }
            try {
                yield this.queryControllerConceler.callOrCanceled(() => { var _a, _b; return (_b = (_a = ObservableQueryBase.experimentalDeferInitialQueryController) === null || _a === void 0 ? void 0 : _a.wait()) !== null && _b !== void 0 ? _b : Promise.resolve(); });
            }
            catch (e) {
                if (e instanceof FlowCancelerError) {
                    return;
                }
                throw e;
            }
            // Recheck
            if (!this.isStarted) {
                return;
            }
        }
        if (!this.canFetch()) {
            return;
        }
        // If response is fetching, cancel the previous query.
        if (this.isFetching && this.queryCanceler.hasCancelable) {
            // When cancel for the next fetching, it behaves differently from other explicit cancels because fetching continues. Use an error message to identify this.
            this.cancel("__fetching__proceed__next__");
        }
        // If there is no existing response, try to load saved reponse.
        if (!this._response) {
            this._isFetching = true;
            const promise = this.loadStaledResponse();
            const handleStaledResponse = (staledResponse) => {
                if (staledResponse && !this._response) {
                    if (this.options.cacheMaxAge <= 0 ||
                        staledResponse.timestamp > Date.now() - this.options.cacheMaxAge) {
                        this.setResponse(staledResponse);
                        return true;
                    }
                }
                return false;
            };
            // When first load, try to load the last response from disk.
            // Use the last saved response if the last saved response exists and the current response hasn't been set yet.
            if (this.options.cacheMaxAge <= 0) {
                // To improve performance, don't wait the loading to proceed if cache age not set.
                promise.then((staledResponse) => {
                    handleStaledResponse(staledResponse);
                });
            }
            else {
                const staledResponse = yield* common_1.toGenerator(promise);
                if (handleStaledResponse(staledResponse)) {
                    this._isFetching = false;
                    return;
                }
            }
        }
        else {
            if (this.options.cacheMaxAge > 0) {
                if (this._response.timestamp > Date.now() - this.options.cacheMaxAge) {
                    this._isFetching = false;
                    return;
                }
            }
            this._isFetching = true;
            // Make the existing response as staled.
            this.setResponse(Object.assign(Object.assign({}, this._response), { staled: true }));
        }
        const abortController = new AbortController();
        let fetchingProceedNext = false;
        let skipAxiosCancelError = false;
        try {
            let hasStarted = false;
            let { response, headers } = yield* common_1.toGenerator(this.queryCanceler.callOrCanceled(() => {
                hasStarted = true;
                return this.fetchResponse(abortController);
            }, () => {
                if (hasStarted) {
                    abortController.abort();
                }
            }));
            if (response.data &&
                typeof response.data === "string" &&
                (response.data.startsWith("stream was reset:") ||
                    ObservableQuery.suspectedResponseDatasWithInvalidValue.includes(response.data) ||
                    ObservableQuery.guessResponseTruncated(headers, response.data))) {
                // In some devices, it is a http ok code, but a strange response is sometimes returned.
                // It's not that they can't query at all, it seems that they get weird response from time to time.
                // These causes are not clear.
                // To solve this problem, if this problem occurs, try the query again, and if that fails, an error is raised.
                // https://github.com/chainapsis/keplr-wallet/issues/275
                // https://github.com/chainapsis/keplr-wallet/issues/278
                // https://github.com/chainapsis/keplr-wallet/issues/318
                if (abortController.signal.aborted) {
                    // In this case, it is assumed that it is caused by cancel() and do nothing.
                    return;
                }
                console.log("There is an unknown problem to the response. Request one more time.");
                // Try to query again.
                let hasStarted = false;
                const refetched = yield* common_1.toGenerator(this.queryCanceler.callOrCanceled(() => {
                    hasStarted = true;
                    return this.fetchResponse(abortController);
                }, () => {
                    if (hasStarted) {
                        abortController.abort();
                    }
                }));
                response = refetched.response;
                headers = refetched.headers;
                if (response.data && typeof response.data === "string") {
                    if (response.data.startsWith("stream was reset:") ||
                        ObservableQuery.suspectedResponseDatasWithInvalidValue.includes(response.data)) {
                        throw new Error(response.data);
                    }
                    if (ObservableQuery.guessResponseTruncated(headers, response.data)) {
                        throw new Error("The response data seems to be truncated");
                    }
                }
            }
            this.setResponse(response);
            // Clear the error if fetching succeeds.
            this.setError(undefined);
            // Should not wait.
            this.saveResponse(response);
        }
        catch (e) {
            // If axios canceled, do nothing.
            if (axios_1.default.isCancel(e)) {
                skipAxiosCancelError = true;
                return;
            }
            if (e instanceof FlowCancelerError) {
                // When cancel for the next fetching, it behaves differently from other explicit cancels because fetching continues.
                if (e.message === "__fetching__proceed__next__") {
                    fetchingProceedNext = true;
                }
                return;
            }
            // If error is from Axios, and get response.
            if (e.response) {
                // Default is status text
                let message = e.response.statusText;
                const contentType = typeof ((_a = e.response.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) === "string"
                    ? e.response.headers["content-type"]
                    : "";
                // Try to figure out the message from the response.
                // If the contentType in the header is specified, try to use the message from the response.
                if (contentType.startsWith("text/plain") &&
                    typeof e.response.data === "string") {
                    message = e.response.data;
                }
                // If the response is an object and "message" field exists, it is used as a message.
                if (contentType.startsWith("application/json") && ((_b = e.response.data) === null || _b === void 0 ? void 0 : _b.message) &&
                    typeof ((_c = e.response.data) === null || _c === void 0 ? void 0 : _c.message) === "string") {
                    message = e.response.data.message;
                }
                const error = {
                    status: e.response.status,
                    statusText: e.response.statusText,
                    message,
                    data: e.response.data,
                };
                this.setError(error);
            }
            else if (e.request) {
                // if can't get the response.
                const error = {
                    status: 0,
                    statusText: "Failed to get response",
                    message: "Failed to get response",
                };
                this.setError(error);
            }
            else {
                const error = {
                    status: 0,
                    statusText: e.message,
                    message: e.message,
                    data: e,
                };
                this.setError(error);
            }
        }
        finally {
            if (!skipAxiosCancelError) {
                if (!fetchingProceedNext) {
                    this._isFetching = false;
                }
            }
        }
    }
    get response() {
        return this._response;
    }
    get error() {
        return this._error;
    }
    setResponse(response) {
        this._response = response;
    }
    setError(error) {
        this._error = error;
    }
    cancel(message) {
        this.queryCanceler.cancel(message);
    }
    /**
     * Wait the response and return the response without considering it is staled or fresh.
     */
    waitResponse() {
        if (this.response) {
            return Promise.resolve(this.response);
        }
        const disposers = [];
        let onceCoerce = false;
        // Make sure that the fetching is tracked to force to be fetched.
        disposers.push(mobx_1.reaction(() => this.isFetching, () => {
            if (!onceCoerce) {
                if (!this.isFetching) {
                    this.fetch();
                }
                onceCoerce = true;
            }
        }, {
            fireImmediately: true,
        }));
        return new Promise((resolve) => {
            const disposer = mobx_1.autorun(() => {
                if (!this.isFetching) {
                    resolve(this.response);
                }
            });
            disposers.push(disposer);
        }).finally(() => {
            for (const disposer of disposers) {
                disposer();
            }
        });
    }
    /**
     * Wait the response and return the response until it is fetched.
     */
    waitFreshResponse() {
        const disposers = [];
        let onceCoerce = false;
        // Make sure that the fetching is tracked to force to be fetched.
        disposers.push(mobx_1.reaction(() => this.isFetching, () => {
            if (!onceCoerce) {
                if (!this.isFetching) {
                    this.fetch();
                }
                onceCoerce = true;
            }
        }, {
            fireImmediately: true,
        }));
        return new Promise((resolve) => {
            const disposer = mobx_1.autorun(() => {
                if (!this.isFetching) {
                    resolve(this.response);
                }
            });
            disposers.push(disposer);
        }).finally(() => {
            for (const disposer of disposers) {
                disposer();
            }
        });
    }
}
/**
 * Allows to decide when to start the first query.
 *
 * This is a temporarily added feature to implement custom rpc/lcd feature in keplr extension or mobile.
 * Because custom rpc/lcd are handled in the background process and the front-end cannot synchronously get those values,
 * Rather than not showing the UI to the user during the delay, the UI is shown and the start of the query is delayed immediately after getting those values.
 *
 * XXX: Having a global field for this feature doesn't seem desirable in the long run.
 *      Unless it's a keplr extension or mobile, you don't need to care about this field.
 *      This field will soon be removed and can be replaced by other implementation.
 *
 */
ObservableQueryBase.experimentalDeferInitialQueryController = undefined;
ObservableQueryBase.suspectedResponseDatasWithInvalidValue = [
    "The network connection was lost.",
    "The request timed out.",
];
__decorate([
    mobx_1.observable.ref
], ObservableQueryBase.prototype, "_response", void 0);
__decorate([
    mobx_1.observable
], ObservableQueryBase.prototype, "_isFetching", void 0);
__decorate([
    mobx_1.observable.ref
], ObservableQueryBase.prototype, "_error", void 0);
__decorate([
    mobx_1.observable
], ObservableQueryBase.prototype, "_isStarted", void 0);
__decorate([
    mobx_1.observable.ref
], ObservableQueryBase.prototype, "_instance", void 0);
__decorate([
    mobx_1.action
], ObservableQueryBase.prototype, "start", null);
__decorate([
    mobx_1.flow
], ObservableQueryBase.prototype, "handleAsyncOnStart", null);
__decorate([
    mobx_1.action
], ObservableQueryBase.prototype, "stop", null);
__decorate([
    mobx_1.computed
], ObservableQueryBase.prototype, "instance", null);
__decorate([
    mobx_1.flow
], ObservableQueryBase.prototype, "fetch", null);
__decorate([
    mobx_1.action
], ObservableQueryBase.prototype, "setResponse", null);
__decorate([
    mobx_1.action
], ObservableQueryBase.prototype, "setError", null);
exports.ObservableQueryBase = ObservableQueryBase;
/**
 * ObservableQuery defines the event class to query the result from endpoint.
 * This supports the stale state if previous query exists.
 */
class ObservableQuery extends ObservableQueryBase {
    constructor(kvStore, instance, url, options = {}) {
        super(instance, options);
        this.kvStore = kvStore;
        this._url = "";
        this.refreshHandler = (data) => {
            const ifError = data === null || data === void 0 ? void 0 : data.ifError;
            if (ifError) {
                if (this.error) {
                    this.fetch();
                }
            }
            else {
                this.fetch();
            }
        };
        mobx_1.makeObservable(this);
        this.setUrl(url);
    }
    static refreshAllObserved() {
        ObservableQuery.eventListener.emit("refresh");
    }
    static refreshAllObservedIfError() {
        ObservableQuery.eventListener.emit("refresh", {
            ifError: true,
        });
    }
    onStart() {
        super.onStart();
        ObservableQuery.eventListener.addListener("refresh", this.refreshHandler);
    }
    onStop() {
        super.onStop();
        ObservableQuery.eventListener.addListener("refresh", this.refreshHandler);
    }
    get url() {
        return this._url;
    }
    setUrl(url) {
        if (this._url !== url) {
            this._url = url;
            this.fetch();
        }
    }
    fetchResponse(abortController) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.instance.get(this.url, {
                signal: abortController.signal,
            });
            return {
                headers: result.headers,
                response: {
                    data: result.data,
                    status: result.status,
                    staled: false,
                    timestamp: Date.now(),
                },
            };
        });
    }
    getCacheKey() {
        return `${this.instance.name}-${this.instance.defaults.baseURL}${this.instance.getUri({
            url: this.url,
        })}`;
    }
    saveResponse(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = this.getCacheKey();
            yield this.kvStore.set(key, response);
        });
    }
    loadStaledResponse() {
        return __awaiter(this, void 0, void 0, function* () {
            const key = this.getCacheKey();
            const response = yield this.kvStore.get(key);
            if (response) {
                return Object.assign(Object.assign({}, response), { staled: true });
            }
            return undefined;
        });
    }
}
ObservableQuery.eventListener = new eventemitter3_1.default();
__decorate([
    mobx_1.observable
], ObservableQuery.prototype, "_url", void 0);
__decorate([
    mobx_1.action
], ObservableQuery.prototype, "setUrl", null);
exports.ObservableQuery = ObservableQuery;
class ObservableQueryMap extends map_1.HasMapStore {
    constructor(creater) {
        super(creater);
    }
}
exports.ObservableQueryMap = ObservableQueryMap;
//# sourceMappingURL=query.js.map