{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CosmosAccountImpl = exports.defaultCosmosMsgOpts = exports.CosmosAccount = void 0;\nconst base_1 = require(\"./base\");\nconst launchpad_1 = require(\"@cosmjs/launchpad\");\nconst common_1 = require(\"@keplr-wallet/common\");\nconst unit_1 = require(\"@keplr-wallet/unit\");\nconst tx_1 = require(\"@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx\");\nconst signing_1 = require(\"@keplr-wallet/proto-types/cosmos/tx/signing/v1beta1/signing\");\nconst keys_1 = require(\"@keplr-wallet/proto-types/cosmos/crypto/secp256k1/keys\");\nconst tx_2 = require(\"@keplr-wallet/proto-types/cosmos/bank/v1beta1/tx\");\nconst tx_3 = require(\"@keplr-wallet/proto-types/ibc/applications/transfer/v1/tx\");\nconst tx_4 = require(\"@keplr-wallet/proto-types/cosmos/staking/v1beta1/tx\");\nconst tx_5 = require(\"@keplr-wallet/proto-types/cosmos/distribution/v1beta1/tx\");\nconst tx_6 = require(\"@keplr-wallet/proto-types/cosmos/gov/v1beta1/tx\");\nconst gov_1 = require(\"@keplr-wallet/proto-types/cosmos/gov/v1beta1/gov\");\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nconst types_1 = require(\"../query/cosmos/staking/types\");\nconst axios_1 = __importDefault(require(\"axios\"));\nconst deepmerge_1 = __importDefault(require(\"deepmerge\"));\nconst address_1 = require(\"@ethersproject/address\");\nconst buffer_1 = require(\"buffer/\");\nconst utils_1 = require(\"./utils\");\nexports.CosmosAccount = {\n  use(options) {\n    return (base, chainGetter, chainId) => {\n      const msgOptsFromCreator = options.msgOptsCreator ? options.msgOptsCreator(chainId) : undefined;\n      return {\n        cosmos: new CosmosAccountImpl(base, chainGetter, chainId, options.queriesStore, deepmerge_1.default(exports.defaultCosmosMsgOpts, msgOptsFromCreator ? msgOptsFromCreator : {}), options)\n      };\n    };\n  }\n};\n/**\n * @deprecated Predict gas through simulation rather than using a fixed gas.\n */\nexports.defaultCosmosMsgOpts = {\n  send: {\n    native: {\n      type: \"cosmos-sdk/MsgSend\",\n      gas: 80000\n    }\n  },\n  ibcTransfer: {\n    type: \"cosmos-sdk/MsgTransfer\",\n    gas: 450000\n  },\n  delegate: {\n    type: \"cosmos-sdk/MsgDelegate\",\n    gas: 250000\n  },\n  undelegate: {\n    type: \"cosmos-sdk/MsgUndelegate\",\n    gas: 250000\n  },\n  redelegate: {\n    type: \"cosmos-sdk/MsgBeginRedelegate\",\n    gas: 250000\n  },\n  // The gas multiplication per rewards.\n  withdrawRewards: {\n    type: \"cosmos-sdk/MsgWithdrawDelegationReward\",\n    gas: 140000\n  },\n  govVote: {\n    type: \"cosmos-sdk/MsgVote\",\n    gas: 250000\n  }\n};\nclass CosmosAccountImpl {\n  constructor(base, chainGetter, chainId, queriesStore, _msgOpts, txOpts) {\n    this.base = base;\n    this.chainGetter = chainGetter;\n    this.chainId = chainId;\n    this.queriesStore = queriesStore;\n    this._msgOpts = _msgOpts;\n    this.txOpts = txOpts;\n    this.broadcastMode = \"sync\";\n    this.base.registerMakeSendTokenFn(this.processMakeSendTokenTx.bind(this));\n    this.base.registerSendTokenFn(this.processSendToken.bind(this));\n  }\n  /**\n   * @deprecated Predict gas through simulation rather than using a fixed gas.\n   */\n  get msgOpts() {\n    return this._msgOpts;\n  }\n  processMakeSendTokenTx(amount, currency, recipient) {\n    const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);\n    const hexAdjustedRecipient = recipient => {\n      const bech32prefix = this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr;\n      if (this.hasEthereumAddress && recipient.startsWith(\"0x\")) {\n        // Validate hex address\n        if (!address_1.isAddress(recipient)) {\n          throw new Error(\"Invalid hex address\");\n        }\n        const buf = buffer_1.Buffer.from(recipient.replace(\"0x\", \"\").toLowerCase(), \"hex\");\n        return new cosmos_1.Bech32Address(buf).toBech32(bech32prefix);\n      }\n      return recipient;\n    };\n    if (denomHelper.type === \"native\") {\n      const actualAmount = (() => {\n        let dec = new unit_1.Dec(amount);\n        dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n        return dec.truncate().toString();\n      })();\n      recipient = hexAdjustedRecipient(recipient);\n      cosmos_1.Bech32Address.validate(recipient, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr);\n      const msg = {\n        type: this.msgOpts.send.native.type,\n        value: {\n          from_address: this.base.bech32Address,\n          to_address: recipient,\n          amount: [{\n            denom: currency.coinMinimalDenom,\n            amount: actualAmount\n          }]\n        }\n      };\n      return this.makeTx(\"send\", {\n        aminoMsgs: [msg],\n        protoMsgs: [{\n          typeUrl: \"/cosmos.bank.v1beta1.MsgSend\",\n          value: tx_2.MsgSend.encode({\n            fromAddress: msg.value.from_address,\n            toAddress: msg.value.to_address,\n            amount: msg.value.amount\n          }).finish()\n        }]\n      }, tx => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to send token, refresh the balance.\n          const queryBalance = this.queries.queryBalances.getQueryBech32Address(this.base.bech32Address).balances.find(bal => {\n            return bal.currency.coinMinimalDenom === currency.coinMinimalDenom;\n          });\n          if (queryBalance) {\n            queryBalance.fetch();\n          }\n        }\n      });\n    }\n  }\n  /**\n   * @deprecated\n   */\n  processSendToken(amount, currency, recipient, memo, stdFee, signOptions, onTxEvents) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);\n      const hexAdjustedRecipient = recipient => {\n        const bech32prefix = this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr;\n        if (this.hasEthereumAddress && recipient.startsWith(\"0x\")) {\n          // Validate hex address\n          if (!address_1.isAddress(recipient)) {\n            throw new Error(\"Invalid hex address\");\n          }\n          const buf = buffer_1.Buffer.from(recipient.replace(\"0x\", \"\").toLowerCase(), \"hex\");\n          return new cosmos_1.Bech32Address(buf).toBech32(bech32prefix);\n        }\n        return recipient;\n      };\n      switch (denomHelper.type) {\n        case \"native\":\n          const actualAmount = (() => {\n            let dec = new unit_1.Dec(amount);\n            dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n            return dec.truncate().toString();\n          })();\n          const msg = {\n            type: this.msgOpts.send.native.type,\n            value: {\n              from_address: this.base.bech32Address,\n              to_address: hexAdjustedRecipient(recipient),\n              amount: [{\n                denom: currency.coinMinimalDenom,\n                amount: actualAmount\n              }]\n            }\n          };\n          yield this.sendMsgs(\"send\", {\n            aminoMsgs: [msg],\n            protoMsgs: [{\n              typeUrl: \"/cosmos.bank.v1beta1.MsgSend\",\n              value: tx_2.MsgSend.encode({\n                fromAddress: msg.value.from_address,\n                toAddress: msg.value.to_address,\n                amount: msg.value.amount\n              }).finish()\n            }]\n          }, memo, {\n            amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],\n            gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.send.native.gas.toString()\n          }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, tx => {\n            if (tx.code == null || tx.code === 0) {\n              // After succeeding to send token, refresh the balance.\n              const queryBalance = this.queries.queryBalances.getQueryBech32Address(this.base.bech32Address).balances.find(bal => {\n                return bal.currency.coinMinimalDenom === currency.coinMinimalDenom;\n              });\n              if (queryBalance) {\n                queryBalance.fetch();\n              }\n            }\n          }));\n          return true;\n      }\n      return false;\n    });\n  }\n  sendMsgs(type, msgs) {\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    let fee = arguments.length > 3 ? arguments[3] : undefined;\n    let signOptions = arguments.length > 4 ? arguments[4] : undefined;\n    let onTxEvents = arguments.length > 5 ? arguments[5] : undefined;\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      this.base.setTxTypeInProgress(type);\n      let txHash;\n      let signDoc;\n      try {\n        if (typeof msgs === \"function\") {\n          msgs = yield msgs();\n        }\n        const result = yield this.broadcastMsgs(msgs, fee, memo, signOptions, this.broadcastMode);\n        txHash = result.txHash;\n        signDoc = result.signDoc;\n      } catch (e) {\n        this.base.setTxTypeInProgress(\"\");\n        if ((_a = this.txOpts.preTxEvents) === null || _a === void 0 ? void 0 : _a.onBroadcastFailed) {\n          this.txOpts.preTxEvents.onBroadcastFailed(this.chainId, e);\n        }\n        if (onTxEvents && \"onBroadcastFailed\" in onTxEvents && onTxEvents.onBroadcastFailed) {\n          onTxEvents.onBroadcastFailed(e);\n        }\n        throw e;\n      }\n      let onBroadcasted;\n      let onFulfill;\n      if (onTxEvents) {\n        if (typeof onTxEvents === \"function\") {\n          onFulfill = onTxEvents;\n        } else {\n          onBroadcasted = onTxEvents.onBroadcasted;\n          onFulfill = onTxEvents.onFulfill;\n        }\n      }\n      if ((_b = this.txOpts.preTxEvents) === null || _b === void 0 ? void 0 : _b.onBroadcasted) {\n        this.txOpts.preTxEvents.onBroadcasted(this.chainId, txHash);\n      }\n      if (onBroadcasted) {\n        onBroadcasted(txHash);\n      }\n      const txTracer = new cosmos_1.TendermintTxTracer(this.chainGetter.getChain(this.chainId).rpc, \"/websocket\", {\n        wsObject: this.txOpts.wsObject\n      });\n      txTracer.traceTx(txHash).then(tx => {\n        var _a;\n        txTracer.close();\n        this.base.setTxTypeInProgress(\"\");\n        // After sending tx, the balances is probably changed due to the fee.\n        for (const feeAmount of signDoc.fee.amount) {\n          const bal = this.queries.queryBalances.getQueryBech32Address(this.base.bech32Address).balances.find(bal => bal.currency.coinMinimalDenom === feeAmount.denom);\n          if (bal) {\n            bal.fetch();\n          }\n        }\n        // Always add the tx hash data.\n        if (tx && !tx.hash) {\n          tx.hash = buffer_1.Buffer.from(txHash).toString(\"hex\");\n        }\n        if ((_a = this.txOpts.preTxEvents) === null || _a === void 0 ? void 0 : _a.onFulfill) {\n          this.txOpts.preTxEvents.onFulfill(this.chainId, tx);\n        }\n        if (onFulfill) {\n          onFulfill(tx);\n        }\n      });\n    });\n  }\n  // Return the tx hash.\n  broadcastMsgs(msgs, fee) {\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    let signOptions = arguments.length > 3 ? arguments[3] : undefined;\n    let mode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"async\";\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.base.walletStatus !== base_1.WalletStatus.Loaded) {\n        throw new Error(`Wallet is not loaded: ${this.base.walletStatus}`);\n      }\n      const aminoMsgs = msgs.aminoMsgs;\n      const protoMsgs = msgs.protoMsgs;\n      // TODO: Make proto sign doc if `aminoMsgs` is empty or null\n      if (aminoMsgs.length === 0 || protoMsgs.length === 0) {\n        throw new Error(\"There is no msg to send\");\n      }\n      if (aminoMsgs.length !== protoMsgs.length) {\n        throw new Error(\"The length of aminoMsgs and protoMsgs are different\");\n      }\n      const account = yield cosmos_1.BaseAccount.fetchFromRest(this.instance, this.base.bech32Address, true);\n      const useEthereumSign = (_a = this.chainGetter.getChain(this.chainId).features) === null || _a === void 0 ? void 0 : _a.includes(\"eth-key-sign\");\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const keplr = yield this.base.getKeplr();\n      const signDoc = launchpad_1.makeSignDoc(aminoMsgs, fee, this.chainId, common_1.escapeHTML(memo), account.getAccountNumber().toString(), account.getSequence().toString());\n      const signResponse = yield keplr.signAmino(this.chainId, this.base.bech32Address, signDoc, signOptions);\n      const signedTx = tx_1.TxRaw.encode({\n        bodyBytes: tx_1.TxBody.encode(tx_1.TxBody.fromPartial({\n          messages: protoMsgs,\n          memo: signResponse.signed.memo\n        })).finish(),\n        authInfoBytes: tx_1.AuthInfo.encode({\n          signerInfos: [{\n            publicKey: {\n              typeUrl: (() => {\n                if (!useEthereumSign) {\n                  return \"/cosmos.crypto.secp256k1.PubKey\";\n                }\n                if (this.chainId.startsWith(\"injective\")) {\n                  return \"/injective.crypto.v1beta1.ethsecp256k1.PubKey\";\n                }\n                return \"/ethermint.crypto.v1.ethsecp256k1.PubKey\";\n              })(),\n              value: keys_1.PubKey.encode({\n                key: buffer_1.Buffer.from(signResponse.signature.pub_key.value, \"base64\")\n              }).finish()\n            },\n            modeInfo: {\n              single: {\n                mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON\n              },\n              multi: undefined\n            },\n            sequence: signResponse.signed.sequence\n          }],\n          fee: tx_1.Fee.fromPartial({\n            amount: signResponse.signed.fee.amount,\n            gasLimit: signResponse.signed.fee.gas\n          })\n        }).finish(),\n        signatures: [buffer_1.Buffer.from(signResponse.signature.signature, \"base64\")]\n      }).finish();\n      return {\n        txHash: yield keplr.sendTx(this.chainId, signedTx, mode),\n        signDoc: signResponse.signed\n      };\n    });\n  }\n  /**\n   * Simulate tx without making state transition on chain or not waiting the tx committed.\n   * Mainly used to estimate the gas needed to process tx.\n   * You should multiply arbitrary number (gas adjustment) for gas before sending tx.\n   *\n   * NOTE: \"/cosmos/tx/v1beta1/simulate\" returns 400, 500 or (more?) status and error code as a response when tx fails on stimulate.\n   *       Currently, non 200~300 status is handled as error, thus error would be thrown.\n   *\n   * XXX: Uses the simulate request format for cosmos-sdk@0.43+\n   *      Thus, may throw an error if the chain is below cosmos-sdk@0.43\n   *      And, for simplicity, doesn't set the public key to tx bytes.\n   *      Thus, the gas estimated doesn't include the tx bytes size of public key.\n   *\n   * @param msgs\n   * @param fee\n   * @param memo\n   */\n  simulateTx(msgs, fee) {\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    return __awaiter(this, void 0, void 0, function* () {\n      const account = yield cosmos_1.BaseAccount.fetchFromRest(this.instance, this.base.bech32Address, true);\n      const unsignedTx = tx_1.TxRaw.encode({\n        bodyBytes: tx_1.TxBody.encode(tx_1.TxBody.fromPartial({\n          messages: msgs,\n          memo: memo\n        })).finish(),\n        authInfoBytes: tx_1.AuthInfo.encode({\n          signerInfos: [tx_1.SignerInfo.fromPartial({\n            // Pub key is ignored.\n            // It is fine to ignore the pub key when simulating tx.\n            // However, the estimated gas would be slightly smaller because tx size doesn't include pub key.\n            modeInfo: {\n              single: {\n                mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON\n              },\n              multi: undefined\n            },\n            sequence: account.getSequence().toString()\n          })],\n          fee: tx_1.Fee.fromPartial({\n            amount: fee.amount.map(amount => {\n              return {\n                amount: amount.amount,\n                denom: amount.denom\n              };\n            })\n          })\n        }).finish(),\n        // Because of the validation of tx itself, the signature must exist.\n        // However, since they do not actually verify the signature, it is okay to use any value.\n        signatures: [new Uint8Array(64)]\n      }).finish();\n      const result = yield this.instance.post(\"/cosmos/tx/v1beta1/simulate\", {\n        tx_bytes: buffer_1.Buffer.from(unsignedTx).toString(\"base64\")\n      });\n      const gasUsed = parseInt(result.data.gas_info.gas_used);\n      if (Number.isNaN(gasUsed)) {\n        throw new Error(`Invalid integer gas: ${result.data.gas_info.gas_used}`);\n      }\n      return {\n        gasUsed\n      };\n    });\n  }\n  makeTx(type, msgs, preOnTxEvents) {\n    var _this = this;\n    const simulate = function () {\n      let fee = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      let memo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n      return __awaiter(_this, void 0, void 0, function* () {\n        var _a;\n        if (typeof msgs === \"function\") {\n          msgs = yield msgs();\n        }\n        return this.simulateTx(msgs.protoMsgs, {\n          amount: (_a = fee.amount) !== null && _a !== void 0 ? _a : []\n        }, memo);\n      });\n    };\n    const sendWithGasPrice = function (gasInfo) {\n      let memo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n      let signOptions = arguments.length > 2 ? arguments[2] : undefined;\n      let onTxEvents = arguments.length > 3 ? arguments[3] : undefined;\n      return __awaiter(_this, void 0, void 0, function* () {\n        if (gasInfo.gas < 0) {\n          throw new Error(\"Gas is zero or negative\");\n        }\n        const fee = {\n          gas: gasInfo.gas.toString(),\n          amount: gasInfo.gasPrice ? [{\n            denom: gasInfo.gasPrice.denom,\n            amount: gasInfo.gasPrice.amount.mul(new unit_1.Dec(gasInfo.gas)).truncate().toString()\n          }] : []\n        };\n        return this.sendMsgs(type, msgs, memo, fee, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, preOnTxEvents));\n      });\n    };\n    return {\n      msgs: () => __awaiter(this, void 0, void 0, function* () {\n        if (typeof msgs === \"function\") {\n          msgs = yield msgs();\n        }\n        return msgs;\n      }),\n      simulate,\n      simulateAndSend: function (feeOptions) {\n        let memo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n        let signOptions = arguments.length > 2 ? arguments[2] : undefined;\n        let onTxEvents = arguments.length > 3 ? arguments[3] : undefined;\n        return __awaiter(_this, void 0, void 0, function* () {\n          this.base.setTxTypeInProgress(type);\n          try {\n            const {\n              gasUsed\n            } = yield simulate({}, memo);\n            if (gasUsed < 0) {\n              throw new Error(\"Gas estimated is zero or negative\");\n            }\n            const gasAdjusted = feeOptions.gasAdjustment * gasUsed;\n            return sendWithGasPrice({\n              gas: gasAdjusted,\n              gasPrice: feeOptions.gasPrice\n            }, memo, signOptions, onTxEvents);\n          } catch (e) {\n            this.base.setTxTypeInProgress(\"\");\n            throw e;\n          }\n        });\n      },\n      send: function (fee) {\n        let memo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n        let signOptions = arguments.length > 2 ? arguments[2] : undefined;\n        let onTxEvents = arguments.length > 3 ? arguments[3] : undefined;\n        return __awaiter(_this, void 0, void 0, function* () {\n          return this.sendMsgs(type, msgs, memo, fee, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, preOnTxEvents));\n        });\n      },\n      sendWithGasPrice\n    };\n  }\n  get instance() {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    return axios_1.default.create(Object.assign({\n      baseURL: chainInfo.rest\n    }, chainInfo.restConfig));\n  }\n  makeIBCTransferTx(channel, amount, currency, recipient) {\n    if (new common_1.DenomHelper(currency.coinMinimalDenom).type !== \"native\") {\n      throw new Error(\"Only native token can be sent via IBC\");\n    }\n    const actualAmount = (() => {\n      let dec = new unit_1.Dec(amount);\n      dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n      return dec.truncate().toString();\n    })();\n    const destinationInfo = this.queriesStore.get(channel.counterpartyChainId).cosmos.queryRPCStatus;\n    return this.makeTx(\"ibcTransfer\", () => __awaiter(this, void 0, void 0, function* () {\n      // Wait until fetching complete.\n      yield destinationInfo.waitFreshResponse();\n      if (!destinationInfo.network) {\n        throw new Error(`Failed to fetch the network chain id of ${channel.counterpartyChainId}`);\n      }\n      if (cosmos_1.ChainIdHelper.parse(destinationInfo.network).identifier !== cosmos_1.ChainIdHelper.parse(channel.counterpartyChainId).identifier) {\n        throw new Error(`Fetched the network chain id is different with counterparty chain id (${destinationInfo.network}, ${channel.counterpartyChainId})`);\n      }\n      if (!destinationInfo.latestBlockHeight || destinationInfo.latestBlockHeight.equals(new unit_1.Int(\"0\"))) {\n        throw new Error(`Failed to fetch the latest block of ${channel.counterpartyChainId}`);\n      }\n      const msg = {\n        type: this.msgOpts.ibcTransfer.type,\n        value: {\n          source_port: channel.portId,\n          source_channel: channel.channelId,\n          token: {\n            denom: currency.coinMinimalDenom,\n            amount: actualAmount\n          },\n          sender: this.base.bech32Address,\n          receiver: recipient,\n          timeout_height: {\n            revision_number: cosmos_1.ChainIdHelper.parse(destinationInfo.network).version.toString(),\n            // Set the timeout height as the current height + 150.\n            revision_height: destinationInfo.latestBlockHeight.add(new unit_1.Int(\"150\")).toString()\n          }\n        }\n      };\n      if (msg.value.timeout_height.revision_number === \"0\") {\n        delete msg.value.timeout_height.revision_number;\n      }\n      return {\n        aminoMsgs: [msg],\n        protoMsgs: [{\n          typeUrl: \"/ibc.applications.transfer.v1.MsgTransfer\",\n          value: tx_3.MsgTransfer.encode(tx_3.MsgTransfer.fromPartial({\n            sourcePort: msg.value.source_port,\n            sourceChannel: msg.value.source_channel,\n            token: msg.value.token,\n            sender: msg.value.sender,\n            receiver: msg.value.receiver,\n            timeoutHeight: {\n              revisionNumber: msg.value.timeout_height.revision_number ? msg.value.timeout_height.revision_number : \"0\",\n              revisionHeight: msg.value.timeout_height.revision_height\n            }\n          })).finish()\n        }]\n      };\n    }), tx => {\n      if (tx.code == null || tx.code === 0) {\n        // After succeeding to send token, refresh the balance.\n        const queryBalance = this.queries.queryBalances.getQueryBech32Address(this.base.bech32Address).balances.find(bal => {\n          return bal.currency.coinMinimalDenom === currency.coinMinimalDenom;\n        });\n        if (queryBalance) {\n          queryBalance.fetch();\n        }\n      }\n    });\n  }\n  sendIBCTransferMsg(channel, amount, currency, recipient) {\n    let memo = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    let stdFee = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    let signOptions = arguments.length > 6 ? arguments[6] : undefined;\n    let onTxEvents = arguments.length > 7 ? arguments[7] : undefined;\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (new common_1.DenomHelper(currency.coinMinimalDenom).type !== \"native\") {\n        throw new Error(\"Only native token can be sent via IBC\");\n      }\n      const actualAmount = (() => {\n        let dec = new unit_1.Dec(amount);\n        dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n        return dec.truncate().toString();\n      })();\n      const destinationInfo = this.queriesStore.get(channel.counterpartyChainId).cosmos.queryRPCStatus;\n      yield this.sendMsgs(\"ibcTransfer\", () => __awaiter(this, void 0, void 0, function* () {\n        // Wait until fetching complete.\n        yield destinationInfo.waitFreshResponse();\n        if (!destinationInfo.network) {\n          throw new Error(`Failed to fetch the network chain id of ${channel.counterpartyChainId}`);\n        }\n        if (cosmos_1.ChainIdHelper.parse(destinationInfo.network).identifier !== cosmos_1.ChainIdHelper.parse(channel.counterpartyChainId).identifier) {\n          throw new Error(`Fetched the network chain id is different with counterparty chain id (${destinationInfo.network}, ${channel.counterpartyChainId})`);\n        }\n        if (!destinationInfo.latestBlockHeight || destinationInfo.latestBlockHeight.equals(new unit_1.Int(\"0\"))) {\n          throw new Error(`Failed to fetch the latest block of ${channel.counterpartyChainId}`);\n        }\n        const msg = {\n          type: this.msgOpts.ibcTransfer.type,\n          value: {\n            source_port: channel.portId,\n            source_channel: channel.channelId,\n            token: {\n              denom: currency.coinMinimalDenom,\n              amount: actualAmount\n            },\n            sender: this.base.bech32Address,\n            receiver: recipient,\n            timeout_height: {\n              revision_number: cosmos_1.ChainIdHelper.parse(destinationInfo.network).version.toString(),\n              // Set the timeout height as the current height + 150.\n              revision_height: destinationInfo.latestBlockHeight.add(new unit_1.Int(\"150\")).toString()\n            }\n          }\n        };\n        if (msg.value.timeout_height.revision_number === \"0\") {\n          delete msg.value.timeout_height.revision_number;\n        }\n        return {\n          aminoMsgs: [msg],\n          protoMsgs: [{\n            typeUrl: \"/ibc.applications.transfer.v1.MsgTransfer\",\n            value: tx_3.MsgTransfer.encode(tx_3.MsgTransfer.fromPartial({\n              sourcePort: msg.value.source_port,\n              sourceChannel: msg.value.source_channel,\n              token: msg.value.token,\n              sender: msg.value.sender,\n              receiver: msg.value.receiver,\n              timeoutHeight: {\n                revisionNumber: msg.value.timeout_height.revision_number ? msg.value.timeout_height.revision_number : \"0\",\n                revisionHeight: msg.value.timeout_height.revision_height\n              }\n            })).finish()\n          }]\n        };\n      }), memo, {\n        amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],\n        gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.ibcTransfer.gas.toString()\n      }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, tx => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to send token, refresh the balance.\n          const queryBalance = this.queries.queryBalances.getQueryBech32Address(this.base.bech32Address).balances.find(bal => {\n            return bal.currency.coinMinimalDenom === currency.coinMinimalDenom;\n          });\n          if (queryBalance) {\n            queryBalance.fetch();\n          }\n        }\n      }));\n    });\n  }\n  makeDelegateTx(amount, validatorAddress) {\n    cosmos_1.Bech32Address.validate(validatorAddress, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr);\n    const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n    let dec = new unit_1.Dec(amount);\n    dec = dec.mulTruncate(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n    const msg = {\n      type: this.msgOpts.delegate.type,\n      value: {\n        delegator_address: this.base.bech32Address,\n        validator_address: validatorAddress,\n        amount: {\n          denom: currency.coinMinimalDenom,\n          amount: dec.truncate().toString()\n        }\n      }\n    };\n    return this.makeTx(\"delegate\", {\n      aminoMsgs: [msg],\n      protoMsgs: [{\n        typeUrl: \"/cosmos.staking.v1beta1.MsgDelegate\",\n        value: tx_4.MsgDelegate.encode({\n          delegatorAddress: msg.value.delegator_address,\n          validatorAddress: msg.value.validator_address,\n          amount: msg.value.amount\n        }).finish()\n      }]\n    }, tx => {\n      if (tx.code == null || tx.code === 0) {\n        // After succeeding to delegate, refresh the validators and delegations, rewards.\n        this.queries.cosmos.queryValidators.getQueryStatus(types_1.BondStatus.Bonded).fetch();\n        this.queries.cosmos.queryDelegations.getQueryBech32Address(this.base.bech32Address).fetch();\n        this.queries.cosmos.queryRewards.getQueryBech32Address(this.base.bech32Address).fetch();\n      }\n    });\n  }\n  /**\n   * Send `MsgDelegate` msg to the chain.\n   * @param amount Decimal number used by humans.\n   *               If amount is 0.1 and the stake currenct is uatom, actual amount will be changed to the 100000uatom.\n   * @param validatorAddress\n   * @param memo\n   * @param onFulfill\n   */\n  sendDelegateMsg(amount, validatorAddress) {\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    let stdFee = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let signOptions = arguments.length > 4 ? arguments[4] : undefined;\n    let onTxEvents = arguments.length > 5 ? arguments[5] : undefined;\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n      let dec = new unit_1.Dec(amount);\n      dec = dec.mulTruncate(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n      const msg = {\n        type: this.msgOpts.delegate.type,\n        value: {\n          delegator_address: this.base.bech32Address,\n          validator_address: validatorAddress,\n          amount: {\n            denom: currency.coinMinimalDenom,\n            amount: dec.truncate().toString()\n          }\n        }\n      };\n      yield this.sendMsgs(\"delegate\", {\n        aminoMsgs: [msg],\n        protoMsgs: [{\n          typeUrl: \"/cosmos.staking.v1beta1.MsgDelegate\",\n          value: tx_4.MsgDelegate.encode({\n            delegatorAddress: msg.value.delegator_address,\n            validatorAddress: msg.value.validator_address,\n            amount: msg.value.amount\n          }).finish()\n        }]\n      }, memo, {\n        amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],\n        gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.delegate.gas.toString()\n      }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, tx => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to delegate, refresh the validators and delegations, rewards.\n          this.queries.cosmos.queryValidators.getQueryStatus(types_1.BondStatus.Bonded).fetch();\n          this.queries.cosmos.queryDelegations.getQueryBech32Address(this.base.bech32Address).fetch();\n          this.queries.cosmos.queryRewards.getQueryBech32Address(this.base.bech32Address).fetch();\n        }\n      }));\n    });\n  }\n  makeUndelegateTx(amount, validatorAddress) {\n    cosmos_1.Bech32Address.validate(validatorAddress, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr);\n    const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n    let dec = new unit_1.Dec(amount);\n    dec = dec.mulTruncate(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n    const msg = {\n      type: this.msgOpts.undelegate.type,\n      value: {\n        delegator_address: this.base.bech32Address,\n        validator_address: validatorAddress,\n        amount: {\n          denom: currency.coinMinimalDenom,\n          amount: dec.truncate().toString()\n        }\n      }\n    };\n    return this.makeTx(\"undelegate\", {\n      aminoMsgs: [msg],\n      protoMsgs: [{\n        typeUrl: \"/cosmos.staking.v1beta1.MsgUndelegate\",\n        value: tx_4.MsgUndelegate.encode({\n          delegatorAddress: msg.value.delegator_address,\n          validatorAddress: msg.value.validator_address,\n          amount: msg.value.amount\n        }).finish()\n      }]\n    }, tx => {\n      if (tx.code == null || tx.code === 0) {\n        // After succeeding to unbond, refresh the validators and delegations, unbonding delegations, rewards.\n        this.queries.cosmos.queryValidators.getQueryStatus(types_1.BondStatus.Bonded).fetch();\n        this.queries.cosmos.queryDelegations.getQueryBech32Address(this.base.bech32Address).fetch();\n        this.queries.cosmos.queryUnbondingDelegations.getQueryBech32Address(this.base.bech32Address).fetch();\n        this.queries.cosmos.queryRewards.getQueryBech32Address(this.base.bech32Address).fetch();\n      }\n    });\n  }\n  /**\n   * @deprecated\n   * Send `MsgUndelegate` msg to the chain.\n   * @param amount Decimal number used by humans.\n   *               If amount is 0.1 and the stake currenct is uatom, actual amount will be changed to the 100000uatom.\n   * @param validatorAddress\n   * @param memo\n   * @param onFulfill\n   */\n  sendUndelegateMsg(amount, validatorAddress) {\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    let stdFee = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let signOptions = arguments.length > 4 ? arguments[4] : undefined;\n    let onTxEvents = arguments.length > 5 ? arguments[5] : undefined;\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n      let dec = new unit_1.Dec(amount);\n      dec = dec.mulTruncate(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n      const msg = {\n        type: this.msgOpts.undelegate.type,\n        value: {\n          delegator_address: this.base.bech32Address,\n          validator_address: validatorAddress,\n          amount: {\n            denom: currency.coinMinimalDenom,\n            amount: dec.truncate().toString()\n          }\n        }\n      };\n      yield this.sendMsgs(\"undelegate\", {\n        aminoMsgs: [msg],\n        protoMsgs: [{\n          typeUrl: \"/cosmos.staking.v1beta1.MsgUndelegate\",\n          value: tx_4.MsgUndelegate.encode({\n            delegatorAddress: msg.value.delegator_address,\n            validatorAddress: msg.value.validator_address,\n            amount: msg.value.amount\n          }).finish()\n        }]\n      }, memo, {\n        amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],\n        gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.undelegate.gas.toString()\n      }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, tx => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to unbond, refresh the validators and delegations, unbonding delegations, rewards.\n          this.queries.cosmos.queryValidators.getQueryStatus(types_1.BondStatus.Bonded).fetch();\n          this.queries.cosmos.queryDelegations.getQueryBech32Address(this.base.bech32Address).fetch();\n          this.queries.cosmos.queryUnbondingDelegations.getQueryBech32Address(this.base.bech32Address).fetch();\n          this.queries.cosmos.queryRewards.getQueryBech32Address(this.base.bech32Address).fetch();\n        }\n      }));\n    });\n  }\n  makeBeginRedelegateTx(amount, srcValidatorAddress, dstValidatorAddress) {\n    cosmos_1.Bech32Address.validate(srcValidatorAddress, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr);\n    cosmos_1.Bech32Address.validate(dstValidatorAddress, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr);\n    const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n    let dec = new unit_1.Dec(amount);\n    dec = dec.mulTruncate(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n    const msg = {\n      type: this.msgOpts.redelegate.type,\n      value: {\n        delegator_address: this.base.bech32Address,\n        validator_src_address: srcValidatorAddress,\n        validator_dst_address: dstValidatorAddress,\n        amount: {\n          denom: currency.coinMinimalDenom,\n          amount: dec.truncate().toString()\n        }\n      }\n    };\n    return this.makeTx(\"redelegate\", {\n      aminoMsgs: [msg],\n      protoMsgs: [{\n        typeUrl: \"/cosmos.staking.v1beta1.MsgBeginRedelegate\",\n        value: tx_4.MsgBeginRedelegate.encode({\n          delegatorAddress: msg.value.delegator_address,\n          validatorSrcAddress: msg.value.validator_src_address,\n          validatorDstAddress: msg.value.validator_dst_address,\n          amount: msg.value.amount\n        }).finish()\n      }]\n    }, tx => {\n      if (tx.code == null || tx.code === 0) {\n        // After succeeding to redelegate, refresh the validators and delegations, rewards.\n        this.queries.cosmos.queryValidators.getQueryStatus(types_1.BondStatus.Bonded).fetch();\n        this.queries.cosmos.queryDelegations.getQueryBech32Address(this.base.bech32Address).fetch();\n        this.queries.cosmos.queryRewards.getQueryBech32Address(this.base.bech32Address).fetch();\n      }\n    });\n  }\n  /**\n   * @deprecated\n   * Send `MsgBeginRedelegate` msg to the chain.\n   * @param amount Decimal number used by humans.\n   *               If amount is 0.1 and the stake currenct is uatom, actual amount will be changed to the 100000uatom.\n   * @param srcValidatorAddress\n   * @param dstValidatorAddress\n   * @param memo\n   * @param onFulfill\n   */\n  sendBeginRedelegateMsg(amount, srcValidatorAddress, dstValidatorAddress) {\n    let memo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    let stdFee = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    let signOptions = arguments.length > 5 ? arguments[5] : undefined;\n    let onTxEvents = arguments.length > 6 ? arguments[6] : undefined;\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n      let dec = new unit_1.Dec(amount);\n      dec = dec.mulTruncate(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n      const msg = {\n        type: this.msgOpts.redelegate.type,\n        value: {\n          delegator_address: this.base.bech32Address,\n          validator_src_address: srcValidatorAddress,\n          validator_dst_address: dstValidatorAddress,\n          amount: {\n            denom: currency.coinMinimalDenom,\n            amount: dec.truncate().toString()\n          }\n        }\n      };\n      yield this.sendMsgs(\"redelegate\", {\n        aminoMsgs: [msg],\n        protoMsgs: [{\n          typeUrl: \"/cosmos.staking.v1beta1.MsgBeginRedelegate\",\n          value: tx_4.MsgBeginRedelegate.encode({\n            delegatorAddress: msg.value.delegator_address,\n            validatorSrcAddress: msg.value.validator_src_address,\n            validatorDstAddress: msg.value.validator_dst_address,\n            amount: msg.value.amount\n          }).finish()\n        }]\n      }, memo, {\n        amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],\n        gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.redelegate.gas.toString()\n      }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, tx => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to redelegate, refresh the validators and delegations, rewards.\n          this.queries.cosmos.queryValidators.getQueryStatus(types_1.BondStatus.Bonded).fetch();\n          this.queries.cosmos.queryDelegations.getQueryBech32Address(this.base.bech32Address).fetch();\n          this.queries.cosmos.queryRewards.getQueryBech32Address(this.base.bech32Address).fetch();\n        }\n      }));\n    });\n  }\n  makeWithdrawDelegationRewardTx(validatorAddresses) {\n    for (const validatorAddress of validatorAddresses) {\n      cosmos_1.Bech32Address.validate(validatorAddress, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr);\n    }\n    const msgs = validatorAddresses.map(validatorAddress => {\n      return {\n        type: this.msgOpts.withdrawRewards.type,\n        value: {\n          delegator_address: this.base.bech32Address,\n          validator_address: validatorAddress\n        }\n      };\n    });\n    return this.makeTx(\"withdrawRewards\", {\n      aminoMsgs: msgs,\n      protoMsgs: msgs.map(msg => {\n        return {\n          typeUrl: \"/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward\",\n          value: tx_5.MsgWithdrawDelegatorReward.encode({\n            delegatorAddress: msg.value.delegator_address,\n            validatorAddress: msg.value.validator_address\n          }).finish()\n        };\n      })\n    }, tx => {\n      if (tx.code == null || tx.code === 0) {\n        // After succeeding to withdraw rewards, refresh rewards.\n        this.queries.cosmos.queryRewards.getQueryBech32Address(this.base.bech32Address).fetch();\n      }\n    });\n  }\n  /**\n   * @deprecated\n   */\n  sendWithdrawDelegationRewardMsgs(validatorAddresses) {\n    let memo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let stdFee = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let signOptions = arguments.length > 3 ? arguments[3] : undefined;\n    let onTxEvents = arguments.length > 4 ? arguments[4] : undefined;\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const msgs = validatorAddresses.map(validatorAddress => {\n        return {\n          type: this.msgOpts.withdrawRewards.type,\n          value: {\n            delegator_address: this.base.bech32Address,\n            validator_address: validatorAddress\n          }\n        };\n      });\n      yield this.sendMsgs(\"withdrawRewards\", {\n        aminoMsgs: msgs,\n        protoMsgs: msgs.map(msg => {\n          return {\n            typeUrl: \"/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward\",\n            value: tx_5.MsgWithdrawDelegatorReward.encode({\n              delegatorAddress: msg.value.delegator_address,\n              validatorAddress: msg.value.validator_address\n            }).finish()\n          };\n        })\n      }, memo, {\n        amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],\n        gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : (this.msgOpts.withdrawRewards.gas * validatorAddresses.length).toString()\n      }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, tx => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to withdraw rewards, refresh rewards.\n          this.queries.cosmos.queryRewards.getQueryBech32Address(this.base.bech32Address).fetch();\n        }\n      }));\n    });\n  }\n  makeGovVoteTx(proposalId, option) {\n    const voteOption = (() => {\n      switch (option) {\n        case \"Yes\":\n          return 1;\n        case \"Abstain\":\n          return 2;\n        case \"No\":\n          return 3;\n        case \"NoWithVeto\":\n          return 4;\n      }\n    })();\n    const msg = {\n      type: this.msgOpts.govVote.type,\n      value: {\n        option: voteOption,\n        proposal_id: proposalId,\n        voter: this.base.bech32Address\n      }\n    };\n    return this.makeTx(\"govVote\", {\n      aminoMsgs: [msg],\n      protoMsgs: [{\n        typeUrl: \"/cosmos.gov.v1beta1.MsgVote\",\n        value: tx_6.MsgVote.encode({\n          proposalId: msg.value.proposal_id,\n          voter: msg.value.voter,\n          option: (() => {\n            switch (msg.value.option) {\n              case 1:\n                return gov_1.VoteOption.VOTE_OPTION_YES;\n              case 2:\n                return gov_1.VoteOption.VOTE_OPTION_ABSTAIN;\n              case 3:\n                return gov_1.VoteOption.VOTE_OPTION_NO;\n              case 4:\n                return gov_1.VoteOption.VOTE_OPTION_NO_WITH_VETO;\n              default:\n                return gov_1.VoteOption.VOTE_OPTION_UNSPECIFIED;\n            }\n          })()\n        }).finish()\n      }]\n    }, tx => {\n      if (tx.code == null || tx.code === 0) {\n        // After succeeding to vote, refresh the proposal.\n        const proposal = this.queries.cosmos.queryGovernance.proposals.find(proposal => proposal.id === proposalId);\n        if (proposal) {\n          proposal.fetch();\n        }\n        const vote = this.queries.cosmos.queryProposalVote.getVote(proposalId, this.base.bech32Address);\n        vote.fetch();\n      }\n    });\n  }\n  /**\n   * @deprecated\n   */\n  sendGovVoteMsg(proposalId, option) {\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    let stdFee = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let signOptions = arguments.length > 4 ? arguments[4] : undefined;\n    let onTxEvents = arguments.length > 5 ? arguments[5] : undefined;\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const voteOption = (() => {\n        switch (option) {\n          case \"Yes\":\n            return 1;\n          case \"Abstain\":\n            return 2;\n          case \"No\":\n            return 3;\n          case \"NoWithVeto\":\n            return 4;\n        }\n      })();\n      const msg = {\n        type: this.msgOpts.govVote.type,\n        value: {\n          option: voteOption,\n          proposal_id: proposalId,\n          voter: this.base.bech32Address\n        }\n      };\n      yield this.sendMsgs(\"govVote\", {\n        aminoMsgs: [msg],\n        protoMsgs: [{\n          typeUrl: \"/cosmos.gov.v1beta1.MsgVote\",\n          value: tx_6.MsgVote.encode({\n            proposalId: msg.value.proposal_id,\n            voter: msg.value.voter,\n            option: (() => {\n              switch (msg.value.option) {\n                case 1:\n                  return gov_1.VoteOption.VOTE_OPTION_YES;\n                case 2:\n                  return gov_1.VoteOption.VOTE_OPTION_ABSTAIN;\n                case 3:\n                  return gov_1.VoteOption.VOTE_OPTION_NO;\n                case 4:\n                  return gov_1.VoteOption.VOTE_OPTION_NO_WITH_VETO;\n                default:\n                  return gov_1.VoteOption.VOTE_OPTION_UNSPECIFIED;\n              }\n            })()\n          }).finish()\n        }]\n      }, memo, {\n        amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],\n        gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.govVote.gas.toString()\n      }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, tx => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to vote, refresh the proposal.\n          const proposal = this.queries.cosmos.queryGovernance.proposals.find(proposal => proposal.id === proposalId);\n          if (proposal) {\n            proposal.fetch();\n          }\n          const vote = this.queries.cosmos.queryProposalVote.getVote(proposalId, this.base.bech32Address);\n          vote.fetch();\n        }\n      }));\n    });\n  }\n  get queries() {\n    return this.queriesStore.get(this.chainId);\n  }\n  get hasEthereumAddress() {\n    var _a, _b;\n    return (_b = (_a = this.chainGetter.getChain(this.chainId).features) === null || _a === void 0 ? void 0 : _a.includes(\"eth-address-gen\")) !== null && _b !== void 0 ? _b : false;\n  }\n}\nexports.CosmosAccountImpl = CosmosAccountImpl;","map":{"version":3,"mappings":"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","names":["exports","use","options","base","chainGetter","chainId","msgOptsFromCreator","msgOptsCreator","undefined","cosmos","CosmosAccountImpl","queriesStore","deepmerge_1","send","native","type","gas","ibcTransfer","delegate","undelegate","redelegate","withdrawRewards","govVote","constructor","_msgOpts","txOpts","registerMakeSendTokenFn","processMakeSendTokenTx","bind","registerSendTokenFn","processSendToken","msgOpts","amount","currency","recipient","denomHelper","common_1","coinMinimalDenom","hexAdjustedRecipient","bech32prefix","getChain","bech32Config","bech32PrefixAccAddr","hasEthereumAddress","startsWith","address_1","Error","buf","buffer_1","from","replace","toLowerCase","cosmos_1","toBech32","actualAmount","dec","unit_1","mul","getPrecisionDec","coinDecimals","truncate","toString","validate","msg","value","from_address","bech32Address","to_address","denom","makeTx","aminoMsgs","protoMsgs","typeUrl","tx_2","encode","fromAddress","toAddress","finish","tx","code","queryBalance","queries","queryBalances","getQueryBech32Address","balances","find","bal","fetch","memo","stdFee","signOptions","onTxEvents","sendMsgs","utils_1","msgs","fee","setTxTypeInProgress","txHash","signDoc","result","broadcastMsgs","broadcastMode","e","preTxEvents","onBroadcastFailed","onBroadcasted","onFulfill","txTracer","rpc","wsObject","traceTx","then","close","feeAmount","hash","mode","walletStatus","base_1","Loaded","length","account","fetchFromRest","instance","useEthereumSign","features","includes","keplr","getKeplr","launchpad_1","getAccountNumber","getSequence","signResponse","signAmino","signedTx","tx_1","bodyBytes","fromPartial","messages","signed","authInfoBytes","signerInfos","publicKey","keys_1","key","signature","pub_key","modeInfo","single","signing_1","SIGN_MODE_LEGACY_AMINO_JSON","multi","sequence","gasLimit","signatures","sendTx","simulateTx","unsignedTx","map","Uint8Array","post","tx_bytes","gasUsed","parseInt","data","gas_info","gas_used","Number","isNaN","preOnTxEvents","simulate","__awaiter","sendWithGasPrice","gasInfo","gasPrice","simulateAndSend","feeOptions","gasAdjusted","gasAdjustment","chainInfo","axios_1","create","baseURL","rest","restConfig","makeIBCTransferTx","channel","destinationInfo","get","counterpartyChainId","queryRPCStatus","waitFreshResponse","network","parse","identifier","latestBlockHeight","equals","source_port","portId","source_channel","channelId","token","sender","receiver","timeout_height","revision_number","version","revision_height","add","tx_3","sourcePort","sourceChannel","timeoutHeight","revisionNumber","revisionHeight","sendIBCTransferMsg","makeDelegateTx","validatorAddress","bech32PrefixValAddr","stakeCurrency","mulTruncate","delegator_address","validator_address","tx_4","delegatorAddress","queryValidators","getQueryStatus","types_1","Bonded","queryDelegations","queryRewards","sendDelegateMsg","makeUndelegateTx","queryUnbondingDelegations","sendUndelegateMsg","makeBeginRedelegateTx","srcValidatorAddress","dstValidatorAddress","validator_src_address","validator_dst_address","validatorSrcAddress","validatorDstAddress","sendBeginRedelegateMsg","makeWithdrawDelegationRewardTx","validatorAddresses","tx_5","sendWithdrawDelegationRewardMsgs","makeGovVoteTx","proposalId","option","voteOption","proposal_id","voter","tx_6","gov_1","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO","VOTE_OPTION_UNSPECIFIED","proposal","queryGovernance","proposals","id","vote","queryProposalVote","getVote","sendGovVoteMsg"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/account/cosmos.ts"],"sourcesContent":["import { AccountSetBaseSuper, MsgOpt, WalletStatus } from \"./base\";\nimport { AppCurrency, KeplrSignOptions } from \"@keplr-wallet/types\";\nimport {\n  BroadcastMode,\n  makeSignDoc,\n  Msg,\n  StdFee,\n  StdSignDoc,\n} from \"@cosmjs/launchpad\";\nimport { DenomHelper, escapeHTML } from \"@keplr-wallet/common\";\nimport { Dec, DecUtils, Int } from \"@keplr-wallet/unit\";\nimport { Any } from \"@keplr-wallet/proto-types/google/protobuf/any\";\nimport {\n  AuthInfo,\n  TxRaw,\n  TxBody,\n  Fee,\n  SignerInfo,\n} from \"@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx\";\nimport { SignMode } from \"@keplr-wallet/proto-types/cosmos/tx/signing/v1beta1/signing\";\nimport { PubKey } from \"@keplr-wallet/proto-types/cosmos/crypto/secp256k1/keys\";\nimport { Coin } from \"@keplr-wallet/proto-types/cosmos/base/v1beta1/coin\";\nimport { MsgSend } from \"@keplr-wallet/proto-types/cosmos/bank/v1beta1/tx\";\nimport { MsgTransfer } from \"@keplr-wallet/proto-types/ibc/applications/transfer/v1/tx\";\nimport {\n  MsgDelegate,\n  MsgUndelegate,\n  MsgBeginRedelegate,\n} from \"@keplr-wallet/proto-types/cosmos/staking/v1beta1/tx\";\nimport { MsgWithdrawDelegatorReward } from \"@keplr-wallet/proto-types/cosmos/distribution/v1beta1/tx\";\nimport { MsgVote } from \"@keplr-wallet/proto-types/cosmos/gov/v1beta1/tx\";\nimport { VoteOption } from \"@keplr-wallet/proto-types/cosmos/gov/v1beta1/gov\";\nimport {\n  BaseAccount,\n  Bech32Address,\n  ChainIdHelper,\n  TendermintTxTracer,\n} from \"@keplr-wallet/cosmos\";\nimport { BondStatus } from \"../query/cosmos/staking/types\";\nimport { QueriesSetBase, IQueriesStore, CosmosQueries } from \"../query\";\nimport { DeepPartial, DeepReadonly } from \"utility-types\";\nimport { ChainGetter } from \"../common\";\nimport Axios, { AxiosInstance } from \"axios\";\nimport deepmerge from \"deepmerge\";\nimport { isAddress } from \"@ethersproject/address\";\nimport { Buffer } from \"buffer/\";\nimport { MakeTxResponse, ProtoMsgsOrWithAminoMsgs } from \"./types\";\nimport { txEventsWithPreOnFulfill } from \"./utils\";\n\nexport interface CosmosAccount {\n  cosmos: CosmosAccountImpl;\n}\n\nexport const CosmosAccount = {\n  use(options: {\n    msgOptsCreator?: (\n      chainId: string\n    ) => DeepPartial<CosmosMsgOpts> | undefined;\n    queriesStore: IQueriesStore<CosmosQueries>;\n    wsObject?: new (url: string, protocols?: string | string[]) => WebSocket;\n    preTxEvents?: {\n      onBroadcastFailed?: (chainId: string, e?: Error) => void;\n      onBroadcasted?: (chainId: string, txHash: Uint8Array) => void;\n      onFulfill?: (chainId: string, tx: any) => void;\n    };\n  }): (\n    base: AccountSetBaseSuper,\n    chainGetter: ChainGetter,\n    chainId: string\n  ) => CosmosAccount {\n    return (base, chainGetter, chainId) => {\n      const msgOptsFromCreator = options.msgOptsCreator\n        ? options.msgOptsCreator(chainId)\n        : undefined;\n\n      return {\n        cosmos: new CosmosAccountImpl(\n          base,\n          chainGetter,\n          chainId,\n          options.queriesStore,\n          deepmerge<CosmosMsgOpts, DeepPartial<CosmosMsgOpts>>(\n            defaultCosmosMsgOpts,\n            msgOptsFromCreator ? msgOptsFromCreator : {}\n          ),\n          options\n        ),\n      };\n    };\n  },\n};\n\n/**\n * @deprecated Predict gas through simulation rather than using a fixed gas.\n */\nexport interface CosmosMsgOpts {\n  readonly send: {\n    readonly native: MsgOpt;\n  };\n  readonly ibcTransfer: MsgOpt;\n  readonly delegate: MsgOpt;\n  readonly undelegate: MsgOpt;\n  readonly redelegate: MsgOpt;\n  // The gas multiplication per rewards.\n  readonly withdrawRewards: MsgOpt;\n  readonly govVote: MsgOpt;\n}\n\n/**\n * @deprecated Predict gas through simulation rather than using a fixed gas.\n */\nexport const defaultCosmosMsgOpts: CosmosMsgOpts = {\n  send: {\n    native: {\n      type: \"cosmos-sdk/MsgSend\",\n      gas: 80000,\n    },\n  },\n  ibcTransfer: {\n    type: \"cosmos-sdk/MsgTransfer\",\n    gas: 450000,\n  },\n  delegate: {\n    type: \"cosmos-sdk/MsgDelegate\",\n    gas: 250000,\n  },\n  undelegate: {\n    type: \"cosmos-sdk/MsgUndelegate\",\n    gas: 250000,\n  },\n  redelegate: {\n    type: \"cosmos-sdk/MsgBeginRedelegate\",\n    gas: 250000,\n  },\n  // The gas multiplication per rewards.\n  withdrawRewards: {\n    type: \"cosmos-sdk/MsgWithdrawDelegationReward\",\n    gas: 140000,\n  },\n  govVote: {\n    type: \"cosmos-sdk/MsgVote\",\n    gas: 250000,\n  },\n};\n\nexport class CosmosAccountImpl {\n  public broadcastMode: \"sync\" | \"async\" | \"block\" = \"sync\";\n\n  constructor(\n    protected readonly base: AccountSetBaseSuper,\n    protected readonly chainGetter: ChainGetter,\n    protected readonly chainId: string,\n    protected readonly queriesStore: IQueriesStore<CosmosQueries>,\n    protected readonly _msgOpts: CosmosMsgOpts,\n    protected readonly txOpts: {\n      wsObject?: new (url: string, protocols?: string | string[]) => WebSocket;\n      preTxEvents?: {\n        onBroadcastFailed?: (chainId: string, e?: Error) => void;\n        onBroadcasted?: (chainId: string, txHash: Uint8Array) => void;\n        onFulfill?: (chainId: string, tx: any) => void;\n      };\n    }\n  ) {\n    this.base.registerMakeSendTokenFn(this.processMakeSendTokenTx.bind(this));\n    this.base.registerSendTokenFn(this.processSendToken.bind(this));\n  }\n\n  /**\n   * @deprecated Predict gas through simulation rather than using a fixed gas.\n   */\n  get msgOpts(): CosmosMsgOpts {\n    return this._msgOpts;\n  }\n\n  protected processMakeSendTokenTx(\n    amount: string,\n    currency: AppCurrency,\n    recipient: string\n  ) {\n    const denomHelper = new DenomHelper(currency.coinMinimalDenom);\n\n    const hexAdjustedRecipient = (recipient: string) => {\n      const bech32prefix = this.chainGetter.getChain(this.chainId).bech32Config\n        .bech32PrefixAccAddr;\n      if (this.hasEthereumAddress && recipient.startsWith(\"0x\")) {\n        // Validate hex address\n        if (!isAddress(recipient)) {\n          throw new Error(\"Invalid hex address\");\n        }\n        const buf = Buffer.from(\n          recipient.replace(\"0x\", \"\").toLowerCase(),\n          \"hex\"\n        );\n        return new Bech32Address(buf).toBech32(bech32prefix);\n      }\n      return recipient;\n    };\n\n    if (denomHelper.type === \"native\") {\n      const actualAmount = (() => {\n        let dec = new Dec(amount);\n        dec = dec.mul(DecUtils.getPrecisionDec(currency.coinDecimals));\n        return dec.truncate().toString();\n      })();\n\n      recipient = hexAdjustedRecipient(recipient);\n      Bech32Address.validate(\n        recipient,\n        this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr\n      );\n\n      const msg = {\n        type: this.msgOpts.send.native.type,\n        value: {\n          from_address: this.base.bech32Address,\n          to_address: recipient,\n          amount: [\n            {\n              denom: currency.coinMinimalDenom,\n              amount: actualAmount,\n            },\n          ],\n        },\n      };\n\n      return this.makeTx(\n        \"send\",\n        {\n          aminoMsgs: [msg],\n          protoMsgs: [\n            {\n              typeUrl: \"/cosmos.bank.v1beta1.MsgSend\",\n              value: MsgSend.encode({\n                fromAddress: msg.value.from_address,\n                toAddress: msg.value.to_address,\n                amount: msg.value.amount,\n              }).finish(),\n            },\n          ],\n        },\n        (tx) => {\n          if (tx.code == null || tx.code === 0) {\n            // After succeeding to send token, refresh the balance.\n            const queryBalance = this.queries.queryBalances\n              .getQueryBech32Address(this.base.bech32Address)\n              .balances.find((bal) => {\n                return (\n                  bal.currency.coinMinimalDenom === currency.coinMinimalDenom\n                );\n              });\n\n            if (queryBalance) {\n              queryBalance.fetch();\n            }\n          }\n        }\n      );\n    }\n  }\n\n  /**\n   * @deprecated\n   */\n  protected async processSendToken(\n    amount: string,\n    currency: AppCurrency,\n    recipient: string,\n    memo: string,\n    stdFee: Partial<StdFee>,\n    signOptions?: KeplrSignOptions,\n    onTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ): Promise<boolean> {\n    const denomHelper = new DenomHelper(currency.coinMinimalDenom);\n\n    const hexAdjustedRecipient = (recipient: string) => {\n      const bech32prefix = this.chainGetter.getChain(this.chainId).bech32Config\n        .bech32PrefixAccAddr;\n      if (this.hasEthereumAddress && recipient.startsWith(\"0x\")) {\n        // Validate hex address\n        if (!isAddress(recipient)) {\n          throw new Error(\"Invalid hex address\");\n        }\n        const buf = Buffer.from(\n          recipient.replace(\"0x\", \"\").toLowerCase(),\n          \"hex\"\n        );\n        return new Bech32Address(buf).toBech32(bech32prefix);\n      }\n      return recipient;\n    };\n\n    switch (denomHelper.type) {\n      case \"native\":\n        const actualAmount = (() => {\n          let dec = new Dec(amount);\n          dec = dec.mul(DecUtils.getPrecisionDec(currency.coinDecimals));\n          return dec.truncate().toString();\n        })();\n\n        const msg = {\n          type: this.msgOpts.send.native.type,\n          value: {\n            from_address: this.base.bech32Address,\n            to_address: hexAdjustedRecipient(recipient),\n            amount: [\n              {\n                denom: currency.coinMinimalDenom,\n                amount: actualAmount,\n              },\n            ],\n          },\n        };\n\n        await this.sendMsgs(\n          \"send\",\n          {\n            aminoMsgs: [msg],\n            protoMsgs: [\n              {\n                typeUrl: \"/cosmos.bank.v1beta1.MsgSend\",\n                value: MsgSend.encode({\n                  fromAddress: msg.value.from_address,\n                  toAddress: msg.value.to_address,\n                  amount: msg.value.amount,\n                }).finish(),\n              },\n            ],\n          },\n          memo,\n          {\n            amount: stdFee.amount ?? [],\n            gas: stdFee.gas ?? this.msgOpts.send.native.gas.toString(),\n          },\n          signOptions,\n          txEventsWithPreOnFulfill(onTxEvents, (tx) => {\n            if (tx.code == null || tx.code === 0) {\n              // After succeeding to send token, refresh the balance.\n              const queryBalance = this.queries.queryBalances\n                .getQueryBech32Address(this.base.bech32Address)\n                .balances.find((bal) => {\n                  return (\n                    bal.currency.coinMinimalDenom === currency.coinMinimalDenom\n                  );\n                });\n\n              if (queryBalance) {\n                queryBalance.fetch();\n              }\n            }\n          })\n        );\n        return true;\n    }\n\n    return false;\n  }\n\n  async sendMsgs(\n    type: string | \"unknown\",\n    msgs:\n      | ProtoMsgsOrWithAminoMsgs\n      | (() => Promise<ProtoMsgsOrWithAminoMsgs> | ProtoMsgsOrWithAminoMsgs),\n    memo: string = \"\",\n    fee: StdFee,\n    signOptions?: KeplrSignOptions,\n    onTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcastFailed?: (e?: Error) => void;\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ) {\n    this.base.setTxTypeInProgress(type);\n\n    let txHash: Uint8Array;\n    let signDoc: StdSignDoc;\n    try {\n      if (typeof msgs === \"function\") {\n        msgs = await msgs();\n      }\n\n      const result = await this.broadcastMsgs(\n        msgs,\n        fee,\n        memo,\n        signOptions,\n        this.broadcastMode\n      );\n      txHash = result.txHash;\n      signDoc = result.signDoc;\n    } catch (e) {\n      this.base.setTxTypeInProgress(\"\");\n\n      if (this.txOpts.preTxEvents?.onBroadcastFailed) {\n        this.txOpts.preTxEvents.onBroadcastFailed(this.chainId, e);\n      }\n\n      if (\n        onTxEvents &&\n        \"onBroadcastFailed\" in onTxEvents &&\n        onTxEvents.onBroadcastFailed\n      ) {\n        onTxEvents.onBroadcastFailed(e);\n      }\n\n      throw e;\n    }\n\n    let onBroadcasted: ((txHash: Uint8Array) => void) | undefined;\n    let onFulfill: ((tx: any) => void) | undefined;\n\n    if (onTxEvents) {\n      if (typeof onTxEvents === \"function\") {\n        onFulfill = onTxEvents;\n      } else {\n        onBroadcasted = onTxEvents.onBroadcasted;\n        onFulfill = onTxEvents.onFulfill;\n      }\n    }\n\n    if (this.txOpts.preTxEvents?.onBroadcasted) {\n      this.txOpts.preTxEvents.onBroadcasted(this.chainId, txHash);\n    }\n    if (onBroadcasted) {\n      onBroadcasted(txHash);\n    }\n\n    const txTracer = new TendermintTxTracer(\n      this.chainGetter.getChain(this.chainId).rpc,\n      \"/websocket\",\n      {\n        wsObject: this.txOpts.wsObject,\n      }\n    );\n    txTracer.traceTx(txHash).then((tx) => {\n      txTracer.close();\n\n      this.base.setTxTypeInProgress(\"\");\n\n      // After sending tx, the balances is probably changed due to the fee.\n      for (const feeAmount of signDoc.fee.amount) {\n        const bal = this.queries.queryBalances\n          .getQueryBech32Address(this.base.bech32Address)\n          .balances.find(\n            (bal) => bal.currency.coinMinimalDenom === feeAmount.denom\n          );\n\n        if (bal) {\n          bal.fetch();\n        }\n      }\n\n      // Always add the tx hash data.\n      if (tx && !tx.hash) {\n        tx.hash = Buffer.from(txHash).toString(\"hex\");\n      }\n\n      if (this.txOpts.preTxEvents?.onFulfill) {\n        this.txOpts.preTxEvents.onFulfill(this.chainId, tx);\n      }\n\n      if (onFulfill) {\n        onFulfill(tx);\n      }\n    });\n  }\n\n  // Return the tx hash.\n  protected async broadcastMsgs(\n    msgs: ProtoMsgsOrWithAminoMsgs,\n    fee: StdFee,\n    memo: string = \"\",\n    signOptions?: KeplrSignOptions,\n    mode: \"block\" | \"async\" | \"sync\" = \"async\"\n  ): Promise<{\n    txHash: Uint8Array;\n    signDoc: StdSignDoc;\n  }> {\n    if (this.base.walletStatus !== WalletStatus.Loaded) {\n      throw new Error(`Wallet is not loaded: ${this.base.walletStatus}`);\n    }\n\n    const aminoMsgs: Msg[] = msgs.aminoMsgs;\n    const protoMsgs: Any[] = msgs.protoMsgs;\n\n    // TODO: Make proto sign doc if `aminoMsgs` is empty or null\n    if (aminoMsgs.length === 0 || protoMsgs.length === 0) {\n      throw new Error(\"There is no msg to send\");\n    }\n\n    if (aminoMsgs.length !== protoMsgs.length) {\n      throw new Error(\"The length of aminoMsgs and protoMsgs are different\");\n    }\n\n    const account = await BaseAccount.fetchFromRest(\n      this.instance,\n      this.base.bech32Address,\n      true\n    );\n\n    const useEthereumSign = this.chainGetter\n      .getChain(this.chainId)\n      .features?.includes(\"eth-key-sign\");\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const keplr = (await this.base.getKeplr())!;\n\n    const signDoc = makeSignDoc(\n      aminoMsgs,\n      fee,\n      this.chainId,\n      escapeHTML(memo),\n      account.getAccountNumber().toString(),\n      account.getSequence().toString()\n    );\n\n    const signResponse = await keplr.signAmino(\n      this.chainId,\n      this.base.bech32Address,\n      signDoc,\n      signOptions\n    );\n\n    const signedTx = TxRaw.encode({\n      bodyBytes: TxBody.encode(\n        TxBody.fromPartial({\n          messages: protoMsgs,\n          memo: signResponse.signed.memo,\n        })\n      ).finish(),\n      authInfoBytes: AuthInfo.encode({\n        signerInfos: [\n          {\n            publicKey: {\n              typeUrl: (() => {\n                if (!useEthereumSign) {\n                  return \"/cosmos.crypto.secp256k1.PubKey\";\n                }\n\n                if (this.chainId.startsWith(\"injective\")) {\n                  return \"/injective.crypto.v1beta1.ethsecp256k1.PubKey\";\n                }\n\n                return \"/ethermint.crypto.v1.ethsecp256k1.PubKey\";\n              })(),\n              value: PubKey.encode({\n                key: Buffer.from(\n                  signResponse.signature.pub_key.value,\n                  \"base64\"\n                ),\n              }).finish(),\n            },\n            modeInfo: {\n              single: {\n                mode: SignMode.SIGN_MODE_LEGACY_AMINO_JSON,\n              },\n              multi: undefined,\n            },\n            sequence: signResponse.signed.sequence,\n          },\n        ],\n        fee: Fee.fromPartial({\n          amount: signResponse.signed.fee.amount as Coin[],\n          gasLimit: signResponse.signed.fee.gas,\n        }),\n      }).finish(),\n      signatures: [Buffer.from(signResponse.signature.signature, \"base64\")],\n    }).finish();\n\n    return {\n      txHash: await keplr.sendTx(this.chainId, signedTx, mode as BroadcastMode),\n      signDoc: signResponse.signed,\n    };\n  }\n\n  /**\n   * Simulate tx without making state transition on chain or not waiting the tx committed.\n   * Mainly used to estimate the gas needed to process tx.\n   * You should multiply arbitrary number (gas adjustment) for gas before sending tx.\n   *\n   * NOTE: \"/cosmos/tx/v1beta1/simulate\" returns 400, 500 or (more?) status and error code as a response when tx fails on stimulate.\n   *       Currently, non 200~300 status is handled as error, thus error would be thrown.\n   *\n   * XXX: Uses the simulate request format for cosmos-sdk@0.43+\n   *      Thus, may throw an error if the chain is below cosmos-sdk@0.43\n   *      And, for simplicity, doesn't set the public key to tx bytes.\n   *      Thus, the gas estimated doesn't include the tx bytes size of public key.\n   *\n   * @param msgs\n   * @param fee\n   * @param memo\n   */\n  async simulateTx(\n    msgs: Any[],\n    fee: Omit<StdFee, \"gas\">,\n    memo: string = \"\"\n  ): Promise<{\n    gasUsed: number;\n  }> {\n    const account = await BaseAccount.fetchFromRest(\n      this.instance,\n      this.base.bech32Address,\n      true\n    );\n\n    const unsignedTx = TxRaw.encode({\n      bodyBytes: TxBody.encode(\n        TxBody.fromPartial({\n          messages: msgs,\n          memo: memo,\n        })\n      ).finish(),\n      authInfoBytes: AuthInfo.encode({\n        signerInfos: [\n          SignerInfo.fromPartial({\n            // Pub key is ignored.\n            // It is fine to ignore the pub key when simulating tx.\n            // However, the estimated gas would be slightly smaller because tx size doesn't include pub key.\n            modeInfo: {\n              single: {\n                mode: SignMode.SIGN_MODE_LEGACY_AMINO_JSON,\n              },\n              multi: undefined,\n            },\n            sequence: account.getSequence().toString(),\n          }),\n        ],\n        fee: Fee.fromPartial({\n          amount: fee.amount.map((amount) => {\n            return { amount: amount.amount, denom: amount.denom };\n          }),\n        }),\n      }).finish(),\n      // Because of the validation of tx itself, the signature must exist.\n      // However, since they do not actually verify the signature, it is okay to use any value.\n      signatures: [new Uint8Array(64)],\n    }).finish();\n\n    const result = await this.instance.post(\"/cosmos/tx/v1beta1/simulate\", {\n      tx_bytes: Buffer.from(unsignedTx).toString(\"base64\"),\n    });\n\n    const gasUsed = parseInt(result.data.gas_info.gas_used);\n    if (Number.isNaN(gasUsed)) {\n      throw new Error(`Invalid integer gas: ${result.data.gas_info.gas_used}`);\n    }\n\n    return {\n      gasUsed,\n    };\n  }\n\n  makeTx(\n    type: string | \"unknown\",\n    msgs: ProtoMsgsOrWithAminoMsgs | (() => Promise<ProtoMsgsOrWithAminoMsgs>),\n    preOnTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ): MakeTxResponse {\n    const simulate = async (\n      fee: Partial<Omit<StdFee, \"gas\">> = {},\n      memo: string = \"\"\n    ): Promise<{\n      gasUsed: number;\n    }> => {\n      if (typeof msgs === \"function\") {\n        msgs = await msgs();\n      }\n\n      return this.simulateTx(\n        msgs.protoMsgs,\n        {\n          amount: fee.amount ?? [],\n        },\n        memo\n      );\n    };\n\n    const sendWithGasPrice = async (\n      gasInfo: {\n        gas: number;\n        gasPrice?: {\n          denom: string;\n          amount: Dec;\n        };\n      },\n      memo: string = \"\",\n      signOptions?: KeplrSignOptions,\n      onTxEvents?:\n        | ((tx: any) => void)\n        | {\n            onBroadcastFailed?: (e?: Error) => void;\n            onBroadcasted?: (txHash: Uint8Array) => void;\n            onFulfill?: (tx: any) => void;\n          }\n    ): Promise<void> => {\n      if (gasInfo.gas < 0) {\n        throw new Error(\"Gas is zero or negative\");\n      }\n\n      const fee = {\n        gas: gasInfo.gas.toString(),\n        amount: gasInfo.gasPrice\n          ? [\n              {\n                denom: gasInfo.gasPrice.denom,\n                amount: gasInfo.gasPrice.amount\n                  .mul(new Dec(gasInfo.gas))\n                  .truncate()\n                  .toString(),\n              },\n            ]\n          : [],\n      };\n\n      return this.sendMsgs(\n        type,\n        msgs,\n        memo,\n        fee,\n        signOptions,\n        txEventsWithPreOnFulfill(onTxEvents, preOnTxEvents)\n      );\n    };\n\n    return {\n      msgs: async (): Promise<ProtoMsgsOrWithAminoMsgs> => {\n        if (typeof msgs === \"function\") {\n          msgs = await msgs();\n        }\n        return msgs;\n      },\n      simulate,\n      simulateAndSend: async (\n        feeOptions: {\n          gasAdjustment: number;\n          gasPrice?: {\n            denom: string;\n            amount: Dec;\n          };\n        },\n        memo: string = \"\",\n        signOptions?: KeplrSignOptions,\n        onTxEvents?:\n          | ((tx: any) => void)\n          | {\n              onBroadcastFailed?: (e?: Error) => void;\n              onBroadcasted?: (txHash: Uint8Array) => void;\n              onFulfill?: (tx: any) => void;\n            }\n      ): Promise<void> => {\n        this.base.setTxTypeInProgress(type);\n\n        try {\n          const { gasUsed } = await simulate({}, memo);\n\n          if (gasUsed < 0) {\n            throw new Error(\"Gas estimated is zero or negative\");\n          }\n\n          const gasAdjusted = feeOptions.gasAdjustment * gasUsed;\n\n          return sendWithGasPrice(\n            {\n              gas: gasAdjusted,\n              gasPrice: feeOptions.gasPrice,\n            },\n            memo,\n            signOptions,\n            onTxEvents\n          );\n        } catch (e) {\n          this.base.setTxTypeInProgress(\"\");\n          throw e;\n        }\n      },\n      send: async (\n        fee: StdFee,\n        memo: string = \"\",\n        signOptions?: KeplrSignOptions,\n        onTxEvents?:\n          | ((tx: any) => void)\n          | {\n              onBroadcastFailed?: (e?: Error) => void;\n              onBroadcasted?: (txHash: Uint8Array) => void;\n              onFulfill?: (tx: any) => void;\n            }\n      ): Promise<void> => {\n        return this.sendMsgs(\n          type,\n          msgs,\n          memo,\n          fee,\n          signOptions,\n          txEventsWithPreOnFulfill(onTxEvents, preOnTxEvents)\n        );\n      },\n      sendWithGasPrice,\n    };\n  }\n\n  get instance(): AxiosInstance {\n    const chainInfo = this.chainGetter.getChain(this.chainId);\n    return Axios.create({\n      ...{\n        baseURL: chainInfo.rest,\n      },\n      ...chainInfo.restConfig,\n    });\n  }\n\n  makeIBCTransferTx(\n    channel: {\n      portId: string;\n      channelId: string;\n      counterpartyChainId: string;\n    },\n    amount: string,\n    currency: AppCurrency,\n    recipient: string\n  ) {\n    if (new DenomHelper(currency.coinMinimalDenom).type !== \"native\") {\n      throw new Error(\"Only native token can be sent via IBC\");\n    }\n\n    const actualAmount = (() => {\n      let dec = new Dec(amount);\n      dec = dec.mul(DecUtils.getPrecisionDec(currency.coinDecimals));\n      return dec.truncate().toString();\n    })();\n\n    const destinationInfo = this.queriesStore.get(channel.counterpartyChainId)\n      .cosmos.queryRPCStatus;\n\n    return this.makeTx(\n      \"ibcTransfer\",\n      async () => {\n        // Wait until fetching complete.\n        await destinationInfo.waitFreshResponse();\n\n        if (!destinationInfo.network) {\n          throw new Error(\n            `Failed to fetch the network chain id of ${channel.counterpartyChainId}`\n          );\n        }\n\n        if (\n          ChainIdHelper.parse(destinationInfo.network).identifier !==\n          ChainIdHelper.parse(channel.counterpartyChainId).identifier\n        ) {\n          throw new Error(\n            `Fetched the network chain id is different with counterparty chain id (${destinationInfo.network}, ${channel.counterpartyChainId})`\n          );\n        }\n\n        if (\n          !destinationInfo.latestBlockHeight ||\n          destinationInfo.latestBlockHeight.equals(new Int(\"0\"))\n        ) {\n          throw new Error(\n            `Failed to fetch the latest block of ${channel.counterpartyChainId}`\n          );\n        }\n\n        const msg = {\n          type: this.msgOpts.ibcTransfer.type,\n          value: {\n            source_port: channel.portId,\n            source_channel: channel.channelId,\n            token: {\n              denom: currency.coinMinimalDenom,\n              amount: actualAmount,\n            },\n            sender: this.base.bech32Address,\n            receiver: recipient,\n            timeout_height: {\n              revision_number: ChainIdHelper.parse(\n                destinationInfo.network\n              ).version.toString() as string | undefined,\n              // Set the timeout height as the current height + 150.\n              revision_height: destinationInfo.latestBlockHeight\n                .add(new Int(\"150\"))\n                .toString(),\n            },\n          },\n        };\n\n        if (msg.value.timeout_height.revision_number === \"0\") {\n          delete msg.value.timeout_height.revision_number;\n        }\n\n        return {\n          aminoMsgs: [msg],\n          protoMsgs: [\n            {\n              typeUrl: \"/ibc.applications.transfer.v1.MsgTransfer\",\n              value: MsgTransfer.encode(\n                MsgTransfer.fromPartial({\n                  sourcePort: msg.value.source_port,\n                  sourceChannel: msg.value.source_channel,\n                  token: msg.value.token,\n                  sender: msg.value.sender,\n                  receiver: msg.value.receiver,\n                  timeoutHeight: {\n                    revisionNumber: msg.value.timeout_height.revision_number\n                      ? msg.value.timeout_height.revision_number\n                      : \"0\",\n                    revisionHeight: msg.value.timeout_height.revision_height,\n                  },\n                })\n              ).finish(),\n            },\n          ],\n        };\n      },\n      (tx) => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to send token, refresh the balance.\n          const queryBalance = this.queries.queryBalances\n            .getQueryBech32Address(this.base.bech32Address)\n            .balances.find((bal) => {\n              return (\n                bal.currency.coinMinimalDenom === currency.coinMinimalDenom\n              );\n            });\n\n          if (queryBalance) {\n            queryBalance.fetch();\n          }\n        }\n      }\n    );\n  }\n\n  async sendIBCTransferMsg(\n    channel: {\n      portId: string;\n      channelId: string;\n      counterpartyChainId: string;\n    },\n    amount: string,\n    currency: AppCurrency,\n    recipient: string,\n    memo: string = \"\",\n    stdFee: Partial<StdFee> = {},\n    signOptions?: KeplrSignOptions,\n    onTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ) {\n    if (new DenomHelper(currency.coinMinimalDenom).type !== \"native\") {\n      throw new Error(\"Only native token can be sent via IBC\");\n    }\n\n    const actualAmount = (() => {\n      let dec = new Dec(amount);\n      dec = dec.mul(DecUtils.getPrecisionDec(currency.coinDecimals));\n      return dec.truncate().toString();\n    })();\n\n    const destinationInfo = this.queriesStore.get(channel.counterpartyChainId)\n      .cosmos.queryRPCStatus;\n\n    await this.sendMsgs(\n      \"ibcTransfer\",\n      async () => {\n        // Wait until fetching complete.\n        await destinationInfo.waitFreshResponse();\n\n        if (!destinationInfo.network) {\n          throw new Error(\n            `Failed to fetch the network chain id of ${channel.counterpartyChainId}`\n          );\n        }\n\n        if (\n          ChainIdHelper.parse(destinationInfo.network).identifier !==\n          ChainIdHelper.parse(channel.counterpartyChainId).identifier\n        ) {\n          throw new Error(\n            `Fetched the network chain id is different with counterparty chain id (${destinationInfo.network}, ${channel.counterpartyChainId})`\n          );\n        }\n\n        if (\n          !destinationInfo.latestBlockHeight ||\n          destinationInfo.latestBlockHeight.equals(new Int(\"0\"))\n        ) {\n          throw new Error(\n            `Failed to fetch the latest block of ${channel.counterpartyChainId}`\n          );\n        }\n\n        const msg = {\n          type: this.msgOpts.ibcTransfer.type,\n          value: {\n            source_port: channel.portId,\n            source_channel: channel.channelId,\n            token: {\n              denom: currency.coinMinimalDenom,\n              amount: actualAmount,\n            },\n            sender: this.base.bech32Address,\n            receiver: recipient,\n            timeout_height: {\n              revision_number: ChainIdHelper.parse(\n                destinationInfo.network\n              ).version.toString() as string | undefined,\n              // Set the timeout height as the current height + 150.\n              revision_height: destinationInfo.latestBlockHeight\n                .add(new Int(\"150\"))\n                .toString(),\n            },\n          },\n        };\n\n        if (msg.value.timeout_height.revision_number === \"0\") {\n          delete msg.value.timeout_height.revision_number;\n        }\n\n        return {\n          aminoMsgs: [msg],\n          protoMsgs: [\n            {\n              typeUrl: \"/ibc.applications.transfer.v1.MsgTransfer\",\n              value: MsgTransfer.encode(\n                MsgTransfer.fromPartial({\n                  sourcePort: msg.value.source_port,\n                  sourceChannel: msg.value.source_channel,\n                  token: msg.value.token,\n                  sender: msg.value.sender,\n                  receiver: msg.value.receiver,\n                  timeoutHeight: {\n                    revisionNumber: msg.value.timeout_height.revision_number\n                      ? msg.value.timeout_height.revision_number\n                      : \"0\",\n                    revisionHeight: msg.value.timeout_height.revision_height,\n                  },\n                })\n              ).finish(),\n            },\n          ],\n        };\n      },\n      memo,\n      {\n        amount: stdFee.amount ?? [],\n        gas: stdFee.gas ?? this.msgOpts.ibcTransfer.gas.toString(),\n      },\n      signOptions,\n      txEventsWithPreOnFulfill(onTxEvents, (tx) => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to send token, refresh the balance.\n          const queryBalance = this.queries.queryBalances\n            .getQueryBech32Address(this.base.bech32Address)\n            .balances.find((bal) => {\n              return (\n                bal.currency.coinMinimalDenom === currency.coinMinimalDenom\n              );\n            });\n\n          if (queryBalance) {\n            queryBalance.fetch();\n          }\n        }\n      })\n    );\n  }\n\n  makeDelegateTx(amount: string, validatorAddress: string) {\n    Bech32Address.validate(\n      validatorAddress,\n      this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr\n    );\n\n    const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n\n    let dec = new Dec(amount);\n    dec = dec.mulTruncate(DecUtils.getPrecisionDec(currency.coinDecimals));\n\n    const msg = {\n      type: this.msgOpts.delegate.type,\n      value: {\n        delegator_address: this.base.bech32Address,\n        validator_address: validatorAddress,\n        amount: {\n          denom: currency.coinMinimalDenom,\n          amount: dec.truncate().toString(),\n        },\n      },\n    };\n\n    return this.makeTx(\n      \"delegate\",\n      {\n        aminoMsgs: [msg],\n        protoMsgs: [\n          {\n            typeUrl: \"/cosmos.staking.v1beta1.MsgDelegate\",\n            value: MsgDelegate.encode({\n              delegatorAddress: msg.value.delegator_address,\n              validatorAddress: msg.value.validator_address,\n              amount: msg.value.amount,\n            }).finish(),\n          },\n        ],\n      },\n      (tx) => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to delegate, refresh the validators and delegations, rewards.\n          this.queries.cosmos.queryValidators\n            .getQueryStatus(BondStatus.Bonded)\n            .fetch();\n          this.queries.cosmos.queryDelegations\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n          this.queries.cosmos.queryRewards\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n        }\n      }\n    );\n  }\n\n  /**\n   * Send `MsgDelegate` msg to the chain.\n   * @param amount Decimal number used by humans.\n   *               If amount is 0.1 and the stake currenct is uatom, actual amount will be changed to the 100000uatom.\n   * @param validatorAddress\n   * @param memo\n   * @param onFulfill\n   */\n  async sendDelegateMsg(\n    amount: string,\n    validatorAddress: string,\n    memo: string = \"\",\n    stdFee: Partial<StdFee> = {},\n    signOptions?: KeplrSignOptions,\n    onTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ) {\n    const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n\n    let dec = new Dec(amount);\n    dec = dec.mulTruncate(DecUtils.getPrecisionDec(currency.coinDecimals));\n\n    const msg = {\n      type: this.msgOpts.delegate.type,\n      value: {\n        delegator_address: this.base.bech32Address,\n        validator_address: validatorAddress,\n        amount: {\n          denom: currency.coinMinimalDenom,\n          amount: dec.truncate().toString(),\n        },\n      },\n    };\n\n    await this.sendMsgs(\n      \"delegate\",\n      {\n        aminoMsgs: [msg],\n        protoMsgs: [\n          {\n            typeUrl: \"/cosmos.staking.v1beta1.MsgDelegate\",\n            value: MsgDelegate.encode({\n              delegatorAddress: msg.value.delegator_address,\n              validatorAddress: msg.value.validator_address,\n              amount: msg.value.amount,\n            }).finish(),\n          },\n        ],\n      },\n      memo,\n      {\n        amount: stdFee.amount ?? [],\n        gas: stdFee.gas ?? this.msgOpts.delegate.gas.toString(),\n      },\n      signOptions,\n      txEventsWithPreOnFulfill(onTxEvents, (tx) => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to delegate, refresh the validators and delegations, rewards.\n          this.queries.cosmos.queryValidators\n            .getQueryStatus(BondStatus.Bonded)\n            .fetch();\n          this.queries.cosmos.queryDelegations\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n          this.queries.cosmos.queryRewards\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n        }\n      })\n    );\n  }\n\n  makeUndelegateTx(amount: string, validatorAddress: string) {\n    Bech32Address.validate(\n      validatorAddress,\n      this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr\n    );\n\n    const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n\n    let dec = new Dec(amount);\n    dec = dec.mulTruncate(DecUtils.getPrecisionDec(currency.coinDecimals));\n\n    const msg = {\n      type: this.msgOpts.undelegate.type,\n      value: {\n        delegator_address: this.base.bech32Address,\n        validator_address: validatorAddress,\n        amount: {\n          denom: currency.coinMinimalDenom,\n          amount: dec.truncate().toString(),\n        },\n      },\n    };\n\n    return this.makeTx(\n      \"undelegate\",\n      {\n        aminoMsgs: [msg],\n        protoMsgs: [\n          {\n            typeUrl: \"/cosmos.staking.v1beta1.MsgUndelegate\",\n            value: MsgUndelegate.encode({\n              delegatorAddress: msg.value.delegator_address,\n              validatorAddress: msg.value.validator_address,\n              amount: msg.value.amount,\n            }).finish(),\n          },\n        ],\n      },\n      (tx) => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to unbond, refresh the validators and delegations, unbonding delegations, rewards.\n          this.queries.cosmos.queryValidators\n            .getQueryStatus(BondStatus.Bonded)\n            .fetch();\n          this.queries.cosmos.queryDelegations\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n          this.queries.cosmos.queryUnbondingDelegations\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n          this.queries.cosmos.queryRewards\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n        }\n      }\n    );\n  }\n\n  /**\n   * @deprecated\n   * Send `MsgUndelegate` msg to the chain.\n   * @param amount Decimal number used by humans.\n   *               If amount is 0.1 and the stake currenct is uatom, actual amount will be changed to the 100000uatom.\n   * @param validatorAddress\n   * @param memo\n   * @param onFulfill\n   */\n  async sendUndelegateMsg(\n    amount: string,\n    validatorAddress: string,\n    memo: string = \"\",\n    stdFee: Partial<StdFee> = {},\n    signOptions?: KeplrSignOptions,\n    onTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ) {\n    const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n\n    let dec = new Dec(amount);\n    dec = dec.mulTruncate(DecUtils.getPrecisionDec(currency.coinDecimals));\n\n    const msg = {\n      type: this.msgOpts.undelegate.type,\n      value: {\n        delegator_address: this.base.bech32Address,\n        validator_address: validatorAddress,\n        amount: {\n          denom: currency.coinMinimalDenom,\n          amount: dec.truncate().toString(),\n        },\n      },\n    };\n\n    await this.sendMsgs(\n      \"undelegate\",\n      {\n        aminoMsgs: [msg],\n        protoMsgs: [\n          {\n            typeUrl: \"/cosmos.staking.v1beta1.MsgUndelegate\",\n            value: MsgUndelegate.encode({\n              delegatorAddress: msg.value.delegator_address,\n              validatorAddress: msg.value.validator_address,\n              amount: msg.value.amount,\n            }).finish(),\n          },\n        ],\n      },\n      memo,\n      {\n        amount: stdFee.amount ?? [],\n        gas: stdFee.gas ?? this.msgOpts.undelegate.gas.toString(),\n      },\n      signOptions,\n      txEventsWithPreOnFulfill(onTxEvents, (tx) => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to unbond, refresh the validators and delegations, unbonding delegations, rewards.\n          this.queries.cosmos.queryValidators\n            .getQueryStatus(BondStatus.Bonded)\n            .fetch();\n          this.queries.cosmos.queryDelegations\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n          this.queries.cosmos.queryUnbondingDelegations\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n          this.queries.cosmos.queryRewards\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n        }\n      })\n    );\n  }\n\n  makeBeginRedelegateTx(\n    amount: string,\n    srcValidatorAddress: string,\n    dstValidatorAddress: string\n  ) {\n    Bech32Address.validate(\n      srcValidatorAddress,\n      this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr\n    );\n    Bech32Address.validate(\n      dstValidatorAddress,\n      this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr\n    );\n\n    const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n\n    let dec = new Dec(amount);\n    dec = dec.mulTruncate(DecUtils.getPrecisionDec(currency.coinDecimals));\n\n    const msg = {\n      type: this.msgOpts.redelegate.type,\n      value: {\n        delegator_address: this.base.bech32Address,\n        validator_src_address: srcValidatorAddress,\n        validator_dst_address: dstValidatorAddress,\n        amount: {\n          denom: currency.coinMinimalDenom,\n          amount: dec.truncate().toString(),\n        },\n      },\n    };\n\n    return this.makeTx(\n      \"redelegate\",\n      {\n        aminoMsgs: [msg],\n        protoMsgs: [\n          {\n            typeUrl: \"/cosmos.staking.v1beta1.MsgBeginRedelegate\",\n            value: MsgBeginRedelegate.encode({\n              delegatorAddress: msg.value.delegator_address,\n              validatorSrcAddress: msg.value.validator_src_address,\n              validatorDstAddress: msg.value.validator_dst_address,\n              amount: msg.value.amount,\n            }).finish(),\n          },\n        ],\n      },\n      (tx) => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to redelegate, refresh the validators and delegations, rewards.\n          this.queries.cosmos.queryValidators\n            .getQueryStatus(BondStatus.Bonded)\n            .fetch();\n          this.queries.cosmos.queryDelegations\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n          this.queries.cosmos.queryRewards\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n        }\n      }\n    );\n  }\n\n  /**\n   * @deprecated\n   * Send `MsgBeginRedelegate` msg to the chain.\n   * @param amount Decimal number used by humans.\n   *               If amount is 0.1 and the stake currenct is uatom, actual amount will be changed to the 100000uatom.\n   * @param srcValidatorAddress\n   * @param dstValidatorAddress\n   * @param memo\n   * @param onFulfill\n   */\n  async sendBeginRedelegateMsg(\n    amount: string,\n    srcValidatorAddress: string,\n    dstValidatorAddress: string,\n    memo: string = \"\",\n    stdFee: Partial<StdFee> = {},\n    signOptions?: KeplrSignOptions,\n    onTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ) {\n    const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;\n\n    let dec = new Dec(amount);\n    dec = dec.mulTruncate(DecUtils.getPrecisionDec(currency.coinDecimals));\n\n    const msg = {\n      type: this.msgOpts.redelegate.type,\n      value: {\n        delegator_address: this.base.bech32Address,\n        validator_src_address: srcValidatorAddress,\n        validator_dst_address: dstValidatorAddress,\n        amount: {\n          denom: currency.coinMinimalDenom,\n          amount: dec.truncate().toString(),\n        },\n      },\n    };\n\n    await this.sendMsgs(\n      \"redelegate\",\n      {\n        aminoMsgs: [msg],\n        protoMsgs: [\n          {\n            typeUrl: \"/cosmos.staking.v1beta1.MsgBeginRedelegate\",\n            value: MsgBeginRedelegate.encode({\n              delegatorAddress: msg.value.delegator_address,\n              validatorSrcAddress: msg.value.validator_src_address,\n              validatorDstAddress: msg.value.validator_dst_address,\n              amount: msg.value.amount,\n            }).finish(),\n          },\n        ],\n      },\n      memo,\n      {\n        amount: stdFee.amount ?? [],\n        gas: stdFee.gas ?? this.msgOpts.redelegate.gas.toString(),\n      },\n      signOptions,\n      txEventsWithPreOnFulfill(onTxEvents, (tx) => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to redelegate, refresh the validators and delegations, rewards.\n          this.queries.cosmos.queryValidators\n            .getQueryStatus(BondStatus.Bonded)\n            .fetch();\n          this.queries.cosmos.queryDelegations\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n          this.queries.cosmos.queryRewards\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n        }\n      })\n    );\n  }\n\n  makeWithdrawDelegationRewardTx(validatorAddresses: string[]) {\n    for (const validatorAddress of validatorAddresses) {\n      Bech32Address.validate(\n        validatorAddress,\n        this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr\n      );\n    }\n\n    const msgs = validatorAddresses.map((validatorAddress) => {\n      return {\n        type: this.msgOpts.withdrawRewards.type,\n        value: {\n          delegator_address: this.base.bech32Address,\n          validator_address: validatorAddress,\n        },\n      };\n    });\n\n    return this.makeTx(\n      \"withdrawRewards\",\n      {\n        aminoMsgs: msgs,\n        protoMsgs: msgs.map((msg) => {\n          return {\n            typeUrl: \"/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward\",\n            value: MsgWithdrawDelegatorReward.encode({\n              delegatorAddress: msg.value.delegator_address,\n              validatorAddress: msg.value.validator_address,\n            }).finish(),\n          };\n        }),\n      },\n      (tx) => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to withdraw rewards, refresh rewards.\n          this.queries.cosmos.queryRewards\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n        }\n      }\n    );\n  }\n\n  /**\n   * @deprecated\n   */\n  async sendWithdrawDelegationRewardMsgs(\n    validatorAddresses: string[],\n    memo: string = \"\",\n    stdFee: Partial<StdFee> = {},\n    signOptions?: KeplrSignOptions,\n    onTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ) {\n    const msgs = validatorAddresses.map((validatorAddress) => {\n      return {\n        type: this.msgOpts.withdrawRewards.type,\n        value: {\n          delegator_address: this.base.bech32Address,\n          validator_address: validatorAddress,\n        },\n      };\n    });\n\n    await this.sendMsgs(\n      \"withdrawRewards\",\n      {\n        aminoMsgs: msgs,\n        protoMsgs: msgs.map((msg) => {\n          return {\n            typeUrl: \"/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward\",\n            value: MsgWithdrawDelegatorReward.encode({\n              delegatorAddress: msg.value.delegator_address,\n              validatorAddress: msg.value.validator_address,\n            }).finish(),\n          };\n        }),\n      },\n      memo,\n      {\n        amount: stdFee.amount ?? [],\n        gas:\n          stdFee.gas ??\n          (\n            this.msgOpts.withdrawRewards.gas * validatorAddresses.length\n          ).toString(),\n      },\n      signOptions,\n      txEventsWithPreOnFulfill(onTxEvents, (tx) => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to withdraw rewards, refresh rewards.\n          this.queries.cosmos.queryRewards\n            .getQueryBech32Address(this.base.bech32Address)\n            .fetch();\n        }\n      })\n    );\n  }\n\n  makeGovVoteTx(\n    proposalId: string,\n    option: \"Yes\" | \"No\" | \"Abstain\" | \"NoWithVeto\"\n  ) {\n    const voteOption = (() => {\n      switch (option) {\n        case \"Yes\":\n          return 1;\n        case \"Abstain\":\n          return 2;\n        case \"No\":\n          return 3;\n        case \"NoWithVeto\":\n          return 4;\n      }\n    })();\n\n    const msg = {\n      type: this.msgOpts.govVote.type,\n      value: {\n        option: voteOption,\n        proposal_id: proposalId,\n        voter: this.base.bech32Address,\n      },\n    };\n\n    return this.makeTx(\n      \"govVote\",\n      {\n        aminoMsgs: [msg],\n        protoMsgs: [\n          {\n            typeUrl: \"/cosmos.gov.v1beta1.MsgVote\",\n            value: MsgVote.encode({\n              proposalId: msg.value.proposal_id,\n              voter: msg.value.voter,\n              option: (() => {\n                switch (msg.value.option) {\n                  case 1:\n                    return VoteOption.VOTE_OPTION_YES;\n                  case 2:\n                    return VoteOption.VOTE_OPTION_ABSTAIN;\n                  case 3:\n                    return VoteOption.VOTE_OPTION_NO;\n                  case 4:\n                    return VoteOption.VOTE_OPTION_NO_WITH_VETO;\n                  default:\n                    return VoteOption.VOTE_OPTION_UNSPECIFIED;\n                }\n              })(),\n            }).finish(),\n          },\n        ],\n      },\n      (tx) => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to vote, refresh the proposal.\n          const proposal = this.queries.cosmos.queryGovernance.proposals.find(\n            (proposal) => proposal.id === proposalId\n          );\n          if (proposal) {\n            proposal.fetch();\n          }\n\n          const vote = this.queries.cosmos.queryProposalVote.getVote(\n            proposalId,\n            this.base.bech32Address\n          );\n          vote.fetch();\n        }\n      }\n    );\n  }\n\n  /**\n   * @deprecated\n   */\n  async sendGovVoteMsg(\n    proposalId: string,\n    option: \"Yes\" | \"No\" | \"Abstain\" | \"NoWithVeto\",\n    memo: string = \"\",\n    stdFee: Partial<StdFee> = {},\n    signOptions?: KeplrSignOptions,\n    onTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ) {\n    const voteOption = (() => {\n      switch (option) {\n        case \"Yes\":\n          return 1;\n        case \"Abstain\":\n          return 2;\n        case \"No\":\n          return 3;\n        case \"NoWithVeto\":\n          return 4;\n      }\n    })();\n\n    const msg = {\n      type: this.msgOpts.govVote.type,\n      value: {\n        option: voteOption,\n        proposal_id: proposalId,\n        voter: this.base.bech32Address,\n      },\n    };\n\n    await this.sendMsgs(\n      \"govVote\",\n      {\n        aminoMsgs: [msg],\n        protoMsgs: [\n          {\n            typeUrl: \"/cosmos.gov.v1beta1.MsgVote\",\n            value: MsgVote.encode({\n              proposalId: msg.value.proposal_id,\n              voter: msg.value.voter,\n              option: (() => {\n                switch (msg.value.option) {\n                  case 1:\n                    return VoteOption.VOTE_OPTION_YES;\n                  case 2:\n                    return VoteOption.VOTE_OPTION_ABSTAIN;\n                  case 3:\n                    return VoteOption.VOTE_OPTION_NO;\n                  case 4:\n                    return VoteOption.VOTE_OPTION_NO_WITH_VETO;\n                  default:\n                    return VoteOption.VOTE_OPTION_UNSPECIFIED;\n                }\n              })(),\n            }).finish(),\n          },\n        ],\n      },\n      memo,\n      {\n        amount: stdFee.amount ?? [],\n        gas: stdFee.gas ?? this.msgOpts.govVote.gas.toString(),\n      },\n      signOptions,\n      txEventsWithPreOnFulfill(onTxEvents, (tx) => {\n        if (tx.code == null || tx.code === 0) {\n          // After succeeding to vote, refresh the proposal.\n          const proposal = this.queries.cosmos.queryGovernance.proposals.find(\n            (proposal) => proposal.id === proposalId\n          );\n          if (proposal) {\n            proposal.fetch();\n          }\n\n          const vote = this.queries.cosmos.queryProposalVote.getVote(\n            proposalId,\n            this.base.bech32Address\n          );\n          vote.fetch();\n        }\n      })\n    );\n  }\n\n  protected get queries(): DeepReadonly<QueriesSetBase & CosmosQueries> {\n    return this.queriesStore.get(this.chainId);\n  }\n\n  protected get hasEthereumAddress(): boolean {\n    return (\n      this.chainGetter\n        .getChain(this.chainId)\n        .features?.includes(\"eth-address-gen\") ?? false\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}