{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AccountSetBaseSuper = exports.AccountSetBase = exports.WalletStatus = void 0;\nconst mobx_1 = require(\"mobx\");\nconst common_1 = require(\"@keplr-wallet/common\");\nconst cosmos_1 = require(\"@keplr-wallet/cosmos\");\nvar WalletStatus;\n(function (WalletStatus) {\n  WalletStatus[\"NotInit\"] = \"NotInit\";\n  WalletStatus[\"Loading\"] = \"Loading\";\n  WalletStatus[\"Loaded\"] = \"Loaded\";\n  WalletStatus[\"NotExist\"] = \"NotExist\";\n  WalletStatus[\"Rejected\"] = \"Rejected\";\n})(WalletStatus = exports.WalletStatus || (exports.WalletStatus = {}));\nclass AccountSetBase {\n  constructor(eventListener, chainGetter, chainId, opts) {\n    this.eventListener = eventListener;\n    this.chainGetter = chainGetter;\n    this.chainId = chainId;\n    this.opts = opts;\n    this._walletVersion = undefined;\n    this._walletStatus = WalletStatus.NotInit;\n    this._name = \"\";\n    this._bech32Address = \"\";\n    this._txTypeInProgress = \"\";\n    this.hasInited = false;\n    this.sendTokenFns = [];\n    this.makeSendTokenTxFns = [];\n    this.handleInit = () => this.init();\n    mobx_1.makeObservable(this);\n    this.pubKey = new Uint8Array();\n    if (opts.autoInit) {\n      this.init();\n    }\n  }\n  getKeplr() {\n    return this.opts.getKeplr();\n  }\n  registerSendTokenFn(fn) {\n    this.sendTokenFns.push(fn);\n  }\n  registerMakeSendTokenFn(fn) {\n    this.makeSendTokenTxFns.push(fn);\n  }\n  enable(keplr, chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chainInfo = this.chainGetter.getChain(chainId);\n      if (this.opts.suggestChain) {\n        if (this.opts.suggestChainFn) {\n          yield this.opts.suggestChainFn(keplr, chainInfo);\n        } else {\n          yield this.suggestChain(keplr, chainInfo);\n        }\n      }\n      yield keplr.enable(chainId);\n    });\n  }\n  suggestChain(keplr, chainInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield keplr.experimentalSuggestChain(chainInfo.raw);\n    });\n  }\n  *init() {\n    // If wallet status is not exist, there is no need to try to init because it always fails.\n    if (this.walletStatus === WalletStatus.NotExist) {\n      return;\n    }\n    // If the store has never been initialized, add the event listener.\n    if (!this.hasInited) {\n      // If key store in the keplr extension is changed, this event will be dispatched.\n      this.eventListener.addEventListener(\"keplr_keystorechange\", this.handleInit);\n    }\n    this.hasInited = true;\n    // Set wallet status as loading whenever try to init.\n    this._walletStatus = WalletStatus.Loading;\n    const keplr = yield* common_1.toGenerator(this.getKeplr());\n    if (!keplr) {\n      this._walletStatus = WalletStatus.NotExist;\n      return;\n    }\n    this._walletVersion = keplr.version;\n    try {\n      yield this.enable(keplr, this.chainId);\n    } catch (e) {\n      console.log(e);\n      this._walletStatus = WalletStatus.Rejected;\n      this._rejectionReason = e;\n      return;\n    }\n    try {\n      const key = yield* common_1.toGenerator(keplr.getKey(this.chainId));\n      this._bech32Address = key.bech32Address;\n      this._name = key.name;\n      this.pubKey = key.pubKey;\n      // Set the wallet status as loaded after getting all necessary infos.\n      this._walletStatus = WalletStatus.Loaded;\n    } catch (e) {\n      console.log(e);\n      // Caught error loading key\n      // Reset properties, and set status to Rejected\n      this._bech32Address = \"\";\n      this._name = \"\";\n      this.pubKey = new Uint8Array(0);\n      this._walletStatus = WalletStatus.Rejected;\n      this._rejectionReason = e;\n    }\n    if (this._walletStatus !== WalletStatus.Rejected) {\n      // Reset previous rejection error message\n      this._rejectionReason = undefined;\n    }\n  }\n  disconnect() {\n    this._walletStatus = WalletStatus.NotInit;\n    this.hasInited = false;\n    this.eventListener.removeEventListener(\"keplr_keystorechange\", this.handleInit);\n    this._bech32Address = \"\";\n    this._name = \"\";\n    this.pubKey = new Uint8Array(0);\n  }\n  get walletVersion() {\n    return this._walletVersion;\n  }\n  get isReadyToSendTx() {\n    return this.walletStatus === WalletStatus.Loaded && this.bech32Address !== \"\";\n  }\n  /**\n   * @deprecated Use `isReadyToSendTx`\n   */\n  get isReadyToSendMsgs() {\n    return this.walletStatus === WalletStatus.Loaded && this.bech32Address !== \"\";\n  }\n  makeSendTokenTx(amount, currency, recipient) {\n    for (let i = 0; i < this.makeSendTokenTxFns.length; i++) {\n      const fn = this.makeSendTokenTxFns[i];\n      const res = fn(amount, currency, recipient);\n      if (res) {\n        return res;\n      }\n    }\n    const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);\n    throw new Error(`Unsupported type of currency (${denomHelper.type})`);\n  }\n  sendToken(amount, currency, recipient) {\n    let memo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    let stdFee = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    let signOptions = arguments.length > 5 ? arguments[5] : undefined;\n    let onTxEvents = arguments.length > 6 ? arguments[6] : undefined;\n    return __awaiter(this, void 0, void 0, function* () {\n      for (let i = 0; i < this.sendTokenFns.length; i++) {\n        const fn = this.sendTokenFns[i];\n        if (yield fn(amount, currency, recipient, memo, stdFee, signOptions, onTxEvents)) {\n          return;\n        }\n      }\n      const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);\n      throw new Error(`Unsupported type of currency (${denomHelper.type})`);\n    });\n  }\n  get walletStatus() {\n    return this._walletStatus;\n  }\n  get rejectionReason() {\n    return this._rejectionReason;\n  }\n  get name() {\n    return this._name;\n  }\n  get bech32Address() {\n    return this._bech32Address;\n  }\n  /**\n   * Returns the tx type in progress waiting to be committed.\n   * If there is no tx type in progress, this returns an empty string (\"\").\n   */\n  get txTypeInProgress() {\n    return this._txTypeInProgress;\n  }\n  /**\n   * @deprecated Use `txTypeInProgress`\n   */\n  get isSendingMsg() {\n    return this.txTypeInProgress;\n  }\n  get hasEthereumHexAddress() {\n    var _a, _b;\n    return (_b = (_a = this.chainGetter.getChain(this.chainId).features) === null || _a === void 0 ? void 0 : _a.includes(\"eth-address-gen\")) !== null && _b !== void 0 ? _b : false;\n  }\n  get ethereumHexAddress() {\n    if (this.bech32Address === \"\") {\n      return \"\";\n    }\n    return cosmos_1.Bech32Address.fromBech32(this.bech32Address, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr).toHex(true);\n  }\n}\n__decorate([mobx_1.observable], AccountSetBase.prototype, \"_walletVersion\", void 0);\n__decorate([mobx_1.observable], AccountSetBase.prototype, \"_walletStatus\", void 0);\n__decorate([mobx_1.observable], AccountSetBase.prototype, \"_rejectionReason\", void 0);\n__decorate([mobx_1.observable], AccountSetBase.prototype, \"_name\", void 0);\n__decorate([mobx_1.observable], AccountSetBase.prototype, \"_bech32Address\", void 0);\n__decorate([mobx_1.observable], AccountSetBase.prototype, \"_txTypeInProgress\", void 0);\n__decorate([mobx_1.flow], AccountSetBase.prototype, \"init\", null);\n__decorate([mobx_1.action], AccountSetBase.prototype, \"disconnect\", null);\n__decorate([mobx_1.computed], AccountSetBase.prototype, \"isReadyToSendTx\", null);\n__decorate([mobx_1.computed], AccountSetBase.prototype, \"isReadyToSendMsgs\", null);\n__decorate([mobx_1.computed], AccountSetBase.prototype, \"ethereumHexAddress\", null);\nexports.AccountSetBase = AccountSetBase;\nclass AccountSetBaseSuper extends AccountSetBase {\n  constructor() {\n    super(...arguments);\n    mobx_1.makeObservable(this);\n  }\n  setTxTypeInProgress(type) {\n    this._txTypeInProgress = type;\n  }\n}\n__decorate([mobx_1.action], AccountSetBaseSuper.prototype, \"setTxTypeInProgress\", null);\nexports.AccountSetBaseSuper = AccountSetBaseSuper;","map":{"version":3,"mappings":"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","names":["WalletStatus","exports","AccountSetBase","constructor","eventListener","chainGetter","chainId","opts","undefined","NotInit","init","mobx_1","pubKey","Uint8Array","autoInit","getKeplr","registerSendTokenFn","fn","sendTokenFns","push","registerMakeSendTokenFn","makeSendTokenTxFns","enable","keplr","chainInfo","getChain","suggestChain","suggestChainFn","experimentalSuggestChain","raw","walletStatus","NotExist","hasInited","addEventListener","handleInit","_walletStatus","Loading","common_1","_walletVersion","version","e","console","log","Rejected","_rejectionReason","key","getKey","_bech32Address","bech32Address","_name","name","Loaded","disconnect","removeEventListener","walletVersion","isReadyToSendTx","isReadyToSendMsgs","makeSendTokenTx","amount","currency","recipient","i","length","res","denomHelper","coinMinimalDenom","Error","type","sendToken","memo","stdFee","signOptions","onTxEvents","rejectionReason","txTypeInProgress","_txTypeInProgress","isSendingMsg","hasEthereumHexAddress","features","includes","ethereumHexAddress","cosmos_1","fromBech32","bech32Config","bech32PrefixAccAddr","toHex","__decorate","AccountSetBaseSuper","setTxTypeInProgress"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/@keplr-wallet/stores/src/account/base.ts"],"sourcesContent":["import { action, computed, flow, makeObservable, observable } from \"mobx\";\nimport { AppCurrency, Keplr, KeplrSignOptions } from \"@keplr-wallet/types\";\nimport { ChainGetter } from \"../common\";\nimport { DenomHelper, toGenerator } from \"@keplr-wallet/common\";\nimport { Bech32Address } from \"@keplr-wallet/cosmos\";\nimport { StdFee } from \"@cosmjs/launchpad\";\nimport { MakeTxResponse } from \"./types\";\n\nexport enum WalletStatus {\n  NotInit = \"NotInit\",\n  Loading = \"Loading\",\n  Loaded = \"Loaded\",\n  NotExist = \"NotExist\",\n  Rejected = \"Rejected\",\n}\n\nexport interface MsgOpt {\n  readonly type: string;\n  readonly gas: number;\n}\n\nexport interface AccountSetOpts {\n  readonly suggestChain: boolean;\n  readonly suggestChainFn?: (\n    keplr: Keplr,\n    chainInfo: ReturnType<ChainGetter[\"getChain\"]>\n  ) => Promise<void>;\n  readonly autoInit: boolean;\n  readonly getKeplr: () => Promise<Keplr | undefined>;\n}\n\nexport class AccountSetBase {\n  @observable\n  protected _walletVersion: string | undefined = undefined;\n\n  @observable\n  protected _walletStatus: WalletStatus = WalletStatus.NotInit;\n\n  @observable\n  protected _rejectionReason: Error | undefined;\n\n  @observable\n  protected _name: string = \"\";\n\n  @observable\n  protected _bech32Address: string = \"\";\n\n  @observable\n  protected _txTypeInProgress: string = \"\";\n\n  protected pubKey: Uint8Array;\n\n  protected hasInited = false;\n\n  protected sendTokenFns: ((\n    amount: string,\n    currency: AppCurrency,\n    recipient: string,\n    memo: string,\n    stdFee: Partial<StdFee>,\n    signOptions?: KeplrSignOptions,\n    onTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcastFailed?: (e?: Error) => void;\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ) => Promise<boolean>)[] = [];\n\n  protected makeSendTokenTxFns: ((\n    amount: string,\n    currency: AppCurrency,\n    recipient: string\n  ) => MakeTxResponse | undefined)[] = [];\n\n  constructor(\n    protected readonly eventListener: {\n      addEventListener: (type: string, fn: () => unknown) => void;\n      removeEventListener: (type: string, fn: () => unknown) => void;\n    },\n    protected readonly chainGetter: ChainGetter,\n    protected readonly chainId: string,\n    protected readonly opts: AccountSetOpts\n  ) {\n    makeObservable(this);\n\n    this.pubKey = new Uint8Array();\n\n    if (opts.autoInit) {\n      this.init();\n    }\n  }\n\n  getKeplr(): Promise<Keplr | undefined> {\n    return this.opts.getKeplr();\n  }\n\n  registerSendTokenFn(\n    fn: (\n      amount: string,\n      currency: AppCurrency,\n      recipient: string,\n      memo: string,\n      stdFee: Partial<StdFee>,\n      signOptions?: KeplrSignOptions,\n      onTxEvents?:\n        | ((tx: any) => void)\n        | {\n            onBroadcasted?: (txHash: Uint8Array) => void;\n            onFulfill?: (tx: any) => void;\n          }\n    ) => Promise<boolean>\n  ) {\n    this.sendTokenFns.push(fn);\n  }\n\n  registerMakeSendTokenFn(\n    fn: (\n      amount: string,\n      currency: AppCurrency,\n      recipient: string\n    ) => MakeTxResponse | undefined\n  ) {\n    this.makeSendTokenTxFns.push(fn);\n  }\n\n  protected async enable(keplr: Keplr, chainId: string): Promise<void> {\n    const chainInfo = this.chainGetter.getChain(chainId);\n\n    if (this.opts.suggestChain) {\n      if (this.opts.suggestChainFn) {\n        await this.opts.suggestChainFn(keplr, chainInfo);\n      } else {\n        await this.suggestChain(keplr, chainInfo);\n      }\n    }\n    await keplr.enable(chainId);\n  }\n\n  protected async suggestChain(\n    keplr: Keplr,\n    chainInfo: ReturnType<ChainGetter[\"getChain\"]>\n  ): Promise<void> {\n    await keplr.experimentalSuggestChain(chainInfo.raw);\n  }\n\n  private readonly handleInit = () => this.init();\n\n  @flow\n  public *init() {\n    // If wallet status is not exist, there is no need to try to init because it always fails.\n    if (this.walletStatus === WalletStatus.NotExist) {\n      return;\n    }\n\n    // If the store has never been initialized, add the event listener.\n    if (!this.hasInited) {\n      // If key store in the keplr extension is changed, this event will be dispatched.\n      this.eventListener.addEventListener(\n        \"keplr_keystorechange\",\n        this.handleInit\n      );\n    }\n    this.hasInited = true;\n\n    // Set wallet status as loading whenever try to init.\n    this._walletStatus = WalletStatus.Loading;\n\n    const keplr = yield* toGenerator(this.getKeplr());\n    if (!keplr) {\n      this._walletStatus = WalletStatus.NotExist;\n      return;\n    }\n\n    this._walletVersion = keplr.version;\n\n    try {\n      yield this.enable(keplr, this.chainId);\n    } catch (e) {\n      console.log(e);\n      this._walletStatus = WalletStatus.Rejected;\n      this._rejectionReason = e;\n      return;\n    }\n\n    try {\n      const key = yield* toGenerator(keplr.getKey(this.chainId));\n      this._bech32Address = key.bech32Address;\n      this._name = key.name;\n      this.pubKey = key.pubKey;\n\n      // Set the wallet status as loaded after getting all necessary infos.\n      this._walletStatus = WalletStatus.Loaded;\n    } catch (e) {\n      console.log(e);\n      // Caught error loading key\n      // Reset properties, and set status to Rejected\n      this._bech32Address = \"\";\n      this._name = \"\";\n      this.pubKey = new Uint8Array(0);\n\n      this._walletStatus = WalletStatus.Rejected;\n      this._rejectionReason = e;\n    }\n\n    if (this._walletStatus !== WalletStatus.Rejected) {\n      // Reset previous rejection error message\n      this._rejectionReason = undefined;\n    }\n  }\n\n  @action\n  public disconnect(): void {\n    this._walletStatus = WalletStatus.NotInit;\n    this.hasInited = false;\n    this.eventListener.removeEventListener(\n      \"keplr_keystorechange\",\n      this.handleInit\n    );\n    this._bech32Address = \"\";\n    this._name = \"\";\n    this.pubKey = new Uint8Array(0);\n  }\n\n  get walletVersion(): string | undefined {\n    return this._walletVersion;\n  }\n\n  @computed\n  get isReadyToSendTx(): boolean {\n    return (\n      this.walletStatus === WalletStatus.Loaded && this.bech32Address !== \"\"\n    );\n  }\n\n  /**\n   * @deprecated Use `isReadyToSendTx`\n   */\n  @computed\n  get isReadyToSendMsgs(): boolean {\n    return (\n      this.walletStatus === WalletStatus.Loaded && this.bech32Address !== \"\"\n    );\n  }\n\n  makeSendTokenTx(\n    amount: string,\n    currency: AppCurrency,\n    recipient: string\n  ): MakeTxResponse {\n    for (let i = 0; i < this.makeSendTokenTxFns.length; i++) {\n      const fn = this.makeSendTokenTxFns[i];\n\n      const res = fn(amount, currency, recipient);\n      if (res) {\n        return res;\n      }\n    }\n\n    const denomHelper = new DenomHelper(currency.coinMinimalDenom);\n\n    throw new Error(`Unsupported type of currency (${denomHelper.type})`);\n  }\n\n  async sendToken(\n    amount: string,\n    currency: AppCurrency,\n    recipient: string,\n    memo: string = \"\",\n    stdFee: Partial<StdFee> = {},\n    signOptions?: KeplrSignOptions,\n    onTxEvents?:\n      | ((tx: any) => void)\n      | {\n          onBroadcasted?: (txHash: Uint8Array) => void;\n          onFulfill?: (tx: any) => void;\n        }\n  ) {\n    for (let i = 0; i < this.sendTokenFns.length; i++) {\n      const fn = this.sendTokenFns[i];\n\n      if (\n        await fn(\n          amount,\n          currency,\n          recipient,\n          memo,\n          stdFee,\n          signOptions,\n          onTxEvents\n        )\n      ) {\n        return;\n      }\n    }\n\n    const denomHelper = new DenomHelper(currency.coinMinimalDenom);\n\n    throw new Error(`Unsupported type of currency (${denomHelper.type})`);\n  }\n\n  get walletStatus(): WalletStatus {\n    return this._walletStatus;\n  }\n\n  get rejectionReason(): Error | undefined {\n    return this._rejectionReason;\n  }\n\n  get name(): string {\n    return this._name;\n  }\n\n  get bech32Address(): string {\n    return this._bech32Address;\n  }\n\n  /**\n   * Returns the tx type in progress waiting to be committed.\n   * If there is no tx type in progress, this returns an empty string (\"\").\n   */\n  get txTypeInProgress(): string {\n    return this._txTypeInProgress;\n  }\n\n  /**\n   * @deprecated Use `txTypeInProgress`\n   */\n  get isSendingMsg(): string | boolean {\n    return this.txTypeInProgress;\n  }\n\n  get hasEthereumHexAddress(): boolean {\n    return (\n      this.chainGetter\n        .getChain(this.chainId)\n        .features?.includes(\"eth-address-gen\") ?? false\n    );\n  }\n\n  @computed\n  get ethereumHexAddress(): string {\n    if (this.bech32Address === \"\") {\n      return \"\";\n    }\n\n    return Bech32Address.fromBech32(\n      this.bech32Address,\n      this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr\n    ).toHex(true);\n  }\n}\n\nexport class AccountSetBaseSuper extends AccountSetBase {\n  constructor(...params: ConstructorParameters<typeof AccountSetBase>) {\n    super(...params);\n\n    makeObservable(this);\n  }\n\n  @action\n  setTxTypeInProgress(type: string): void {\n    this._txTypeInProgress = type;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}